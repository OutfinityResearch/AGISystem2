{
  "id": "suite_11_recursive_small",
  "name": "Recursive Planning Problems - Small Scale",
  "description": "Tests recursive reasoning with classic AI problems: Wolf-Goat-Cabbage river crossing and Towers of Hanoi with 3-4 disks. These problems require planning, constraint satisfaction, and recursive decomposition.",
  "theory": {
    "natural_language": "Wolf-Goat-Cabbage Problem: A farmer needs to cross a river with a wolf, a goat, and a cabbage. The boat can only carry the farmer and one item at a time. Constraints: If left alone without the farmer, the wolf will eat the goat. If left alone without the farmer, the goat will eat the cabbage. The wolf will not eat the cabbage. Goal: Get all three items across safely. Initial state: All on left bank. Towers of Hanoi (3 disks): Three pegs named A, B, C. Three disks of different sizes: small, medium, large. Initial state: All disks on peg A (large at bottom, small on top). Goal: Move all disks to peg C. Rules: Only one disk can be moved at a time. Only the top disk of a stack can be moved. A larger disk cannot be placed on a smaller disk. Minimum moves for 3 disks: 7 moves (2^n - 1 formula).",
    "expected_facts": [
      "wolf EATS goat",
      "goat EATS cabbage",
      "wolf NOT_EATS cabbage",
      "wolf_and_goat_alone CAUSES goat_eaten",
      "goat_and_cabbage_alone CAUSES cabbage_eaten",
      "wolf_and_cabbage_alone IS safe",
      "first_move IS farmer_takes_goat",
      "crossing_4 REQUIRES bring_goat_back",
      "wolf_goat_cabbage HAS_SOLUTION 7_crossings",
      "wolf_goat_cabbage NOT_SOLVABLE_IN less_than_7",
      "hanoi_3_disks REQUIRES 7_moves",
      "hanoi_4_disks REQUIRES 15_moves",
      "hanoi_n_disks FORMULA 2_power_n_minus_1",
      "disk_small SMALLER_THAN disk_medium",
      "disk_medium SMALLER_THAN disk_large",
      "large_on_small IS forbidden",
      "hanoi_rule IS move_only_top_disk",
      "hanoi RECURSIVE_PATTERN move_n_minus_1_then_largest_then_n_minus_1"
    ],
    "problems": {
      "wolf_goat_cabbage": {
        "description": "River crossing puzzle",
        "solution_steps": [
          "1. Farmer takes goat to right bank",
          "2. Farmer returns alone",
          "3. Farmer takes wolf to right bank",
          "4. Farmer returns with goat",
          "5. Farmer takes cabbage to right bank",
          "6. Farmer returns alone",
          "7. Farmer takes goat to right bank"
        ],
        "total_crossings": 7
      },
      "hanoi_3": {
        "description": "Towers of Hanoi with 3 disks",
        "solution_steps": [
          "1. Move small from A to C",
          "2. Move medium from A to B",
          "3. Move small from C to B",
          "4. Move large from A to C",
          "5. Move small from B to A",
          "6. Move medium from B to C",
          "7. Move small from A to C"
        ],
        "total_moves": 7
      },
      "hanoi_4": {
        "description": "Towers of Hanoi with 4 disks",
        "total_moves": 15,
        "recursive_pattern": "Move n-1 disks to auxiliary, move largest to target, move n-1 from auxiliary to target"
      }
    }
  },
  "queries": [
    {
      "id": "q1",
      "natural_language": "In the wolf-goat-cabbage problem, what happens if the farmer leaves the wolf and goat alone?",
      "expected_dsl": "@q1 wolf_and_goat_alone CAUSES goat_eaten",
      "expected_answer": {
        "natural_language": "If the farmer leaves the wolf and goat alone on either bank, the wolf will eat the goat. This is a constraint that must be avoided.",
        "truth": "TRUE_CERTAIN",
        "explanation": "Direct constraint: wolf eats goat when farmer absent",
        "existence": "positive"
      }
    },
    {
      "id": "q2",
      "natural_language": "What should be the first move in the wolf-goat-cabbage problem?",
      "expected_dsl": "@q2 first_move IS farmer_takes_goat",
      "expected_answer": {
        "natural_language": "The farmer must take the goat first. This is the only safe first move because: leaving wolf+goat alone = goat eaten, leaving goat+cabbage alone = cabbage eaten, but wolf+cabbage alone is safe.",
        "truth": "TRUE_CERTAIN",
        "explanation": "Constraint satisfaction: only goat-first avoids all violations",
        "existence": "positive"
      }
    },
    {
      "id": "q3",
      "natural_language": "Can the wolf-goat-cabbage problem be solved in fewer than 7 crossings?",
      "expected_dsl": "@q3 wolf_goat_cabbage NOT_SOLVABLE_IN less_than_7",
      "expected_answer": {
        "natural_language": "No, 7 crossings is the minimum. The constraints force specific moves, and there is no shorter valid sequence.",
        "truth": "TRUE_CERTAIN",
        "explanation": "Optimal solution requires exactly 7 crossings",
        "existence": "positive"
      }
    },
    {
      "id": "q4",
      "natural_language": "How many moves are needed for Towers of Hanoi with 3 disks?",
      "expected_dsl": "@q4 hanoi_3_disks REQUIRES 7_moves",
      "expected_answer": {
        "natural_language": "7 moves are needed. The formula is 2^n - 1, so for n=3: 2^3 - 1 = 8 - 1 = 7.",
        "truth": "TRUE_CERTAIN",
        "explanation": "Mathematical formula: 2^3 - 1 = 7",
        "existence": "positive"
      }
    },
    {
      "id": "q5",
      "natural_language": "In Hanoi, can a large disk be placed on a small disk?",
      "expected_dsl": "@q5 large_on_small IS forbidden",
      "expected_answer": {
        "natural_language": "No, a larger disk cannot be placed on a smaller disk. This is a fundamental rule of the Towers of Hanoi.",
        "truth": "TRUE_CERTAIN",
        "explanation": "Hanoi rule: LARGER_ON_SMALLER forbidden",
        "existence": "positive"
      }
    },
    {
      "id": "q6",
      "natural_language": "What is the recursive pattern for solving Towers of Hanoi?",
      "expected_dsl": "@q6 hanoi RECURSIVE_PATTERN move_n_minus_1_then_largest_then_n_minus_1",
      "expected_answer": {
        "natural_language": "The recursive pattern is: 1) Move n-1 disks from source to auxiliary peg, 2) Move the largest disk from source to target peg, 3) Move n-1 disks from auxiliary to target peg. Base case: 1 disk = 1 move.",
        "truth": "TRUE_CERTAIN",
        "explanation": "Classic recursive decomposition of Hanoi",
        "existence": "positive"
      }
    },
    {
      "id": "q7",
      "natural_language": "How many moves are needed for Towers of Hanoi with 4 disks?",
      "expected_dsl": "@q7 hanoi_4_disks REQUIRES 15_moves",
      "expected_answer": {
        "natural_language": "15 moves are needed. Using the formula 2^n - 1: 2^4 - 1 = 16 - 1 = 15.",
        "truth": "TRUE_CERTAIN",
        "explanation": "Mathematical formula: 2^4 - 1 = 15",
        "existence": "positive"
      }
    },
    {
      "id": "q8",
      "natural_language": "In wolf-goat-cabbage, why must the farmer bring the goat back on the 4th crossing?",
      "expected_dsl": "@q8 crossing_4 REQUIRES bring_goat_back",
      "expected_answer": {
        "natural_language": "After taking the wolf to the right bank (crossing 3), the farmer must bring the goat back because leaving wolf+goat together on the right bank would result in the wolf eating the goat. The goat acts as a 'shuttle' that must be carefully managed.",
        "truth": "TRUE_CERTAIN",
        "explanation": "Constraint avoidance: wolf+goat alone violates safety",
        "existence": "positive"
      }
    }
  ],
  "tags": [
    "recursive",
    "planning",
    "constraints",
    "hanoi",
    "wolf-goat-cabbage",
    "puzzle",
    "small-scale"
  ],
  "version": "3.0"
}
