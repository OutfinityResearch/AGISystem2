<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Syntax – Sys2DSL</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Sys2DSL: Session &amp; Theory Scripts</h1>
  </div>

  <p>Sys2DSL is the textual language used to describe all reasoning logic in an AGISystem2 session or theory file. There is no separate concept of “macro”: a theory is simply a multi‑line Sys2DSL programme.</p>

  <h2>Basic Line Form</h2>
  <p>Every Sys2DSL instruction is a line (or a fragment of a line) of the form:</p>
  <pre><code>@varName ACTION arg1 arg2 ...</code></pre>

  <ul>
    <li><code>@varName</code> defines a variable name in the script environment (for example <code>@f1</code>, <code>@q1</code>, <code>@mask</code>).</li>
    <li><code>ACTION</code> is an uppercase keyword (for example <code>ASSERT</code>, <code>ASK</code>, <code>CF</code>, <code>FACTS_MATCHING</code>, <code>ALL_REQUIREMENTS_SATISFIED</code>, <code>MASK_DIMS</code>).</li>
    <li><code>arg1 arg2 ...</code> are the action parameters: simple words or quoted strings, optionally with variable references.</li>
  </ul>

  <p>Comments are lines starting with <code>#</code> and are ignored. Extra spaces between tokens are allowed.</p>

  <h2>Tokens and Variables</h2>
  <p>Conventions for tokens in arguments:</p>
  <ul>
    <li>words starting with a lowercase letter (<code>dog</code>, <code>water</code>, <code>export_data</code>) – concept names;</li>
    <li>words starting with an uppercase letter (<code>Alice</code>, <code>CityX</code>) – individuals or concrete instances;</li>
    <li>words starting with <code>$</code> (<code>$reqs</code>, <code>$list</code>) – references to variables defined earlier (via <code>@reqs</code>, <code>@list</code>);</li>
    <li>double‑quoted strings – complete texts (for example questions or search patterns) that may contain spaces, <code>?</code>, <code>=</code> etc.</li>
  </ul>

  <p>Variables are bound at the time the instruction that defines them is executed. Any instruction that uses <code>$name</code> depends on the instruction that defined <code>@name</code>.</p>

  <h2>Statements and Topological Evaluation</h2>
  <p>A Sys2DSL script is a list of instructions. Statements are delimited as follows:</p>
  <ul>
    <li>each occurrence of <code>@</code> that starts a word marks the beginning of a new statement;</li>
    <li>you may write a single instruction per line or several instructions on the same line, as long as each starts with its own <code>@</code>:</li>
  </ul>

  <pre><code>@f1 ASSERT Dog IS_A Animal
@f2 ASSERT Water BOILS_AT Celsius100
@f3 ASSERT Celsius100 IS_A temperature
@q1 ASK "Is Dog an Animal?"
@q2 ASK "Water BOILS_AT Celsius100?"</code></pre>

  <pre><code>@f1 ASSERT Dog IS_A Animal @q1 ASK "Is Dog an Animal?"</code></pre>

  <p>Instead of executing lines strictly in textual order, the interpreter first builds a dependency graph between variables (based on <code>$name</code> occurrences) and evaluates instructions in a topological order. This allows you to write:</p>

  <pre><code>@b BOOL_AND $a $a
@a NONEMPTY $list
@list FACTS_MATCHING "Dog IS_A Animal"</code></pre>

  <p>even though <code>@b</code> appears first textually; the engine will evaluate <code>@list</code> first, then <code>@a</code>, then <code>@b</code>. Cyclic dependencies (for example <code>@a</code> depending on <code>$b</code> and <code>@b</code> on <code>$a</code>) are detected and reported as errors.</p>

  <h2>Command Categories</h2>
  <p>Sys2DSL commands are organized into functional categories. See DS(/theory/Sys2DSL_commands) for the complete reference with 40+ commands.</p>

  <h3>Query Commands</h3>
  <pre><code>@q1 ASK Dog IS_A Animal                    # Query truth value
@q2 ASK "Is Dog an Animal?"                # Natural question form
@masked ASK_MASKED $ontologyMask Dog IS_A Animal  # Masked query
@facts FACTS_MATCHING Dog ? ?              # Pattern search</code></pre>

  <h3>Assertion Commands</h3>
  <pre><code>@f1 ASSERT Dog IS_A Animal
@f2 ASSERT Water BOILS_AT Celsius100
@r1 RETRACT Dog IS_A Fish                  # Remove fact</code></pre>

  <h3>Reasoning Commands</h3>
  <pre><code>@proof PROVE Dog IS_A LivingThing          # Prove with chain
@valid VALIDATE                            # Check consistency
@hyp HYPOTHESIZE Smoke                     # Generate hypotheses
@cf CF "Water IS_A gas?" | Water TEMPERATURE_AT Celsius150
@abd ABDUCT Smoke CAUSED_BY                # Abductive reasoning</code></pre>

  <h3>Theory Layer Commands</h3>
  <pre><code>@_ THEORY_PUSH name="exploration"          # Push new layer
@_ THEORY_POP                              # Pop and discard
@stack LIST_THEORIES                       # Show layer stack
@load LOAD_THEORY physics_basics           # Load from file
@save SAVE_THEORY my_domain                # Save to file</code></pre>

  <h3>Memory Management Commands</h3>
  <pre><code>@stats GET_USAGE Water                     # Usage statistics
@_ PROTECT ImportantConcept                # Protect from forgetting
@_ UNPROTECT TempConcept                   # Remove protection
@clean FORGET threshold=5                  # Remove low-usage
@_ BOOST Water 50                          # Increase priority</code></pre>

  <h3>Mask Commands</h3>
  <pre><code>@m1 MASK_PARTITIONS ontology               # By partition
@m2 MASK_DIMS temperature pressure         # By dimensions
@m3 MASK_CONCEPT $waterRef                 # By concept relevance</code></pre>

  <h3>Utility Commands</h3>
  <pre><code>@and BOOL_AND $q1 $q2                      # Boolean AND
@or BOOL_OR $q1 $q2                        # Boolean OR
@not BOOL_NOT $q1                          # Boolean NOT
@merged MERGE_LISTS $list1 $list2          # Combine lists
@first PICK_FIRST $list                    # First element
@n COUNT $list                             # List size
@nonEmpty NONEMPTY $list                   # Check if non-empty</code></pre>

  <h3>Output Commands</h3>
  <pre><code>@text TO_NATURAL $result                   # Human-readable
@json TO_JSON $result                      # JSON export
@exp EXPLAIN $result                       # Detailed explanation</code></pre>

  <h2>Complete Example</h2>
  <p>A compliance check programme demonstrating multiple command types:</p>
  <pre><code># Fetch procedure requirements
@reqs FACTS_MATCHING "$procId REQUIRES ?"
@satGiven FACTS_MATCHING "? GIVEN yes"
@satPresent FACTS_MATCHING "? PRESENT yes"
@allSat MERGE_LISTS $satGiven $satPresent
@result ALL_REQUIREMENTS_SATISFIED $reqs $allSat

# Check and report
@check ASK ProcedureX COMPLIANT yes
@explanation EXPLAIN $check</code></pre>

  <h2>Sys2DSL in Theory Files vs. Sessions</h2>
  <p>The same language is used in two contexts:</p>
  <ul>
    <li><strong>Theory files</strong> – text files (for example <code>*.sys2dsl</code>) versioned in Git, containing reusable Sys2DSL programmes for a domain (health rules, export rules, narratives, etc.).</li>
    <li><strong>Session scripts</strong> – strings or arrays of lines sent to a <code>System2Session</code> to add facts, run checks or explore counterfactuals.</li>
  </ul>

  <p>There is no syntax difference between the two; only the loading method differs (persistent files vs. commands sent via API/CLI).</p>

  <h2>Summary</h2>
  <p>Sys2DSL is the only textual‑level language used to talk to AGISystem2. Facts, questions and verification programmes are all expressed as sequences of <code>@var ACTION …</code> instructions, evaluated in a deterministic and easily auditable way.</p>

  <h2>References</h2>
  <p>For implementation details, see the relevant design specifications (referenced by ID):</p>
  <ul>
    <li>DS[/theory/dsl_engine.js] – Sys2DSL interpreter and action set.</li>
    <li>DS[/theory/Sys2DSL_arch]</li>
    <li>DS[/theory/topological_eval]</li>
    <li>DS[/interface/system2_session.js]</li>
  </ul>

  <div class="footer-nav">
    <a href="index.html">Back to Syntax overview</a>
    <a href="../index.html">Back to index</a>
  </div>
  </div>
  <script src="nav.js"></script>
</body>
</html>
