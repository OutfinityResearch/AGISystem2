<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Syntax – Sys2DSL</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Sys2DSL: Session &amp; Theory Scripts</h1>
  </div>

  <p>Sys2DSL is the textual language used to describe all reasoning logic in an AGISystem2 session or theory file. There is no separate concept of “macro”: a theory is simply a multi‑line Sys2DSL programme.</p>

  <h2>Basic Line Form</h2>
  <p>Every Sys2DSL instruction is a line (or a fragment of a line) of the form:</p>
  <pre><code>@varName ACTION arg1 arg2 ...</code></pre>

  <ul>
    <li><code>@varName</code> defines a variable name in the script environment (for example <code>@f1</code>, <code>@q1</code>, <code>@mask</code>).</li>
    <li><code>ACTION</code> is an uppercase keyword (for example <code>ASSERT</code>, <code>ASK</code>, <code>CF</code>, <code>FACTS_MATCHING</code>, <code>ALL_REQUIREMENTS_SATISFIED</code>, <code>MASK_DIMS</code>).</li>
    <li><code>arg1 arg2 ...</code> are the action parameters: simple words or quoted strings, optionally with variable references.</li>
  </ul>

  <p>Comments are lines starting with <code>#</code> and are ignored. Extra spaces between tokens are allowed.</p>

  <h2>Tokens and Variables</h2>
  <p>Conventions for tokens in arguments:</p>
  <ul>
    <li>words starting with a lowercase letter (<code>dog</code>, <code>water</code>, <code>export_data</code>) – concept names;</li>
    <li>words starting with an uppercase letter (<code>Alice</code>, <code>CityX</code>) – individuals or concrete instances;</li>
    <li>words starting with <code>$</code> (<code>$reqs</code>, <code>$list</code>) – references to variables defined earlier (via <code>@reqs</code>, <code>@list</code>);</li>
    <li>double‑quoted strings – complete texts (for example questions or search patterns) that may contain spaces, <code>?</code>, <code>=</code> etc.</li>
  </ul>

  <p>Variables are bound at the time the instruction that defines them is executed. Any instruction that uses <code>$name</code> depends on the instruction that defined <code>@name</code>.</p>

  <h2>Statements and Topological Evaluation</h2>
  <p>A Sys2DSL script is a list of instructions. Statements are delimited as follows:</p>
  <ul>
    <li>each occurrence of <code>@</code> that starts a word marks the beginning of a new statement;</li>
    <li>you may write a single instruction per line or several instructions on the same line, as long as each starts with its own <code>@</code>:</li>
  </ul>

  <pre><code>@_ Dog IS_A Animal
@_ Water BOILS_AT Celsius100
@_ Celsius100 IS_A temperature
@q1 "Is Dog an Animal?" ASK any
@q2 "Water BOILS_AT Celsius100?" ASK any</code></pre>

  <pre><code>@_ Dog IS_A Animal @q1 "Is Dog an Animal?" ASK any</code></pre>

  <p>Instead of executing lines strictly in textual order, the interpreter first builds a dependency graph between variables (based on <code>$name</code> occurrences) and evaluates instructions in a topological order. This allows you to write:</p>

  <pre><code>@b BOOL_AND $a $a
@a NONEMPTY $list
@list FACTS_MATCHING "Dog IS_A Animal"</code></pre>

  <p>even though <code>@b</code> appears first textually; the engine will evaluate <code>@list</code> first, then <code>@a</code>, then <code>@b</code>. Cyclic dependencies (for example <code>@a</code> depending on <code>$b</code> and <code>@b</code> on <code>$a</code>) are detected and reported as errors.</p>

  <h2>Command Categories</h2>
  <p>Sys2DSL commands are organized into functional categories. See DS(/theory/Sys2DSL_commands) for the complete reference with 40+ commands.</p>

  <h3>Query Commands</h3>
  <pre><code>@q1 Dog IS_A Animal                        # Query truth value
@q2 "Is Dog an Animal?" ASK any            # Natural question form
@masked Dog IS_A Animal                    # Masked query
@facts Dog FACTS any                       # Pattern search</code></pre>

  <h3>Assertion Commands</h3>
  <pre><code>@_ Dog IS_A Animal
@_ Water BOILS_AT Celsius100
@r1 Dog IS_A Fish                          # Remove fact</code></pre>

  <h3>Reasoning Commands</h3>
  <pre><code>@proof Dog PROVE LivingThing               # Prove with chain
@valid any VALIDATE any                    # Check consistency
@hyp Smoke HYPOTHESIZE any                 # Generate hypotheses
@cf "Water IS_A gas?" CF any
@abd Smoke ABDUCT any                      # Abductive reasoning</code></pre>

  <h3>Theory Layer Commands</h3>
  <pre><code>@_ exploration PUSH any                    # Push new layer
@_ any POP any                             # Pop and discard
@stack any THEORIES any                    # Show layer stack
@load physics_basics LOAD any              # Load from file
@save my_domain SAVE any                   # Save to file</code></pre>

  <h3>Memory Management Commands</h3>
  <pre><code>@stats Water GET_USAGE any                 # Usage statistics
@_ ImportantConcept PROTECT any            # Protect from forgetting
@_ TempConcept UNPROTECT any               # Remove protection
@p threshold DIM_PAIR 5
@clean threshold FORGET any                # Remove low-usage
@_ Water BOOST 50                          # Increase priority</code></pre>

  <h3>Mask Commands</h3>
  <pre><code>@m1 ontology MASK_PARTITIONS any           # By partition
@m2 temperature MASK_DIMS pressure         # By dimensions
@m3 $waterRef MASK_CONCEPT any             # By concept relevance</code></pre>

  <h3>Utility Commands</h3>
  <pre><code>@and BOOL_AND $q1 $q2                      # Boolean AND
@or BOOL_OR $q1 $q2                        # Boolean OR
@not BOOL_NOT $q1                          # Boolean NOT
@merged MERGE_LISTS $list1 $list2          # Combine lists
@first PICK_FIRST $list                    # First element
@n COUNT $list                             # List size
@nonEmpty NONEMPTY $list                   # Check if non-empty</code></pre>

  <h3>Output Commands</h3>
  <pre><code>@text $result TO_NATURAL any               # Human-readable
@json $result TO_JSON any                  # JSON export
@exp $result EXPLAIN any                   # Detailed explanation</code></pre>

  <h2>Complete Example</h2>
  <p>A compliance check programme demonstrating multiple command types:</p>
  <pre><code># Fetch procedure requirements
@reqs "$procId REQUIRES ?" FACTS any
@satGiven "? GIVEN yes" FACTS any
@satPresent "? PRESENT yes" FACTS any
@allSat $satGiven MERGE_LISTS $satPresent
@result $reqs ALL_REQUIREMENTS_SATISFIED $allSat

# Check and report
@check ProcedureX IS_COMPLIANT yes
@explanation $check EXPLAIN any</code></pre>

  <h2>Sys2DSL in Theory Files vs. Sessions</h2>
  <p>The same language is used in two contexts:</p>
  <ul>
    <li><strong>Theory files</strong> – text files (for example <code>*.sys2dsl</code>) versioned in Git, containing reusable Sys2DSL programmes for a domain (health rules, export rules, narratives, etc.).</li>
    <li><strong>Session scripts</strong> – strings or arrays of lines sent to a <code>System2Session</code> to add facts, run checks or explore counterfactuals.</li>
  </ul>

  <p>There is no syntax difference between the two; only the loading method differs (persistent files vs. commands sent via API/CLI).</p>

  <h2>Summary</h2>
  <p>Sys2DSL is the only textual‑level language used to talk to AGISystem2. Facts, questions and verification programmes are all expressed as sequences of <code>@var ACTION …</code> instructions, evaluated in a deterministic and easily auditable way.</p>

  <h2>References</h2>
  <p>For implementation details, see the relevant design specifications (referenced by ID):</p>
  <ul>
    <li>DS[/theory/dsl_engine.js] – Sys2DSL interpreter and action set.</li>
    <li>DS[/theory/Sys2DSL_arch]</li>
    <li>DS[/theory/topological_eval]</li>
    <li>DS[/interface/system2_session.js]</li>
  </ul>

  <div class="footer-nav">
    <a href="index.html">Back to Syntax overview</a>
    <a href="../index.html">Back to index</a>
  </div>
  </div>
  <script src="nav.js"></script>
</body>
</html>
