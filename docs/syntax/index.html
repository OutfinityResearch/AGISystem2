<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Syntax - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Sys2DSL Syntax Reference</h1>
    <small>
      <a href="../index.html">Home</a> ·
      <a href="../architecture/index.html">Architecture</a> ·
      <a href="../theory/index.html">Theory</a> ·
      <a href="index.html"><strong>Syntax</strong></a> ·
      <a href="../api/index.html">APIs</a> ·
      <a href="../specs/matrix.html">Specs</a> ·
      <a href="../research/index.html">Research</a>
    </small>
    <small>Domain-Specific Language for knowledge representation</small>
  </div>

  <div class="section-intro">
    <p><strong>Sys2DSL</strong> (System 2 Domain-Specific Language) is a minimal, uniform language where every statement encodes semantic relationships as Subject-Verb-Object triplets. All concepts, facts, and operations are represented as vectors.</p>
  </div>

  <h2>Core Principle</h2>

  <div class="alert alert-info">
    <strong>"Everything is a Vector"</strong>
    <p>Atoms, operators, facts, roles, and theories are ALL represented as hypervectors. The DSL provides human-readable syntax that compiles to vector operations.</p>
  </div>

  <h2>Position Binding Model</h2>

  <p>Every statement is encoded using position vectors that tag each argument:</p>

  <div class="alert alert-info">
    <strong>Binding Formula:</strong>
    <pre style="background: transparent; padding: 10px 0; margin: 10px 0;"><code>destination = Operator ⊕ (Pos1 ⊕ arg1) ⊕ (Pos2 ⊕ arg2) ⊕ (Pos3 ⊕ arg3) ⊕ ...</code></pre>
    <p>Each argument is tagged with its position vector (Pos1, Pos2, etc.) before being XORed into the result. This encodes argument order without using permutation.</p>
  </div>

  <p><strong>Example:</strong></p>
  <pre><code>@rel loves John Mary
# Encoded as: rel = loves ⊕ (Pos1 ⊕ John) ⊕ (Pos2 ⊕ Mary)
# Note: loves(John, Mary) ≠ loves(Mary, John) because Pos1⊕John ≠ Pos1⊕Mary</code></pre>

  <h2>Basic Statement Syntax</h2>

  <p>Four statement forms with different storage behavior:</p>

  <table>
    <tr>
      <th>Form</th>
      <th>In Scope</th>
      <th>In KB</th>
      <th>Use Case</th>
    </tr>
    <tr>
      <td><code>operator arg1 arg2</code></td>
      <td>No</td>
      <td><strong>Yes</strong></td>
      <td>Simple facts (anonymous, auto-persisted)</td>
    </tr>
    <tr>
      <td><code>@var operator arg1 arg2</code></td>
      <td><strong>Yes</strong></td>
      <td>No</td>
      <td>Temporary variable (for references)</td>
    </tr>
    <tr>
      <td><code>@var:name operator arg1 arg2</code></td>
      <td><strong>Yes</strong></td>
      <td><strong>Yes</strong></td>
      <td>Named persistent fact</td>
    </tr>
    <tr>
      <td><code>@:name operator arg1 arg2</code></td>
      <td>No</td>
      <td><strong>Yes</strong></td>
      <td>KB only (no local reference needed)</td>
    </tr>
  </table>

  <h3>Examples</h3>

  <pre><code># Anonymous fact (stored in KB only)
isA Dog Animal
loves John Mary

# Scope-only variable (can reference later)
@fact1 loves John Mary
@rule1 Implies $fact1 $conclusion

# Named persistent fact (both scope and KB)
@Person:Person __Category
@myRule:inheritance Implies (isA ?x Dog) (isA ?x Animal)

# Discard result (execute but don't store)
@_ Load $Commerce

# KB-only export (no local variable needed)
@:Pythagorean_Theorem Implies $premise $conclusion</code></pre>

  <h2>Token Types</h2>

  <table>
    <tr>
      <th>Token</th>
      <th>Syntax</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
    <tr>
      <td><code>@var</code></td>
      <td>Declaration</td>
      <td>Create and assign variable</td>
      <td><code>@f1 loves John Mary</code></td>
    </tr>
    <tr>
      <td><code>@var:name</code></td>
      <td>Declare + KB</td>
      <td>Create variable AND add to KB as name</td>
      <td><code>@Person:Person __Atom</code></td>
    </tr>
    <tr>
      <td><code>@:name</code></td>
      <td>KB only</td>
      <td>Add to KB without local variable</td>
      <td><code>@:myFact isA Dog Animal</code></td>
    </tr>
    <tr>
      <td><code>@_</code></td>
      <td>Discard</td>
      <td>Execute but don't store result</td>
      <td><code>@_ Load $Theory</code></td>
    </tr>
    <tr>
      <td><code>$var</code></td>
      <td>Reference</td>
      <td>Access existing variable</td>
      <td><code>@f2 isA $John Person</code></td>
    </tr>
    <tr>
      <td><code>?var</code></td>
      <td>Hole</td>
      <td>Unknown value to find</td>
      <td><code>@q loves ?who Mary</code></td>
    </tr>
    <tr>
      <td><code>name</code></td>
      <td>Literal</td>
      <td>Atom from vocabulary</td>
      <td><code>John</code>, <code>loves</code></td>
    </tr>
    <tr>
      <td><code>#</code></td>
      <td>Comment</td>
      <td>Ignored until end of line</td>
      <td><code># This is a comment</code></td>
    </tr>
  </table>

  <h2>Abstraction Levels</h2>

  <p>Names follow a prefix convention indicating abstraction level:</p>

  <table>
    <tr>
      <th>Level</th>
      <th>Prefix</th>
      <th>Purpose</th>
      <th>User</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>L0</td>
      <td><code>___</code></td>
      <td>HDC primitives</td>
      <td>Runtime only</td>
      <td><code>___Bind</code></td>
    </tr>
    <tr>
      <td>L1</td>
      <td><code>__</code></td>
      <td>Structural operations</td>
      <td>Core theory</td>
      <td><code>__Atom</code>, <code>__Bundle</code></td>
    </tr>
    <tr>
      <td>L2</td>
      <td><code>_</code></td>
      <td>Semantic primitives</td>
      <td>Knowledge engineers</td>
      <td><code>_ptrans</code>, <code>_atrans</code></td>
    </tr>
    <tr>
      <td>L3+</td>
      <td>(none)</td>
      <td>Domain concepts</td>
      <td>End users</td>
      <td><code>Person</code>, <code>loves</code></td>
    </tr>
  </table>

  <h2>Comments</h2>

  <pre><code># Line comment (shell style)
// Line comment (C++ style)

/* Block comment
   can span multiple lines */</code></pre>

  <h2>Theory Definition</h2>

  <p>Theories are named collections of atoms, macros, and rules. Four syntax variants supported:</p>

  <h3>Primary Syntax (Recommended)</h3>

  <pre><code>@TheoryName theory GEOMETRY INIT_MODE
    # statements
end</code></pre>

  <h3>Bracket Syntax</h3>

  <pre><code>theory Name {
    # statements
}</code></pre>

  <h3>Begin/End Syntax</h3>

  <pre><code>theory Name begin
    # statements
end</code></pre>

  <h3>Legacy Bracket Syntax</h3>

  <pre><code>theory Name [
    # statements
]</code></pre>

  <h3>Theory Parameters</h3>

  <table>
    <tr>
      <th>Parameter</th>
      <th>Values</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>GEOMETRY</td>
      <td>2048, 8192, 32768, etc.</td>
      <td>Vector dimension (Dense-Binary) or k value (SPHDC)</td>
    </tr>
    <tr>
      <td>INIT_MODE</td>
      <td><code>deterministic</code>, <code>random</code></td>
      <td>How atoms are initialized</td>
    </tr>
  </table>

  <h3>Complete Theory Example</h3>

  <pre><code>@Animals theory 32768 deterministic

    # Categories
    @Animal:Animal __Category
    @Dog:Dog __Category
    @Cat:Cat __Category

    # Taxonomy
    isA Dog Animal
    isA Cat Animal

    # Properties
    @bark:bark __Relation
    @meow:meow __Relation

    # Rules (build complex rules step by step)
    @isDog isA ?x Dog
    @canBark canDo ?x bark
    @barkRule Implies $isDog $canBark

end</code></pre>

  <h2>Graph Definition</h2>

  <p>Graphs are named procedures that process arguments and return a result:</p>

  <pre><code>@GraphName:exportName graph param1 param2 param3
    # Statements using parameters
    @local1 someOp $param1 $param2
    @local2 otherOp $local1 $param3

    # Return value
    return $local2
end</code></pre>

  <p>When a statement uses an operator that has a graph, the graph is executed first:</p>

  <pre><code>@tx sell Alice Bob Car 100
# 1. Execute sell graph with args (Alice, Bob, Car, 100) → graphResult
# 2. Bind: tx = sell ⊕ graphResult</code></pre>

  <h3>Graph Examples</h3>

  <pre><code># Define a person creation graph
@DefinePerson:person graph name age occupation
    @p1 isA $name Person
    @p2 hasAge $name $age
    @p3 hasJob $name $occupation
    @result __Bundle $p1 $p2 $p3
    return $result
end

# Use the graph
@john person John 30 Engineer
@mary person Mary 25 Doctor

# Graph with holes for pattern matching
@:FindKiller graph victim
    @result kill ?murderer $victim
    return $result
end</code></pre>

  <h2>Query Syntax</h2>

  <p>Queries use <code>?</code> prefix for unknown values (holes):</p>

  <pre><code># Single hole - "Who loves Mary?"
@q1 loves ?who Mary

# Multiple holes - "Who bought what from whom?"
@q2 buy ?buyer ?item ?seller

# Mixed known and unknown
@q3 sell Alice ?what Bob</code></pre>

  <h3>Query Results</h3>

  <pre><code>QueryResult {
  success: true,
  bindings: {
    "who": { answer: "John", similarity: 0.78, alternatives: [...] }
  },
  confidence: 0.78,
  ambiguous: false
}</code></pre>

  <h2>FindAll and CSP Queries</h2>

  <p>In addition to similarity-based queries (best match), Sys2DSL supports enumeration queries that return ALL matches.</p>

  <h3>FindAll Pattern</h3>

  <pre><code># Standard query - returns best match
@q loves ?who Mary
# Result: { who: 'John' } (single best)

# FindAll - returns ALL matches
@all findAll seatedAt ?person Table1
# Result: [{ person: 'Alice' }, { person: 'Bob' }]

# Find all entities of a type
@guests findAllOfType Guest
# Result: ['Alice', 'Bob', 'Carol']</code></pre>

  <h3>CSP Solver (Constraint Satisfaction)</h3>

  <p>For combinatorial problems requiring ALL valid solutions:</p>

  <pre><code># Define problem in KB
isA Alice Guest
isA Bob Guest
isA Table1 Table
isA Table2 Table
conflictsWith Alice Bob

# Solve via API
session.solveWeddingSeating()
# Result: [
#   { Alice: 'Table1', Bob: 'Table2' },
#   { Alice: 'Table2', Bob: 'Table1' }
# ]</code></pre>

  <table>
    <tr>
      <th>Method</th>
      <th>Returns</th>
      <th>Use Case</th>
    </tr>
    <tr>
      <td><code>query</code></td>
      <td>Best match</td>
      <td>"Who loves Mary?"</td>
    </tr>
    <tr>
      <td><code>findAll</code></td>
      <td>All matches</td>
      <td>"List everyone at Table1"</td>
    </tr>
    <tr>
      <td><code>solveCSP</code></td>
      <td>All valid assignments</td>
      <td>"Find all seating arrangements"</td>
    </tr>
  </table>

  <p>See <a href="../specsLoader.html?spec=DS/DS16-CSP-Solver.md">DS16 - CSP Solver</a> for full documentation.</p>

  <h2>Built-in Operations</h2>

  <h3>L0: HDC Primitives (Runtime)</h3>

  <table>
    <tr>
      <th>Operation</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>___Bind A B</code></td>
      <td>XOR of two vectors</td>
    </tr>
    <tr>
      <td><code>___Bundle [A B C]</code></td>
      <td>Majority vote of vectors</td>
    </tr>
    <tr>
      <td><code>___Similarity A B</code></td>
      <td>Similarity score (0.0-1.0)</td>
    </tr>
  </table>

  <h3>L1: Structural Operations (Core Theory)</h3>

  <table>
    <tr>
      <th>Operation</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>__Atom</code></td>
      <td>Create new atom</td>
    </tr>
    <tr>
      <td><code>__Bundle</code></td>
      <td>Create set/superposition</td>
    </tr>
    <tr>
      <td><code>__Role name vector</code></td>
      <td>Tag vector with semantic role</td>
    </tr>
    <tr>
      <td><code>__Category</code></td>
      <td>Define type category</td>
    </tr>
  </table>

  <h3>L2: Logic Operations</h3>

  <table>
    <tr>
      <th>Operation</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
    <tr>
      <td><code>Implies A B</code></td>
      <td>If A then B</td>
      <td><code>@r Implies (isA ?x Human) (isA ?x Mortal)</code></td>
    </tr>
    <tr>
      <td><code>And A B</code></td>
      <td>Both A and B</td>
      <td><code>@c And $cond1 $cond2</code></td>
    </tr>
    <tr>
      <td><code>Or A B</code></td>
      <td>Either A or B</td>
      <td><code>@d Or $opt1 $opt2</code></td>
    </tr>
    <tr>
      <td><code>Not A</code></td>
      <td>Negation of A</td>
      <td><code>@n Not $fact</code></td>
    </tr>
    <tr>
      <td><code>ForAll ?x P</code></td>
      <td>Universal quantification</td>
      <td><code>ForAll ?x (Implies (Human ?x) (Mortal ?x))</code></td>
    </tr>
    <tr>
      <td><code>Exists ?x P</code></td>
      <td>Existential quantification</td>
      <td><code>Exists ?x (loves ?x Mary)</code></td>
    </tr>
  </table>

  <h2>Session Commands</h2>

  <pre><code># Load a theory
@_ Load $TheoryName

# Create session-local fact
@myFact someRelation Subject Object

# Query knowledge base
@result query loves ?who Mary

# Prove a goal
@proof prove isA Socrates Mortal</code></pre>

  <h2>Complete Example</h2>

  <pre><code># ============ Theory Definition ============
@Family theory 32768 deterministic

    # Types
    @Person:Person __Category
    @Relationship:Relationship __Category

    # Relation atoms
    @loves:loves __Relation
    @parent:parent __Relation
    @sibling:sibling __Relation

    # Rule: siblings share parent
    # Using reference-based composition (clearer for complex logic)
    @p1 parent ?p ?x
    @p2 parent ?p ?y
    @notSame Not (equals ?x ?y)
    @siblingCond And $p1 (And $p2 $notSame)
    @siblingConc sibling ?x ?y
    @siblingRule Implies $siblingCond $siblingConc

end

# ============ Session Usage ============

# Load theory
@_ Load $Family

# Add facts
@f1 parent Alice Charlie
@f2 parent Alice Diana
@f3 parent Bob Charlie
@f4 parent Bob Diana
@f5 loves Charlie Diana

# Query: Who are Charlie's siblings?
@q sibling Charlie ?who

# Result: ?who = Diana (confidence: 0.82)</code></pre>

  <h2>Syntax Diagram</h2>

  <div class="diagram-container">
    <div class="diagram-title">Statement Structure</div>
    <svg viewBox="0 0 700 100" xmlns="http://www.w3.org/2000/svg">
      <!-- Boxes -->
      <rect x="20" y="30" width="80" height="40" rx="5" fill="#e3f2fd" stroke="#1976d2"/>
      <text x="60" y="55" text-anchor="middle" font-size="11">@dest</text>

      <rect x="120" y="30" width="100" height="40" rx="5" fill="#e8f5e9" stroke="#4caf50"/>
      <text x="170" y="55" text-anchor="middle" font-size="11">operator</text>

      <rect x="240" y="30" width="80" height="40" rx="5" fill="#fff3e0" stroke="#ff9800"/>
      <text x="280" y="55" text-anchor="middle" font-size="11">arg1</text>

      <rect x="340" y="30" width="80" height="40" rx="5" fill="#fff3e0" stroke="#ff9800"/>
      <text x="380" y="55" text-anchor="middle" font-size="11">arg2</text>

      <rect x="440" y="30" width="80" height="40" rx="5" fill="#fff3e0" stroke="#ff9800"/>
      <text x="480" y="55" text-anchor="middle" font-size="11">...</text>

      <!-- Labels -->
      <text x="60" y="85" text-anchor="middle" font-size="9" fill="#666">destination</text>
      <text x="170" y="85" text-anchor="middle" font-size="9" fill="#666">verb/relation</text>
      <text x="380" y="85" text-anchor="middle" font-size="9" fill="#666">arguments</text>
    </svg>
  </div>

  <h2>Error Messages</h2>

  <table>
    <tr>
      <th>Error</th>
      <th>Cause</th>
      <th>Solution</th>
    </tr>
    <tr>
      <td>Undefined reference: $name</td>
      <td>Variable not in scope</td>
      <td>Define variable first or load theory</td>
    </tr>
    <tr>
      <td>Unexpected token: X</td>
      <td>Syntax error</td>
      <td>Check statement format</td>
    </tr>
    <tr>
      <td>Theory not found: Name</td>
      <td>Theory file missing</td>
      <td>Verify theory path</td>
    </tr>
    <tr>
      <td>Low confidence: 0.45</td>
      <td>Query match is weak</td>
      <td>Refine query or add facts</td>
    </tr>
  </table>

	  <h2>Loading Theories</h2>

	  <p>Load a theory (namespace) using the Core <code>Load</code> operator:</p>

	  <pre><code>@_ Load $Commerce
@_ Load $Animals</code></pre>

	  <h2>Rules (Implies)</h2>

	  <p>Define rules as <code>Implies</code> statements:</p>

	  <pre><code>@cond isA ?x Human
@concl isA ?x Mortal
@rule Implies $cond $concl</code></pre>

  <h2>List Syntax</h2>

  <p>Lists use brackets with comma-separated items:</p>

  <pre><code>@items __Bundle [Cat, Dog, Bird]
@numbers __List [1, 2, 3, 4, 5]</code></pre>

  <h2>Compound Expressions (Parenthesized)</h2>

  <p>Sys2DSL supports parenthesized expressions for nested graph calls:</p>

  <pre><code># Inline nested graph call:
@causal __Role Causes (__Pair $cause $effect)

# Nested logic operators:
@rule Implies (And (isA ?x Human) (isA ?x Adult)) (canVote ?x)</code></pre>

  <p><strong>Syntax:</strong> <code>(operator arg1 arg2 ...)</code></p>

  <p>Compound expressions evaluate the nested graph call first, then pass the result as an argument to the outer expression. This is useful for:</p>
  <ul>
    <li>Nested graph invocations in Core theories</li>
    <li>Building complex structures inline</li>
  </ul>

  <h3>Alternative: Reference-Based Composition</h3>

  <p>For complex logic or when sub-expressions need names for debugging, you can also define parts separately:</p>

  <pre><code># Reference-based (recommended for complex logic):
@cond1 hasState Door Open
@cond2 isA Door Entrance
@combined And $cond1 $cond2
@conclusion canEnter Person Door
@rule Implies $combined $conclusion</code></pre>

  <p>The reference-based approach is preferred when sub-expressions need inspection or when the logic is complex. Inline parentheses are best for simple structural patterns.</p>

  <h2>Formal Grammar (EBNF)</h2>

  <p>Complete grammar specification for the Sys2DSL parser:</p>

  <pre><code>program      = { statement | graph_def | theory_block } ;

destination  = "_" | ident [ ":" , ident ] | ":" , ident ;
statement    = "@" , destination , operation , { argument } , [ "#" , text ] , NL ;
operation    = ident | "$" , ident ;
argument     = "$" , ident | "?" , ident | ident | number | list | compound ;

	list         = "[" , argument , { [ "," ] , argument } , "]" ;
compound     = "(" , ident , { argument } , ")" ;

graph_def    = "@" , ( ident [ ":" , ident ] | ":" , ident ) , "graph" , { ident } , NL ,
               { statement } ,
               "return" , "$" , ident , NL ,
               "end" , NL ;

theory_primary = "@" , ident , "theory" , number , init_type , NL ,
                 { statement | graph_def } ,
                 "end" , NL ;

theory_brace   = "theory" , ident , "{" , NL ,
                 { statement | graph_def } ,
                 "}" , NL ;

theory_begin   = "theory" , ident , "begin" , NL ,
                 { statement | graph_def } ,
                 "end" , NL ;

theory_block   = theory_primary | theory_brace | theory_begin ;

init_type    = "random" | "deterministic" ;
ident        = ( letter | "_" ) , { letter | digit | "_" } ;
number       = digit , { digit } ;</code></pre>

  <h2>Related Documentation</h2>

  <ul>
    <li><a href="../specsLoader.html?spec=DS/DS02-DSL-Syntax.md">DS02 - Complete DSL Specification</a></li>
    <li><a href="../api/index.html">API Reference</a> - Using DSL programmatically</li>
    <li><a href="../specsLoader.html?spec=DS/DS07-Core-Theory.md">DS07 - Core Theory Reference</a></li>
    <li><a href="../specsLoader.html?spec=DS/DS16-CSP-Solver.md">DS16 - CSP Solver</a> - Constraint satisfaction and exhaustive search</li>
    <li><a href="../theory/index.html">HDC Theory</a> - How vectors encode semantics</li>
  </ul>

  <div class="footer-nav">
    <p>Sys2DSL provides a minimal, uniform syntax for representing knowledge as vector operations.</p>
    <p style="margin-top: 10px;">
      <a href="https://github.com/OutfinityResearch/AGISystem2/" target="_blank">GitHub: OutfinityResearch/AGISystem2</a>
    </p>
  </div>
  </div>
</body>
</html>
