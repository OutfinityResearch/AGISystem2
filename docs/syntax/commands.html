<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sys2DSL Command Reference</title>
  <link rel="stylesheet" href="../reference/style.css">
  <style>
    .cmd-table { width: 100%; border-collapse: collapse; margin: 1em 0; }
    .cmd-table th, .cmd-table td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    .cmd-table th { background: #f5f5f5; }
    .cmd-table code { background: #f8f8f8; padding: 2px 4px; }
    .category-section { margin-bottom: 2em; }
    .arch-note { background: #e8f4e8; padding: 10px; border-left: 3px solid #4a4; margin: 1em 0; }
    .warning { background: #fff3cd; padding: 10px; border-left: 3px solid #ffc107; margin: 1em 0; }
  </style>
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Sys2DSL Command Reference</h1>
    <div class="sub-nav">
      <strong>Categories:</strong>
      <a href="#highlevel" style="color:#4a4;font-weight:bold">High-Level</a> ·
      <a href="#query">Query</a> ·
      <a href="#assertion">Assertion</a> ·
      <a href="#concept">Concept</a> ·
      <a href="#relation">Relation</a> ·
      <a href="#theory">Theory</a> ·
      <a href="#reasoning">Reasoning</a> ·
      <a href="#inference">Inference</a> ·
      <a href="#memory">Memory</a> ·
      <a href="#mask">Mask</a> ·
      <a href="#utility">Utility</a> ·
      <a href="#output">Output</a> ·
      <a href="#ontology">Ontology</a>
    </div>
  </div>

  <section>
    <h2>Overview</h2>
    <p>This page provides a reference for the Sys2DSL verb set. Verbs are organized by functional category. In v3.0, every statement follows strict triple syntax:</p>
    <pre><code>@varName Subject VERB Object</code></pre>

    <div class="arch-note">
      <strong>High-Level API (Recommended):</strong> For simpler NL→DSL generation, use these consolidated verbs that try multiple strategies internally (still in triple form):
      <code>QUERY</code>, <code>WHATIF</code>, <code>SUGGEST</code>, <code>SUMMARIZE_FACTS</code>, <code>MANAGE_THEORY</code>, <code>MEMORY</code>, <code>MASK</code>, <code>FORMAT_RESULT</code>, <code>EXPLAIN_QUERY</code>.
      See <a href="../specs/theory/Sys2DSL_highlevel.md">Sys2DSL_highlevel.md</a>.
    </div>

    <div class="arch-note">
      <strong>Design spec links (split by area):</strong>
      <ul>
        <li><a href="../specs/theory/Sys2DSL_commands_queries_masks.md">Queries &amp; Masks</a></li>
        <li><a href="../specs/theory/Sys2DSL_commands_assertions_entities.md">Assertions, Concepts &amp; Relations</a></li>
        <li><a href="../specs/theory/Sys2DSL_commands_theory_memory.md">Theory Management &amp; Memory</a></li>
        <li><a href="../specs/theory/Sys2DSL_commands_reasoning.md">Reasoning</a></li>
        <li><a href="../specs/theory/Sys2DSL_commands_util_output_ontology.md">Utility, Output &amp; Ontology Introspection</a></li>
      </ul>
    </div>

    <div class="arch-note">
      <strong>Architecture Integration:</strong> All commands execute through the <code>TheoryDSLEngine</code> which routes to specialized handlers: <code>DSLCommandsCore</code>, <code>DSLCommandsReasoning</code>, <code>DSLCommandsInference</code>, <code>DSLCommandsHighLevel</code>, etc. Results are stored in the script environment and can be referenced by subsequent commands using <code>$varName</code>.
    </div>
  </section>

  <section id="highlevel" class="category-section">
    <h2>0. High-Level Commands (Recommended)</h2>
    <p>These consolidated verbs try multiple strategies internally and are recommended for NL→DSL generation. They wrap the granular verbs below for simpler usage.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Wraps</th></tr>
      <tr>
        <td><code>QUERY</code></td>
        <td>Multi-strategy query (direct geometric + inference)</td>
        <td>IS_A, FACTS, INFER</td>
      </tr>
      <tr>
        <td><code>WHATIF</code></td>
        <td>Counterfactual reasoning</td>
        <td>PUSH + triple fact + inference + POP (see Sys2DSL_highlevel.md)</td>
      </tr>
      <tr>
        <td><code>EXPLAIN_QUERY</code></td>
        <td>Proof-oriented query with explanation</td>
        <td>PROVE, EXPLAIN</td>
      </tr>
      <tr>
        <td><code>SUGGEST</code></td>
        <td>Generate hypotheses (abduct → analogical)</td>
        <td>ABDUCT, ANALOGICAL</td>
      </tr>
      <tr>
        <td><code>SUMMARIZE_FACTS</code></td>
        <td>Find and summarize matching facts</td>
        <td>FACTS, SUMMARIZE</td>
      </tr>
      <tr>
        <td><code>MANAGE_THEORY</code></td>
        <td>Theory storage operations</td>
        <td>THEORIES, SAVE, LOAD, MERGE_THEORY, DELETE_THEORY</td>
      </tr>
      <tr>
        <td><code>MEMORY</code></td>
        <td>Memory lifecycle operations</td>
        <td>BOOST, FORGET, PROTECT, UNPROTECT, GET_USAGE</td>
      </tr>
      <tr>
        <td><code>MASK</code></td>
        <td>Build dimension masks</td>
        <td><code>@mask Subject MASK any</code> (replaces <code>MASK_PARTITIONS</code>/<code>MASK_DIMS</code>)</td>
      </tr>
      <tr>
        <td><code>FORMAT_RESULT</code></td>
        <td>Format results (natural/json/summary)</td>
        <td>TO_NATURAL, TO_JSON, SUMMARIZE</td>
      </tr>
    </table>

    <h3>QUERY</h3>
    <p><strong>Purpose:</strong> Multi-strategy query that tries ASK first, then falls back to INFER if unknown.</p>
    <pre><code>@result Dog QUERY Animal
@result Dog QUERY Animal
@result Dog QUERY Animal</code></pre>

    <h3>WHATIF</h3>
    <p><strong>Purpose:</strong> Counterfactual query - answer a question under hypothetical conditions.</p>
    <pre><code>@cf WHATIF "Water IS_A gas | Water TEMPERATURE_AT Celsius150"
# Temporarily asserts facts after |, runs query, then reverts</code></pre>

    <h3>SUGGEST</h3>
    <p><strong>Purpose:</strong> Generate hypotheses via abduction, with analogical fallback.</p>
    <pre><code>@causes SUGGEST fever                    # Abductive: what causes fever?
@analog SUGGEST King Queen Man           # Analogical: King:Queen :: Man:?</code></pre>

    <h3>MANAGE_THEORY</h3>
    <p><strong>Purpose:</strong> Single entry point for theory storage operations.</p>
    <pre><code>@list any MANAGE_THEORY any
@p action DIM_PAIR LIST
@ok action SET_DIM any
@p name DIM_PAIR my_theory
@ok name SET_DIM any</code></pre>

    <h3>MEMORY</h3>
    <p><strong>Purpose:</strong> Single entry point for memory lifecycle operations.</p>
    <pre><code>@stats MEMORY action=USAGE target=Dog
@ok MEMORY action=BOOST target=ImportantConcept
@ok MEMORY action=PROTECT target=CoreConcept
@removed MEMORY action=FORGET threshold=2</code></pre>
  </section>

  <section id="query" class="category-section">
    <h2>1. Query Verbs</h2>
    <p>Verbs for querying the knowledge base. These read from the ConceptStore and current theory stack.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>QUERY</code> <span style="color:#4a4">(high-level)</span></td>
        <td>Multi-strategy query over a triple</td>
        <td><code>@result Subject QUERY Object</code></td>
      </tr>
      <tr>
        <td><code>FACTS</code></td>
        <td>Find all facts matching a pattern</td>
        <td><code>@results Subject FACTS Object</code> (with <code>any</code> as wildcard)</td>
      </tr>
      <tr>
        <td><code>FACTS_WITH_RELATION</code></td>
        <td>Find all facts with specific relation</td>
        <td><code>@results FACTS_WITH_RELATION IS_A</code></td>
      </tr>
      <tr>
        <td><code>FACTS_WITH_OBJECT</code></td>
        <td>Find all facts with specific object</td>
        <td><code>@results FACTS_WITH_OBJECT Animal</code></td>
      </tr>
      <tr>
        <td><code>INSTANCES_OF</code></td>
        <td>Find all subjects with IS_A to type</td>
        <td><code>@results INSTANCES_OF Animal</code></td>
      </tr>
      <tr>
        <td><code>ALL_REQUIREMENTS_SATISFIED</code></td>
        <td>Check if all requirements are met</td>
        <td><code>@result ALL_REQUIREMENTS_SATISFIED $reqs $satisfied</code></td>
      </tr>
    </table>

    <h3>IS_A / QUERY</h3>
    <p><strong>Purpose:</strong> Query the truth value of a statement within the current theory using <code>IS_A</code> or the high-level <code>QUERY</code> verb.</p>
    <pre><code>@q1 Dog IS_A animal
@q2 Water BOILS_AT Celsius100
@q3 Alice QUERY friend</code></pre>

    <p><strong>Returns:</strong></p>
    <pre><code>{
  truth: 'TRUE_CERTAIN' | 'PLAUSIBLE' | 'FALSE' | 'UNKNOWN' | 'CONFLICT',
  confidence: number,      // 0.0 - 1.0
  provenance: [...]        // reasoning chain
}</code></pre>

    <div class="arch-note">
      <strong>Internal Flow:</strong> Query verbs dispatch to the reasoner, which checks <code>ConceptStore.getFacts()</code> for direct matches, then uses <code>InferenceEngine</code> for transitive, symmetric, and inverse relations. Results pass through <code>DimensionRegistry</code> for relation property lookup.
    </div>

    <h3>FACTS</h3>
    <p><strong>Purpose:</strong> Pattern search across all facts using the unified triple syntax.</p>
    <pre><code>@all any FACTS any              # All facts
@aboutDog Dog FACTS any         # All facts about Dog
@dogIsA Dog FACTS IS_A          # Dog IS_A ?
@exact Dog FACTS animal         # Exact match</code></pre>

    <div class="warning">
      <strong>Note:</strong> Sys2DSL does NOT support <code>?</code> or <code>*</code> wildcards. Use the <code>any</code> concept in triple position or specialized verbs (for example <code>INSTANCES</code>) instead.</div>
  </section>

  <section id="assertion" class="category-section">
    <h2>2. Assertion / Update Verbs</h2>
    <p>Verbs for adding and removing facts. These modify the working theory layer.</p>

    <table class="cmd-table">
      <tr><th>Verb</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>IS_A</code>, <code>HAS</code>, etc.</td>
        <td>Add a new fact</td>
        <td><code>@_ Subject VERB Object</code></td>
      </tr>
      <tr>
        <td><code>RETRACT</code></td>
        <td>Remove a fact</td>
        <td><code>@result Subject RETRACT Object</code></td>
      </tr>
    </table>

    <h3>Triple Facts</h3>
    <p><strong>Purpose:</strong> Add a new fact to the current working theory using the unified triple format.</p>
    <pre><code>@_ Dog IS_A animal
@_ Alice KNOWS Bob
@_ Water BOILS_AT Celsius100</code></pre>

    <div class="arch-note">
      <strong>Internal Flow:</strong> Triple statements call <code>api.add()</code> which encodes concepts via <code>Encoder</code>, stores in <code>ConceptStore</code>, and updates usage tracking in <code>UsageTracker</code>. Facts go to the working theory layer (session-local) until saved with <code>SAVE</code>.
    </div>

    <h3>RETRACT</h3>
    <p><strong>Purpose:</strong> Remove a fact from the current working theory.</p>
    <pre><code>@r1 Water RETRACT solid   # Remove incorrect assertion</code></pre>

    <div class="warning">
      <strong>Note:</strong> RETRACT only affects the working theory layer. Base theories loaded with <code>LOAD</code> are immutable.</div>
  </section>

  <section id="concept" class="category-section">
    <h2>3. Concept Verbs</h2>
    <p>Verbs for working with concepts. Concepts are stored as diamond regions in the vector space.</p>

    <table class="cmd-table">
      <tr><th>Verb</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>BIND</code></td>
        <td>Get or create a concept/fact reference</td>
        <td><code>@ref ConceptName BIND any</code></td>
      </tr>
      <tr>
        <td><code>BIND_POINT</code></td>
        <td>Get point representation</td>
        <td><code>@point ConceptName BIND_POINT any</code></td>
      </tr>
      <tr>
        <td><code>INSPECT</code></td>
        <td>Get detailed concept info</td>
        <td><code>@info ConceptName INSPECT any</code></td>
      </tr>
      <tr>
        <td><code>LITERAL</code></td>
        <td>Create a literal value</td>
        <td><code>@val type LITERAL "some text"</code></td>
      </tr>
    </table>

    <h3>BIND</h3>
    <p><strong>Purpose:</strong> Get a reference to a concept or fact for further operations.</p>
    <pre><code>@waterRef water BIND any
@props $waterRef INSPECT any</code></pre>

    <h3>BIND_POINT</h3>
    <p><strong>Purpose:</strong> Resolve a concept into its geometric representation.</p>
    <pre><code>@waterPoint water BIND_POINT any
@info water INSPECT any
# Returns: diamonds array with center/radii, usage stats</code></pre>
  </section>

  <section id="relation" class="category-section">
    <h2>4. Relation Commands</h2>
    <p>Commands for working with relations (verbs). Relations have properties defined in <code>dimensions.json</code>.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>BIND_RELATION</code></td>
        <td>Get reference to a relation</td>
        <td><code>@ref BIND_RELATION RELATION_NAME</code></td>
      </tr>
      <tr>
        <td><code>DEFINE_RELATION</code></td>
        <td>Create a new relation</td>
        <td><code>@ref DEFINE_RELATION NAME inverse=... symmetric=...</code></td>
      </tr>
      <tr>
        <td><code>BIND_POINT</code></td>
        <td>Create a point in vector space</td>
        <td><code>@point BIND_POINT dim1=val1 ...</code></td>
      </tr>
    </table>

    <h3>BIND_RELATION</h3>
    <p><strong>Purpose:</strong> Get a reference to a relation with its properties.</p>
    <pre><code>@causesRel BIND_RELATION CAUSES
@props INSPECT $causesRel</code></pre>

    <p><strong>Returns:</strong></p>
    <pre><code>{
  kind: 'relationRef',
  name: string,
  inverse: string | null,
  symmetric: boolean,
  transitive: boolean
}</code></pre>

    <h3>DEFINE_RELATION</h3>
    <p><strong>Purpose:</strong> Create a new custom relation (verb).</p>
    <pre><code>@teachRel DEFINE_RELATION TEACHES \
          inverse=TAUGHT_BY \
          symmetric=false \
          transitive=false

@f1 Professor TEACHES Student
@f2 Student TAUGHT_BY Professor</code></pre>

    <div class="arch-note">
      <strong>Internal Flow:</strong> Relations are registered in <code>DimensionRegistry</code>. Each relation gets a deterministic permutation vector generated from its name. The inverse relation (if specified) is automatically registered.
    </div>
  </section>

  <section id="theory" class="category-section">
    <h2>5. Theory Management Commands</h2>
    <p>Commands for managing theory layers and persistence. Theories enable modular, stackable knowledge.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>PUSH</code></td>
        <td>Push new theory layer</td>
        <td><code>@_ layerName PUSH any</code></td>
      </tr>
      <tr>
        <td><code>POP</code></td>
        <td>Pop and discard top layer</td>
        <td><code>@_ any POP any</code></td>
      </tr>
      <tr>
        <td><code>THEORIES</code></td>
        <td>List available theories</td>
        <td><code>@list any THEORIES any</code></td>
      </tr>
      <tr>
        <td><code>LOAD</code></td>
        <td>Load theory from file</td>
        <td><code>@loaded name LOAD any</code></td>
      </tr>
      <tr>
        <td><code>SAVE</code></td>
        <td>Save working theory</td>
        <td><code>@saved name SAVE any</code></td>
      </tr>
      <tr>
        <td><code>MERGE_THEORY</code></td>
        <td>Merge theories</td>
        <td><code>@result MERGE_THEORY target strategy</code></td>
      </tr>
      <tr>
        <td><code>DELETE_THEORY</code></td>
        <td>Delete a saved theory</td>
        <td><code>@result DELETE_THEORY name</code></td>
      </tr>
      <tr>
        <td><code>THEORY_INFO</code></td>
        <td>Get theory metadata</td>
        <td><code>@info THEORY_INFO name</code></td>
      </tr>
      <tr>
        <td><code>RESET_SESSION</code></td>
        <td>Clear working theory</td>
        <td><code>@_ RESET_SESSION</code></td>
      </tr>
    </table>

    <h3>PUSH / POP</h3>
    <p><strong>Purpose:</strong> Create temporary theory layers for exploration or counterfactual reasoning.</p>
    <pre><code>@_ exploration PUSH any
@_ Gravity IS_A fiction              # Temporary fact
@q1 Things IS_ALWAYS true            # Query in this context
@_ any POP any                       # Discard changes</code></pre>

    <div class="arch-note">
      <strong>Internal Flow:</strong> Theory layers are managed by <code>TheoryStack</code> in <code>ConceptStore</code>. Each layer has its own facts that shadow (but don't modify) lower layers. <code>POP</code> discards all changes in the top layer.
    </div>

    <h3>LOAD / SAVE</h3>
    <p><strong>Purpose:</strong> Persist and load theories from <code>data/theories/</code> directory.</p>
    <pre><code>@base physics_fundamentals LOAD any
@domain medical_knowledge LOAD any
# ... add domain-specific facts ...
@saved my_combined_theory SAVE any</code></pre>
  </section>

  <section id="reasoning" class="category-section">
    <h2>6. Reasoning Commands</h2>
    <p>Commands for logical reasoning, validation, and hypothesis generation.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>VALIDATE</code></td>
        <td>Check theory consistency</td>
        <td><code>@result VALIDATE</code></td>
      </tr>
      <tr>
        <td><code>PROVE</code></td>
        <td>Prove a statement</td>
        <td><code>@proof PROVE Subject RELATION Object</code></td>
      </tr>
      <tr>
        <td><code>HYPOTHESIZE</code></td>
        <td>Generate hypotheses</td>
        <td><code>@hyp HYPOTHESIZE observation</code></td>
      </tr>
      <tr>
        <td><code>CF</code></td>
        <td>Counterfactual query</td>
        <td><code>@result CF query | hypothetical_fact</code></td>
      </tr>
      <tr>
        <td><code>ABDUCT</code></td>
        <td>Abductive reasoning</td>
        <td><code>@causes ABDUCT observation RELATION</code></td>
      </tr>
      <tr>
        <td><code>ANALOGICAL</code></td>
        <td>Analogical reasoning</td>
        <td><code>@result ANALOGICAL source target</code></td>
      </tr>
      <tr>
        <td><code>CHECK_CONTRADICTION</code></td>
        <td>Check for contradictions</td>
        <td><code>@result CHECK_CONTRADICTION</code></td>
      </tr>
      <tr>
        <td><code>CHECK_WOULD_CONTRADICT</code></td>
        <td>Check if fact would contradict</td>
        <td><code>@result CHECK_WOULD_CONTRADICT Subject RELATION Object</code></td>
      </tr>
      <tr>
        <td><code>REGISTER_FUNCTIONAL</code></td>
        <td>Register functional constraint</td>
        <td><code>@_ REGISTER_FUNCTIONAL RELATION</code></td>
      </tr>
      <tr>
        <td><code>REGISTER_CARDINALITY</code></td>
        <td>Register cardinality constraint</td>
        <td><code>@_ REGISTER_CARDINALITY RELATION min max</code></td>
      </tr>
    </table>

    <h3>VALIDATE</h3>
    <p><strong>Purpose:</strong> Check the current theory for logical consistency and contradictions.</p>
    <pre><code>@_ Water IS_A solid
@_ Water IS_A liquid
@check any VALIDATE any
# Returns: conflicts about Water being both solid and liquid</code></pre>

    <p><strong>Returns:</strong></p>
    <pre><code>{
  valid: boolean,
  conflicts: [
    { fact1: {...}, fact2: {...}, reason: string },
    ...
  ],
  warnings: [...]
}</code></pre>

    <h3>CF (Counterfactual)</h3>
    <p><strong>Purpose:</strong> Query under hypothetical conditions without permanently modifying the theory.</p>
    <pre><code>@cf CF Water IS_A gas | Water TEMPERATURE_AT Celsius150
# Asks: "Would water be a gas if it were at 150 degrees?"</code></pre>

    <div class="arch-note">
      <strong>Internal Flow:</strong> CF creates a temporary theory layer, adds the hypothetical facts, runs the query, then discards the layer. The original theory remains unchanged.
    </div>

    <h3>PROVE</h3>
    <p><strong>Purpose:</strong> Attempt to prove a statement with a reasoning chain.</p>
    <pre><code>@proof PROVE Dog IS_A LivingThing
# Returns: proof chain showing Dog IS_A Animal IS_A LivingThing</code></pre>

    <h3>ABDUCT</h3>
    <p><strong>Purpose:</strong> Find possible causes/explanations using inverse reasoning.</p>
    <pre><code>@causes ABDUCT Smoke CAUSED_BY
# Returns: candidates like Fire, ChemicalReaction, etc.</code></pre>

    <h3>ANALOGICAL</h3>
    <p><strong>Purpose:</strong> Transfer properties from a source domain to a target domain based on structural similarity.</p>
    <pre><code>@analog ANALOGICAL atom:solar_system
# Maps electron:planet, nucleus:sun based on ORBITS relationship</code></pre>
  </section>

  <section id="inference" class="category-section">
    <h2>7. Inference Commands</h2>
    <p>Commands for multi-method inference, rule definition, and explanation.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>INFER</code></td>
        <td>Multi-method inference</td>
        <td><code>@result INFER Subject RELATION Object [method=X] [proof=true]</code></td>
      </tr>
      <tr>
        <td><code>FORWARD_CHAIN</code></td>
        <td>Derive all conclusions</td>
        <td><code>@derived FORWARD_CHAIN [maxIterations=N]</code></td>
      </tr>
      <tr>
        <td><code>WHY</code></td>
        <td>Explain inference result</td>
        <td><code>@exp WHY Subject RELATION Object</code></td>
      </tr>
      <tr>
        <td><code>DEFINE_RULE</code></td>
        <td>Register composition/inference rule</td>
        <td><code>@r DEFINE_RULE name=X head="pattern" body="pattern"</code></td>
      </tr>
      <tr>
        <td><code>DEFINE_DEFAULT</code></td>
        <td>Register default reasoning rule</td>
        <td><code>@d DEFINE_DEFAULT name=X type=T property=P value=V [exception=E]</code></td>
      </tr>
      <tr>
        <td><code>CLEAR_RULES</code></td>
        <td>Clear all registered rules</td>
        <td><code>@_ CLEAR_RULES</code></td>
      </tr>
    </table>

    <h3>INFER</h3>
    <p><strong>Purpose:</strong> Attempt to infer a statement using all available methods.</p>
    <pre><code>@result INFER Grandpa ANCESTOR_OF Grandson method=transitive proof=true</code></pre>

    <p><strong>Methods available:</strong></p>
    <ul>
      <li><code>direct</code> - Direct fact lookup</li>
      <li><code>transitive</code> - Follow transitive relations</li>
      <li><code>symmetric</code> - Check symmetric relations (e.g., MARRIED_TO)</li>
      <li><code>inverse</code> - Check inverse relations (e.g., PARENT_OF/CHILD_OF)</li>
      <li><code>composition</code> - Apply composition rules</li>
      <li><code>inheritance</code> - Use IS_A hierarchy</li>
      <li><code>default</code> - Apply default reasoning</li>
    </ul>

    <div class="arch-note">
      <strong>Internal Flow:</strong> INFER delegates to <code>InferenceEngine.infer()</code> which tries methods in sequence. The engine uses <code>DimensionRegistry</code> to check relation properties (symmetric, transitive, inverse).
    </div>

    <h3>FORWARD_CHAIN</h3>
    <p><strong>Purpose:</strong> Derive all possible conclusions from current facts using inference rules.</p>
    <pre><code>@derived FORWARD_CHAIN maxIterations=100
# Returns: { derived: [...], count: N, originalCount: M }</code></pre>

    <h3>WHY</h3>
    <p><strong>Purpose:</strong> Explain why a statement is true or false.</p>
    <pre><code>@exp WHY Dog IS_A LivingThing
# Returns detailed reasoning chain with each step justified</code></pre>

    <h3>DEFINE_RULE</h3>
    <p><strong>Purpose:</strong> Register a composition/inference rule for complex relationship reasoning.</p>
    <pre><code>@r1 DEFINE_RULE name=grandparent \
    head="?x GRANDPARENT_OF ?z" \
    body="?x PARENT_OF ?y" \
    body="?y PARENT_OF ?z"</code></pre>
    <p>Rules enable deriving new facts from existing ones via pattern matching.</p>

    <h3>DEFINE_DEFAULT</h3>
    <p><strong>Purpose:</strong> Register a default reasoning rule with optional exceptions.</p>
    <pre><code>@d1 DEFINE_DEFAULT name=birds_fly \
    type=bird property=CAN value=fly \
    exception=penguin exception=ostrich</code></pre>
    <p>Default reasoning applies typical properties unless explicitly overridden.</p>

    <h3>CLEAR_RULES</h3>
    <p><strong>Purpose:</strong> Clear all registered inference rules and defaults.</p>
    <pre><code>@_ CLEAR_RULES</code></pre>
  </section>

  <section id="memory" class="category-section">
    <h2>8. Memory Management Commands</h2>
    <p>Commands for managing concept memory, usage tracking, and forgetting.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>GET_USAGE</code></td>
        <td>Get usage statistics</td>
        <td><code>@stats GET_USAGE conceptName</code></td>
      </tr>
      <tr>
        <td><code>FORGET</code></td>
        <td>Remove low-usage concepts</td>
        <td><code>@result FORGET threshold=N</code></td>
      </tr>
      <tr>
        <td><code>BOOST</code></td>
        <td>Increase usage count</td>
        <td><code>@_ BOOST conceptName amount</code></td>
      </tr>
      <tr>
        <td><code>PROTECT</code></td>
        <td>Protect from forgetting</td>
        <td><code>@_ PROTECT conceptName</code></td>
      </tr>
      <tr>
        <td><code>UNPROTECT</code></td>
        <td>Remove protection</td>
        <td><code>@_ UNPROTECT conceptName</code></td>
      </tr>
    </table>

    <h3>GET_USAGE</h3>
    <p><strong>Purpose:</strong> Get usage statistics for a concept.</p>
    <pre><code>@stats GET_USAGE water
# Returns: { usageCount, lastUsed, createdAt, assertCount, queryCount }</code></pre>

    <h3>FORGET</h3>
    <p><strong>Purpose:</strong> Remove concepts/facts with low usage to manage memory.</p>
    <pre><code>@cleaned FORGET threshold=5      # Remove if usageCount < 5
@old FORGET older_than=30d        # Remove if not used in 30 days</code></pre>

    <div class="arch-note">
      <strong>Internal Flow:</strong> FORGET uses <code>UsageTracker</code> to identify candidates and <code>ForgettingEngine</code> to safely remove them. Protected concepts are never forgotten.
    </div>

    <h3>BOOST / PROTECT / UNPROTECT</h3>
    <p><strong>Purpose:</strong> Manually control concept priority and protection.</p>
    <pre><code>@_ PROTECT CoreConcept           # Never forget this
@_ BOOST ImportantTerm 100       # Increase priority
@_ UNPROTECT TemporaryConcept    # Allow forgetting</code></pre>
  </section>

  <section id="mask" class="category-section">
    <h2>9. Mask Commands</h2>
    <p>Commands for creating dimension masks. Masks enable bias control and focused queries.</p>

    <table class="cmd-table">
      <tr><th>Verb</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>MASK</code></td>
        <td>Mask by partition or dimension names</td>
        <td><code>@mask Subject MASK any</code></td>
      </tr>
    </table>

    <h3>MASK (v3.0)</h3>
    <p><strong>Purpose:</strong> Create a mask for partitions or specific named dimensions using the unified triple syntax.</p>
    <pre><code>@ontologyMask ontology MASK any
@valueMask axiology MASK any
@thermoMask Temperature_Pressure MASK any
@ethicsMask MoralValence_Legality_Trust MASK any</code></pre>
  </section>

  <section id="utility" class="category-section">
    <h2>10. Utility Commands</h2>
    <p>Boolean operations and list manipulation.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>BOOL_AND</code></td>
        <td>Logical AND</td>
        <td><code>@result BOOL_AND $a $b</code></td>
      </tr>
      <tr>
        <td><code>BOOL_OR</code></td>
        <td>Logical OR</td>
        <td><code>@result BOOL_OR $a $b</code></td>
      </tr>
      <tr>
        <td><code>BOOL_NOT</code></td>
        <td>Logical NOT</td>
        <td><code>@result BOOL_NOT $a</code></td>
      </tr>
      <tr>
        <td><code>NONEMPTY</code></td>
        <td>Check if list non-empty</td>
        <td><code>@result NONEMPTY $list</code></td>
      </tr>
      <tr>
        <td><code>MERGE_LISTS</code></td>
        <td>Concatenate lists</td>
        <td><code>@combined MERGE_LISTS $list1 $list2</code></td>
      </tr>
      <tr>
        <td><code>PICK_FIRST</code></td>
        <td>Get first element</td>
        <td><code>@first PICK_FIRST $list</code></td>
      </tr>
      <tr>
        <td><code>PICK_LAST</code></td>
        <td>Get last element</td>
        <td><code>@last PICK_LAST $list</code></td>
      </tr>
      <tr>
        <td><code>COUNT</code></td>
        <td>Count elements</td>
        <td><code>@n COUNT $list</code></td>
      </tr>
      <tr>
        <td><code>FILTER</code></td>
        <td>Filter list</td>
        <td><code>@filtered FILTER $list condition</code></td>
      </tr>
      <tr>
        <td><code>POLARITY_DECIDE</code></td>
        <td>Decide based on polarity</td>
        <td><code>@result POLARITY_DECIDE $truthValue</code></td>
      </tr>
    </table>

    <h3>Boolean Operations</h3>
    <pre><code>@q1 Dog IS_A Animal
@q2 Dog HAS_PROPERTY fur
@both BOOL_AND $q1 $q2        # True if both true
@either BOOL_OR $q1 $q2       # True if either true
@notQ1 BOOL_NOT $q1           # Negation</code></pre>

    <h3>List Operations</h3>
    <pre><code>@list1 Dog FACTS any
@list2 Cat FACTS any
@all $list1 MERGE_LISTS $list2
@first PICK_FIRST $all
@count COUNT $all
@hasItems NONEMPTY $all</code></pre>
  </section>

  <section id="output" class="category-section">
    <h2>11. Output Commands</h2>
    <p>Commands for formatting and exporting results.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>TO_NATURAL</code></td>
        <td>Convert to natural language</td>
        <td><code>@text TO_NATURAL $result</code></td>
      </tr>
      <tr>
        <td><code>TO_JSON</code></td>
        <td>Export as JSON</td>
        <td><code>@json TO_JSON $result</code></td>
      </tr>
      <tr>
        <td><code>EXPLAIN</code></td>
        <td>Detailed explanation</td>
        <td><code>@exp EXPLAIN $result</code></td>
      </tr>
      <tr>
        <td><code>FORMAT</code></td>
        <td>Format with template</td>
        <td><code>@formatted FORMAT $result template="..."</code></td>
      </tr>
      <tr>
        <td><code>SUMMARIZE</code></td>
        <td>Summarize results</td>
        <td><code>@summary SUMMARIZE $results</code></td>
      </tr>
    </table>

    <h3>TO_NATURAL</h3>
    <p><strong>Purpose:</strong> Convert a result to human-readable text.</p>
    <pre><code>@answer Water IS_A liquid
@readable TO_NATURAL $answer
# Returns: "Yes, water is a liquid (confidence: 95%)"</code></pre>

    <h3>EXPLAIN</h3>
    <p><strong>Purpose:</strong> Get a detailed explanation of how a result was derived.</p>
    <pre><code>@result Dog IS_A LivingThing
@exp EXPLAIN $result
# Returns: step-by-step reasoning chain</code></pre>
  </section>

  <section id="ontology" class="category-section">
    <h2>12. Ontology Introspection Commands</h2>
    <p>Commands for exploring what the system knows and doesn't know.</p>

    <table class="cmd-table">
      <tr><th>Command</th><th>Purpose</th><th>Syntax</th></tr>
      <tr>
        <td><code>EXPLAIN_CONCEPT</code></td>
        <td>Explain what system knows</td>
        <td><code>@info EXPLAIN_CONCEPT conceptName</code></td>
      </tr>
      <tr>
        <td><code>MISSING</code></td>
        <td>Find undefined concepts</td>
        <td><code>@gaps MISSING "statement"</code></td>
      </tr>
      <tr>
        <td><code>WHAT_IS</code></td>
        <td>Simple identity query</td>
        <td><code>@desc WHAT_IS conceptName</code></td>
      </tr>
    </table>

    <h3>EXPLAIN_CONCEPT</h3>
    <p><strong>Purpose:</strong> Get comprehensive information about what the system knows about a concept.</p>
    <pre><code>@water EXPLAIN_CONCEPT Water
# Returns: types, properties, relationships, usage stats</code></pre>

    <p><strong>Returns:</strong></p>
    <pre><code>{
  concept: string,
  normalized: string,
  exists: boolean,
  asSubject: [...],    // facts where concept is subject
  asObject: [...],     // facts where concept is object
  types: [...],        // IS_A relationships
  properties: [...],   // HAS_PROPERTY values
  summary: string      // natural language summary
}</code></pre>

    <h3>MISSING</h3>
    <p><strong>Purpose:</strong> Find undefined concepts in a statement before executing it.</p>
    <pre><code>@gaps MISSING "Doctor TREATS Patient USING Medicine"
# Returns: which concepts are undefined, with suggestions</code></pre>

    <div class="arch-note">
      <strong>Use Case:</strong> Call MISSING before complex queries to identify what facts need to be added first. Useful for LLM integration where the system can report what knowledge is missing.
    </div>

    <h3>WHAT_IS</h3>
    <p><strong>Purpose:</strong> Quick identity query - what type of thing is this?</p>
    <pre><code>@desc WHAT_IS Dog
# Returns: "'Dog' is a Mammal, Animal with four_legs, fur."</code></pre>
  </section>

  <section>
    <h2>Command Summary Table</h2>
    <table class="cmd-table">
      <tr><th>Category</th><th>Commands</th><th>Count</th></tr>
      <tr><td>Query</td><td>IS_A, FACTS, FACTS_WITH_RELATION, FACTS_WITH_OBJECT, INSTANCES_OF, ALL_REQUIREMENTS_SATISFIED</td><td>6</td></tr>
      <tr><td>Assertion</td><td>triple facts (IS_A, HAS, ...), RETRACT</td><td>2</td></tr>
      <tr><td>Concept</td><td>BIND_CONCEPT, DEFINE_CONCEPT, INSPECT, LITERAL</td><td>4</td></tr>
      <tr><td>Relation</td><td>BIND_RELATION, DEFINE_RELATION, BIND_POINT</td><td>3</td></tr>
      <tr><td>Theory</td><td>PUSH, POP, THEORIES, LOAD, SAVE, MERGE_THEORY, DELETE_THEORY, THEORY_INFO, RESET_SESSION</td><td>9</td></tr>
      <tr><td>Reasoning</td><td>VALIDATE, PROVE, HYPOTHESIZE, CF, ABDUCT, ANALOGICAL, CHECK_CONTRADICTION, CHECK_WOULD_CONTRADICT, REGISTER_FUNCTIONAL, REGISTER_CARDINALITY</td><td>10</td></tr>
      <tr><td>Inference</td><td>INFER, FORWARD_CHAIN, WHY, DEFINE_RULE, DEFINE_DEFAULT, CLEAR_RULES</td><td>6</td></tr>
      <tr><td>Memory</td><td>GET_USAGE, FORGET, BOOST, PROTECT, UNPROTECT</td><td>5</td></tr>
      <tr><td>Mask</td><td>MASK</td><td>1</td></tr>
      <tr><td>Utility</td><td>BOOL_AND, BOOL_OR, BOOL_NOT, NONEMPTY, MERGE_LISTS, PICK_FIRST, PICK_LAST, COUNT, FILTER, POLARITY_DECIDE</td><td>10</td></tr>
      <tr><td>Output</td><td>TO_NATURAL, TO_JSON, EXPLAIN, FORMAT, SUMMARIZE</td><td>5</td></tr>
      <tr><td>Ontology</td><td>EXPLAIN_CONCEPT, MISSING, WHAT_IS</td><td>3</td></tr>
      <tr><td style="background:#e8f4e8"><strong>High-Level</strong></td><td style="background:#e8f4e8">QUERY, WHATIF, SUGGEST, MANAGE_THEORY, MEMORY, MASK, FORMAT_RESULT, SUMMARIZE_FACTS, EXPLAIN_QUERY</td><td style="background:#e8f4e8">9</td></tr>
      <tr><td colspan="2"><strong>Total (Granular + High-Level)</strong></td><td><strong>67</strong></td></tr>
    </table>
  </section>

  <section>
    <h2>Architecture Overview</h2>
    <p>How commands connect to the internal architecture:</p>

    <pre><code>
User/LLM Input
     |
     v
TranslatorBridge  ─────────────────────────────────────────────────┐
     |                                                              |
     v                                                              |
TheoryDSLEngine ─────> DSLParser (tokenize, resolve variables)      |
     |                                                              |
     ├──> DSLCommandsCore ─────> api.ask(), api.add()               |
     |         |                      |                             |
     |         v                      v                             |
     |    Reasoner ──────────> ConceptStore ───> StorageAdapter     |
     |         |                      |                             |
     |         v                      v                             |
     |    InferenceEngine       TheoryStack                         |
     |         |                                                    |
     |         v                                                    |
     ├──> DSLCommandsReasoning ─> ContradictionDetector             |
     |                                                              |
     ├──> DSLCommandsInference ─> InferenceEngine                   |
     |                                                              |
     ├──> DSLCommandsTheory ────> TheoryManager                     |
     |                                                              |
     ├──> DSLCommandsMemory ────> UsageTracker, ForgettingEngine    |
     |                                                              |
     ├──> DSLCommandsOntology ──> DimensionRegistry                 |
     |                                                              |
     └──> DSLCommandsOutput ────> (formatting utilities)            |
                                                                    |
                                                 DimensionRegistry ─┘
                                                 (relation properties)
    </code></pre>
  </section>

  <div class="footer-nav">
    <a href="index.html">Back to Syntax overview</a>
    <a href="../index.html">Back to Documentation</a>
  </div>
  </div>
  <script src="../reference/nav2.js"></script>
</body>
</html>
