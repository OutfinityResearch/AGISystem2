<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Syntax – Macros and the Theory DSL</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Syntax for Macros and the Theory DSL</h1>
  </div>
  <p>Macros let you express reusable reasoning patterns in text, without changing the JavaScript engine. They are written in a small domain-specific language that lives in <code>.dsl</code> files. This chapter explains the syntax of that language, shows how the built-in macros for health, export, and narrative domains are written, and describes how you can override or extend them.</p>

  <h2>Basic Line Syntax</h2>
  <p>A macro script is a text file where each non-empty, non-comment line is an assignment. Lines starting with <code>#</code> are comments and are ignored. Every assignment has the form:</p>
  <pre><code>@varName COMMAND arg1 arg2 ...</code></pre>
  <p>The <code>varName</code> chooses the variable name that will hold the result of the command. The <code>COMMAND</code> is an upper-case keyword such as <code>FACTS_MATCHING</code>, <code>ALL_REQUIREMENTS_SATISFIED</code>, <code>MERGE_LISTS</code>, <code>NONEMPTY</code>, <code>POLARITY_DECIDE</code>, or <code>BOOL_AND</code>. Arguments can be literal fragments of fact syntax or references to variables defined earlier in the script.</p>

  <p>Literals are written as plain text. When they contain spaces or variable references, they are often wrapped in quotes for clarity:</p>
  <pre><code>@reqs FACTS_MATCHING "$procId REQUIRES ?"
@satGiven FACTS_MATCHING "? GIVEN yes"
@satPresent FACTS_MATCHING "? PRESENT yes"</code></pre>

  <p>Variable references use the <code>$name</code> form. If you previously defined <code>@reqs</code>, you can pass that value to another command as <code>$reqs</code>:</p>
  <pre><code>@allSat MERGE_LISTS $satGiven $satPresent
@result ALL_REQUIREMENTS_SATISFIED $reqs $allSat</code></pre>

  <h2>Built-in Macro Examples</h2>

  <h3>Health Procedure Compliance</h3>
  <p>The built-in health macro evaluates whether all requirements of a procedure are satisfied. Conceptually, it does three things: it finds all requirements for a given procedure, it finds all facts that say a requirement is satisfied, and it checks that each requirement appears in the satisfied set.</p>

  <p>In DSL form, the core of the macro looks like this (the actual file is <code>health_procedure.dsl</code>):</p>
  <pre><code># Inputs: procId is provided by the API
@reqs FACTS_MATCHING "$procId REQUIRES ?"
@satGiven FACTS_MATCHING "? GIVEN yes"
@satPresent FACTS_MATCHING "? PRESENT yes"
@allSat MERGE_LISTS $satGiven $satPresent
@result ALL_REQUIREMENTS_SATISFIED $reqs $allSat</code></pre>

  <p>When EngineAPI calls this macro via <code>checkProcedureCompliance</code>, it seeds the environment with a variable <code>procId</code> set to the procedure identifier. The macro produces a variable called <code>result</code> whose value is a small truth object such as <code>{ truth: "TRUE_CERTAIN" }</code> or <code>{ truth: "FALSE" }</code>. The API then returns this truth value to the caller.</p>

  <h3>Export Decisions Under Regulations</h3>
  <p>The export macro decides whether an action is permitted, prohibited, or in conflict under a set of regulations. It looks for all facts of the form <code>Action PROHIBITED_BY Reg</code> and <code>Action PERMITTED_BY Reg</code>, then applies a polarity rule per active regulation.</p>

  <p>The core of <code>export_action.dsl</code> looks like this:</p>
  <pre><code># Inputs: actionId and regs (list of regulations)
@prohib FACTS_MATCHING "$actionId PROHIBITED_BY ?"
@permit FACTS_MATCHING "$actionId PERMITTED_BY ?"
@result POLARITY_DECIDE $prohib $permit $regs</code></pre>

  <p>Here <code>POLARITY_DECIDE</code> examines the negative and positive evidence for each regulation in <code>regs</code> and returns a truth object with <code>TRUE_CERTAIN</code>, <code>FALSE</code>, or <code>CONFLICT</code>, depending on whether permissions and prohibitions are aligned or opposed.</p>

  <h3>Narrative Magic Permissions</h3>
  <p>The narrative macro checks whether an actor is allowed to use magic in a given city. It requires three conditions: the actor must cast magic, must be located in the city, and some theory must declare that magic is permitted there.</p>

  <p>The core of <code>narrative_magic.dsl</code> looks like this:</p>
  <pre><code># Inputs: actorId and cityId
@casts FACTS_MATCHING "$actorId CASTS Magic"
@locs FACTS_MATCHING "$actorId LOCATED_IN $cityId"
@perm1 FACTS_MATCHING "? PERMITS Magic_IN $cityId"
@perm2 FACTS_MATCHING "? PERMITS Magic_IN_$cityId"
@permAll MERGE_LISTS $perm1 $perm2
@hasMagic NONEMPTY $casts
@hasLoc NONEMPTY $locs
@perm NONEMPTY $permAll
@both BOOL_AND $hasMagic $hasLoc
@result BOOL_AND $both $perm</code></pre>

  <p>This macro again produces a <code>result</code> variable whose truth is interpreted by the <code>checkMagicInCity</code> helper. If any of the three conditions fails, the final truth is <code>FALSE</code>; if all three succeed, the truth is <code>TRUE_CERTAIN</code>.</p>

  <h2>Where Macro Files Live</h2>
  <p>Macro scripts can be shipped with the engine or defined per project:</p>
  <pre><code># Built-in macros shipped with the engine
data/init/macros/health_procedure.dsl
data/init/macros/export_action.dsl
data/init/macros/narrative_magic.dsl

# Project-level overrides and extensions
.AGISystem2/macros/health_procedure.dsl
.AGISystem2/macros/export_action.dsl
.AGISystem2/macros/narrative_magic.dsl
.AGISystem2/macros/custom_domain_macro.dsl</code></pre>

  <p>When the engine needs a macro named <code>health_procedure</code>, it first looks under a <code>macros</code> folder next to the storage root (for CLI sessions this is usually <code>.AGISystem2/macros</code>). If such a file exists, it is used; otherwise, the engine falls back to the built-in version. This allows you to change domain behaviour by editing text files without touching the core code.</p>

  <h2>Relationship to Facts and Theories</h2>
  <p>Macros do not change the syntax of facts; they only read and group them. Commands such as <code>FACTS_MATCHING</code> search over sets of triples in memory or in the temporary context assembled from theory files and extra facts. Other commands such as <code>MERGE_LISTS</code>, <code>NONEMPTY</code>, <code>ALL_REQUIREMENTS_SATISFIED</code>, and <code>POLARITY_DECIDE</code> combine these lists and derive higher-level truth values. From the perspective of the engine, macros are small programs that say “how to think” about a set of facts in a particular domain.</p>

  <div class="footer-nav">
    <a href="syntax.html">Back to Syntax overview</a>
    <a href="../index.html">Back to index</a>
  </div>
  </div>
  <script src="nav.js"></script>
</body>
</html>

