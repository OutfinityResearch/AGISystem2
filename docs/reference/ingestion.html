<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Data Ingestion</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>How Data Enters</h1>
    <small><a href="index.html">Back to index</a> · <a href="quick_wiki.html">Quick Wiki</a></small>
  </div>
  <p>The ingestion pipeline is how raw text becomes geometry in AGISystem2. It is intentionally simple and linear so that every step can be inspected and replayed. A sentence arrives, is rewritten into the constrained grammar, is parsed into a small tree, and is then encoded into a high-dimensional vector. That vector shapes bounded diamonds in ConceptStore and is indexed for later retrieval. This chapter follows that conveyor from left to right and points to the relevant module specifications and tests.</p>

  <h2>From Text to Normalised Sentences</h2>
  <p>In many applications, incoming text will be messy: natural language questions, documentation excerpts, logs, or transcripts. Before any of this can influence the conceptual space, TranslatorBridge must turn it into the small dialect described in the Syntax and Grammar chapters. Given an input paragraph, the bridge uses a pinned language model and prompt to produce one or more canonical sentences such as <code>Dog IS_A Animal</code> or <code>ExportData PROHIBITED_BY GDPR</code>. Its behaviour is deterministic for a given configuration, and it reports its model and prompt versions so that later you can repeat the same normalisation if needed.</p>
  <p>If the bridge cannot find a safe rewrite into subject–relation–object form, it should decline the input rather than guess. This rule applies especially in safety-critical contexts, where a mis-normalised sentence could warp the conceptual space in hard-to-detect ways. Internal tests contain examples of both successful and intentionally failing normalisations, ensuring that surprising phrases are either handled explicitly or rejected.</p>

  <h2>Parsing and Encoding</h2>
  <p>Once normalised sentences are available, the Parser builds a shallow tree for each: a root node for the subject, a relation node, and one or more child nodes for objects or properties. The recursion horizon limits how deep this tree may become; tokens beyond that depth are either ignored or treated neutrally to prevent runaway complexity. The encoder then walks this tree. For every edge from parent to child, it applies a relation-specific permutation to the child’s vector and adds it to the parent using saturated int8 arithmetic implemented by MathEngine.</p>

  <div class="diagram">
    <svg viewBox="0 0 320 160" role="img" aria-label="Ingestion tree from subject through relation to encoded vector">
      <defs>
        <marker id="arrow-ingest-tree" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L6,3 L0,6 z" fill="#0f4c81" />
        </marker>
      </defs>
      <circle cx="80" cy="40" r="10" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1" />
      <text x="71" y="44" font-size="8" fill="#0f4c81">Subj</text>
      <circle cx="160" cy="40" r="10" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1" />
      <text x="151" y="44" font-size="8" fill="#0f4c81">Rel</text>
      <circle cx="240" cy="40" r="10" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1" />
      <text x="232" y="44" font-size="8" fill="#0f4c81">Obj</text>
      <line x1="90" y1="40" x2="150" y2="40" stroke="#0f4c81" stroke-width="1" marker-end="url(#arrow-ingest-tree)" />
      <line x1="170" y1="40" x2="230" y2="40" stroke="#0f4c81" stroke-width="1" marker-end="url(#arrow-ingest-tree)" />
      <rect x="110" y="90" width="100" height="26" rx="4" fill="#ffffff" stroke="#b0b6c4" stroke-width="1" />
      <text x="118" y="106" font-size="8" fill="#4a5670">Encoded sentence vector</text>
      <line x1="160" y1="50" x2="160" y2="90" stroke="#0f4c81" stroke-width="1" marker-end="url(#arrow-ingest-tree)" />
    </svg>
    <p class="diagram-caption">A normalised sentence becomes a small subject–relation–object tree that the encoder walks using relation-specific permutations and saturated addition. The diagram abstracts this into three nodes feeding a single encoded vector, which is the unit that later shapes diamonds and participates in retrieval.</p>
  </div>

  <p>This process yields a single high-dimensional vector per sentence that encodes both the identities of the tokens and the roles they played. Because the same relations always use the same permutations and all arithmetic is deterministic, two identical sentences ingested under the same configuration will always produce identical vectors. Other chapters describe the underlying parser and encoder behaviour conceptually, and internal tests verify that permutations and additions behave as expected.</p>

  <h2>Clustering into Concepts</h2>
  <p>Each encoded sentence is both a new fact and a clue about the shape of the concept it refers to. The ClusterManager examines the new vector relative to existing diamonds for the target concept. If the point falls comfortably inside one of them, the corresponding diamond may be tightened or slightly adjusted. If it lies outside all current diamonds but close enough to be considered a plausible extension, a diamond may be widened. If it sits far from existing regions, ClusterManager may decide to create a new diamond, representing a distinct sense or context.</p>
  <p>This clustering logic turns a stream of discrete observations into evolving, continuous regions in conceptual space. It supports both conservative updates, where concepts change slowly as more evidence accumulates, and more dramatic restructurings, such as splitting a single overloaded concept into several more specific ones. Internal tests demonstrate how these decisions are made and how they preserve determinism.</p>

  <h2>Persistence and Indexing</h2>
  <p>After clustering decides how to adjust concepts, ConceptStore persists the resulting diamonds using Storage modules that write compact binary representations to disk or keep them in memory depending on profile. In test profiles this may mean writing to a temporary directory; in production it means persisting under a chosen root with optional custom backends. Either way, the goal is that reloading a store reproduces the same conceptual space, down to min/max bounds, centres, radii, and relevance masks.</p>
  <p>At the same time, Retriever updates its index so that subsequent queries can find relevant concepts quickly. It feeds the new vectors into the locality-sensitive hashing scheme configured for the current profile, computing hash values, band keys, and bucket assignments. Because hashing is seed-based and index parameters are fixed per profile, repeated ingestion of the same data set in the same configuration yields identical index structures. Internal tests check that persisted and reloaded stores lead to the same retrieval behaviour.</p>

  <h2>End-to-End Example</h2>
  <p>Consider the sentence "Water HAS_PROPERTY boiling_point=100". TranslatorBridge either emits this form directly or normalises a more natural sentence into it. Parser and encoder then compute a vector where dimensions related to temperature, physicality, and process dynamics carry most of the signal. ClusterManager notices that this point strengthens the existing "Water" concept’s association with a particular temperature range and adjusts the corresponding diamond accordingly. ConceptStore writes the new diamond to disk, and Retriever records the new vector in its index. A subsequent question "Is water boiling at 100?" will follow the query path described in the Reasoning and API chapters and, if configurations align, land squarely inside the updated region.</p>
  <p>Throughout this process, provenance links every change back to the original text, the normalisation steps, the profile in use, and the seeds that shaped hashing and permutations. The Ingestion story therefore fits into the larger explainability and bias-control picture: data does not simply disappear into weights, but remains traceable as points and regions in a well-defined conceptual space.</p>

  <div class="footer-nav">
    <a href="index.html">Back to index</a>
    <a href="quick_wiki.html">Quick Wiki</a>
  </div>
  </div>
</body>
</html>
