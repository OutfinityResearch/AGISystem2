<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Creating HDC Strategies – AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Creating HDC Strategies</h1>
    <small>
      <a href="../index.html">Home</a> ·
      <a href="../architecture/index.html">Architecture</a> ·
      <a href="index.html">Guides</a>
    </small>
    <small>How to implement alternative hyperdimensional computing strategies</small>
  </div>

  <div class="section-intro">
    <p>AGISystem2 uses a <strong>strategy pattern</strong> for HDC operations. This allows swapping the underlying vector representation without changing the reasoning layer. This guide explains how to create a new strategy.</p>
  </div>

  <h2>HDC Contract</h2>
  <p>Every strategy must satisfy these <strong>mathematical properties</strong>:</p>

  <table class="matrix-table">
    <tr>
      <td><strong>bind(a, a)</strong></td>
      <td>Produces "zero" effect (self-inverse)</td>
    </tr>
    <tr>
      <td><strong>bind(bind(a, b), b)</strong></td>
      <td>≈ a (reversibility)</td>
    </tr>
    <tr>
      <td><strong>similarity(v, v)</strong></td>
      <td>= 1.0 (reflexive)</td>
    </tr>
    <tr>
      <td><strong>similarity(a, b)</strong></td>
      <td>= similarity(b, a) (symmetric)</td>
    </tr>
    <tr>
      <td><strong>similarity(random, random)</strong></td>
      <td>≈ 0.5 ± 0.05 (quasi-orthogonal)</td>
    </tr>
    <tr>
      <td><strong>bundle([a,b,c]).similarity(a)</strong></td>
      <td>> 0.5 for small n (retrievable)</td>
    </tr>
  </table>

  <h2>Step 1: Create Strategy File</h2>
  <p>Create <code>src/hdc/strategies/your-strategy.mjs</code>:</p>

  <pre><code>/**
 * AGISystem2 - Your Custom HDC Strategy
 * @module hdc/strategies/your-strategy
 */

// ============================================================================
// VECTOR CLASS (Internal)
// ============================================================================

class YourVector {
  constructor(geometry, data = null) {
    this.geometry = geometry;
    this.strategyId = 'your-strategy';
    // Initialize your data structure
    this.data = data || this.createEmpty(geometry);
  }

  createEmpty(geometry) {
    // Return your empty data structure
  }

  // Required instance methods for backward compat:
  // getBit(index), setBit(index, value), popcount(), density()
  // clone(), equals(other), serialize()
  // xorInPlace(other), andInPlace(other), orInPlace(other), notInPlace()
  // zero(), ones()

  // Required static methods:
  // static random(geometry, randomFn)
  // static zeros(geometry)
  // static ones(geometry)
  // static deserialize(obj)
}

// ============================================================================
// STRATEGY PROPERTIES
// ============================================================================

const properties = {
  id: 'your-strategy',
  displayName: 'Your Strategy Name',
  recommendedBundleCapacity: 7,      // Optimal vectors to bundle
  maxBundleCapacity: 100,            // Before accuracy drops
  bytesPerVector: (geo) => geo / 8,  // Memory estimate
  bindComplexity: 'O(n)',            // Big-O notation
  sparseOptimized: false,            // Benefits from sparse data?
  description: 'Description of your strategy'
};

// ============================================================================
// FACTORY FUNCTIONS
// ============================================================================

function createZero(geometry) {
  return new YourVector(geometry);
}

function createRandom(geometry, seed = null) {
  // Create vector with ~50% density
  const v = new YourVector(geometry);
  // Fill with random data...
  return v;
}

function createFromName(name, geometry) {
  // CRITICAL: Same (name, geometry) must always produce same vector!
  // Use deterministic hash-based PRNG
  const seed = hashFunction(name);
  return createRandom(geometry, seed);
}

function deserialize(serialized) {
  if (serialized.strategyId !== 'your-strategy') {
    throw new Error('Wrong strategy');
  }
  const v = new YourVector(serialized.geometry);
  // Restore data from serialized.data
  return v;
}

// ============================================================================
// CORE OPERATIONS
// ============================================================================

function bind(a, b) {
  // Must be: associative, commutative, self-inverse
  // For binary: XOR
  // For polynomial: multiply mod irreducible
  if (a.geometry !== b.geometry) {
    throw new Error('Geometry mismatch');
  }
  const result = clone(a);
  // Apply binding operation...
  return result;
}

function bindAll(...vectors) {
  if (vectors.length === 0) throw new Error('Need at least one vector');
  let result = clone(vectors[0]);
  for (let i = 1; i &lt; vectors.length; i++) {
    result = bind(result, vectors[i]);
  }
  return result;
}

function bundle(vectors, tieBreaker = null) {
  // Superposition: result similar to ALL inputs
  // For binary: majority vote per bit
  // For polynomial: weighted sum
  if (vectors.length === 0) throw new Error('Need at least one vector');
  if (vectors.length === 1) return clone(vectors[0]);

  const geometry = vectors[0].geometry;
  const result = new YourVector(geometry);
  // Apply bundling operation...
  return result;
}

function similarity(a, b) {
  // Range: [0, 1], reflexive, symmetric
  // For binary: 1 - (hamming distance / geometry)
  // For polynomial: cosine similarity
  if (a.geometry !== b.geometry) {
    throw new Error('Geometry mismatch');
  }
  // Calculate and return similarity...
  return 0.5; // placeholder
}

function unbind(composite, component) {
  // For self-inverse bind: unbind === bind
  return bind(composite, component);
}

// ============================================================================
// UTILITY OPERATIONS
// ============================================================================

function clone(v) {
  const result = new YourVector(v.geometry);
  // Copy data...
  return result;
}

function equals(a, b) {
  if (a.geometry !== b.geometry) return false;
  // Compare data...
  return true;
}

function serialize(v) {
  return {
    strategyId: 'your-strategy',
    geometry: v.geometry,
    version: 1,
    data: /* your serialization */
  };
}

function topKSimilar(query, vocabulary, k = 5) {
  const results = [];
  const entries = vocabulary instanceof Map
    ? vocabulary.entries()
    : Object.entries(vocabulary);

  for (const [name, vec] of entries) {
    results.push({ name, similarity: similarity(query, vec) });
  }
  results.sort((a, b) => b.similarity - a.similarity);
  return results.slice(0, k);
}

function distance(a, b) {
  return 1 - similarity(a, b);
}

function isOrthogonal(a, b, threshold = 0.55) {
  const sim = similarity(a, b);
  return sim &lt; threshold && sim > (1 - threshold);
}

// ============================================================================
// EXPORT STRATEGY OBJECT
// ============================================================================

export const yourStrategy = {
  id: 'your-strategy',
  properties,

  // Factory
  createZero,
  createRandom,
  createFromName,
  deserialize,

  // Core operations
  bind,
  bindAll,
  bundle,
  similarity,
  unbind,

  // Utilities
  clone,
  equals,
  serialize,
  topKSimilar,
  distance,
  isOrthogonal,

  // Internal class (for advanced use)
  Vector: YourVector
};

export default yourStrategy;</code></pre>

  <h2>Step 2: Register Strategy</h2>
  <p>Edit <code>src/hdc/strategies/index.mjs</code>:</p>

  <pre><code>import { denseBinaryStrategy } from './dense-binary.mjs';
import { yourStrategy } from './your-strategy.mjs';

const strategies = new Map();

// Register strategies
strategies.set('dense-binary', denseBinaryStrategy);
strategies.set('your-strategy', yourStrategy);  // ADD THIS

export function getStrategy(strategyId) {
  const strategy = strategies.get(strategyId);
  if (!strategy) {
    throw new Error(`Unknown strategy: ${strategyId}`);
  }
  return strategy;
}

// ... rest of file</code></pre>

  <h2>Step 3: Validate Contract</h2>
  <p>Use the built-in validator to check your strategy:</p>

  <pre><code>import { validateStrategy } from './src/hdc/contract.mjs';
import { yourStrategy } from './src/hdc/strategies/your-strategy.mjs';

const result = validateStrategy(yourStrategy, 2048);

if (result.valid) {
  console.log('Strategy passes contract!');
} else {
  console.log('Contract violations:');
  for (const error of result.errors) {
    console.log('  -', error);
  }
}</code></pre>

  <h2>Step 4: Test with Eval Suite</h2>
  <pre><code># Run eval suite with your strategy
SYS2_HDC_STRATEGY=your-strategy npm run eval</code></pre>

  <h2>Step 5: Benchmark</h2>
  <pre><code>import { compareStrategies } from './src/hdc/facade.mjs';

const results = compareStrategies(
  ['dense-binary', 'your-strategy'],
  8192,
  { iterations: 1000 }
);

console.log(JSON.stringify(results, null, 2));</code></pre>

  <h2>Example: Sparse Polynomial Strategy (Sketch)</h2>
  <p>A sparse polynomial strategy might represent vectors as polynomials over GF(2)[x]:</p>

  <pre><code>class SparsePolyVector {
  constructor(geometry) {
    this.geometry = geometry;
    this.strategyId = 'sparse-polynomial';
    // Store as Map&lt;exponent, coefficient&gt;
    this.terms = new Map();
  }
}

function bind(a, b) {
  // Polynomial multiplication mod irreducible polynomial
  const result = new SparsePolyVector(a.geometry);
  for (const [expA, coefA] of a.terms) {
    for (const [expB, coefB] of b.terms) {
      const newExp = (expA + expB) % a.geometry;
      const newCoef = coefA * coefB;
      result.terms.set(newExp,
        (result.terms.get(newExp) || 0) + newCoef
      );
    }
  }
  return result;
}

function similarity(a, b) {
  // Cosine similarity in polynomial coefficient space
  let dotProduct = 0, normA = 0, normB = 0;
  // ... calculate ...
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}</code></pre>

  <h2>Properties to Consider</h2>
  <table class="matrix-table">
    <tr>
      <td><strong>Memory</strong></td>
      <td>Sparse strategies use less memory for low-density vectors</td>
    </tr>
    <tr>
      <td><strong>Speed</strong></td>
      <td>Dense strategies are faster for dense vectors (SIMD-friendly)</td>
    </tr>
    <tr>
      <td><strong>Capacity</strong></td>
      <td>How many vectors can be bundled before accuracy drops?</td>
    </tr>
    <tr>
      <td><strong>Noise</strong></td>
      <td>How does noise accumulate through operations?</td>
    </tr>
  </table>

  <h2>Sparse Polynomial HDC (SPHDC) Strategy</h2>
  <p>The SPHDC strategy implements sparse HDC using Integer-XOR binding with Min-Hash sampling.</p>

  <h3>Mathematical Foundations</h3>
  <ul>
    <li><strong>Binding:</strong> C = A ⊗ B = {a ⊕ b | a ∈ A, b ∈ B} using Integer XOR</li>
    <li><strong>Self-Inverse:</strong> (A ⊗ B) ⊗ B ≈ A (approximate due to sparsification)</li>
    <li><strong>Commutative:</strong> bind(a,b) = bind(b,a) (perfectly preserved)</li>
    <li><strong>Similarity:</strong> Jaccard Index: |A ∩ B| / |A ∪ B|</li>
  </ul>

  <h3>Implementation Details</h3>
  <ul>
    <li><strong>Vector Representation:</strong> Sparse set of 64-bit integers (max 500 exponents)</li>
    <li><strong>Sparsification:</strong> Min-Hash sampling with deterministic sorting</li>
    <li><strong>Memory:</strong> ~4KB per vector (500 × 8 bytes)</li>
    <li><strong>Performance:</strong> O(k² log k) binding, O(k) similarity</li>
  </ul>

  <h3>Use Cases</h3>
  <ul>
    <li>Large knowledge bases (>10K facts)</li>
    <li>Complex hierarchical data structures</li>
    <li>Memory-constrained environments</li>
    <li>Applications where statistical robustness > perfect properties</li>
  </ul>

  <h3>Comparison of All Three Strategies</h3>
  <table class="matrix-table">
    <tr>
      <td><strong>Property</strong></td>
      <td><strong>Dense Binary</strong></td>
      <td><strong>Sparse Polynomial</strong></td>
      <td><strong>Metric-Affine</strong></td>
    </tr>
    <tr>
      <td>Dimensionality</td>
      <td>Fixed (2048-4096 bits)</td>
      <td>Infinite (k=4-8 exponents)</td>
      <td>Fixed (32 byte channels)</td>
    </tr>
    <tr>
      <td>Binding Operation</td>
      <td>XOR (bitwise)</td>
      <td>Symmetric difference</td>
      <td>Affine transformation</td>
    </tr>
    <tr>
      <td>Binding Speed</td>
      <td>Fast (O(n/32))</td>
      <td>Slower (O(k²))</td>
      <td><strong>Fastest (O(m))</strong></td>
    </tr>
    <tr>
      <td>Memory per Vector</td>
      <td>256-512 bytes</td>
      <td>32 bytes (k=4 default)</td>
      <td><strong>32 bytes</strong></td>
    </tr>
    <tr>
      <td>Similarity Metric</td>
      <td>Hamming distance</td>
      <td>Jaccard index</td>
      <td>Channel overlap</td>
    </tr>
    <tr>
      <td>Performance (Core Theory)</td>
      <td>516ms (symbolic)</td>
      <td>523ms (symbolic)</td>
      <td><strong>225ms (symbolic)</strong> ⚡ 2.3x faster</td>
    </tr>
    <tr>
      <td>Self-Inverse</td>
      <td>Perfect</td>
      <td>Approximate</td>
      <td>Approximate</td>
    </tr>
    <tr>
      <td>Commutative</td>
      <td>Perfect</td>
      <td>Perfect</td>
      <td>Perfect</td>
    </tr>
    <tr>
      <td>Best For</td>
      <td>Research, standard HDC</td>
      <td>Large KBs, memory-constrained</td>
      <td><strong>Production systems, speed-critical apps</strong></td>
    </tr>
  </table>

  <p>See the <a href="sphdc-comparison.html">SPHDC Comparison Guide</a> for detailed benchmarks and recommendations.</p>

  <h2>Common Pitfalls</h2>
  <ul>
    <li><strong>Non-deterministic createFromName:</strong> Must produce identical vector for same input!</li>
    <li><strong>Geometry mismatch:</strong> Always check geometries match before operations</li>
    <li><strong>Bind not self-inverse:</strong> bind(bind(a,b), b) must approximately recover a</li>
    <li><strong>Similarity out of range:</strong> Must return value in [0, 1]</li>
  </ul>

  <div class="footer-nav">
    <a href="../index.html">← Back to Documentation</a>
  </div>
  </div>

  <style>
    .matrix-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    .matrix-table td {
      border: 1px solid #ddd;
      padding: 12px;
      vertical-align: top;
    }
    .matrix-table td:first-child {
      width: 180px;
      background: #f5f5f5;
    }
    pre {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
      font-size: 13px;
    }
    code {
      font-family: 'Consolas', 'Monaco', monospace;
    }
    .section-intro {
      background: #e3f2fd;
      padding: 15px 20px;
      border-radius: 8px;
      margin: 15px 0;
    }
    h2 {
      margin-top: 30px;
      border-bottom: 2px solid #1976d2;
      padding-bottom: 5px;
    }
    .footer-nav {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #ddd;
    }
  </style>
</body>
</html>
