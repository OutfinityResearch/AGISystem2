<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>FSP vs Dense Binary Comparison - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>FSP vs Dense Binary: Strategy Comparison</h1>
    <small>
      <a href="index.html">Guides</a> ·
      <a href="hdc-strategies.html">HDC Strategies</a>
    </small>
    <small>Detailed comparison of Fractal Semantic Polynomials and Dense Binary strategies</small>
  </div>

  <div class="section-intro">
    <p>This guide compares the two HDC strategies available in AGISystem2, helping you choose the right approach for your application.</p>
  </div>

  <h2>Architecture Overview</h2>
  
  <div class="section-card">
    <h3>Dense Binary Strategy</h3>
    <p>Traditional HDC using fixed-dimensional vectors and bitwise operations.</p>
    <ul>
      <li><strong>Representation:</strong> Uint32Array with fixed geometry (e.g., 32,768 bits)</li>
      <li><strong>Binding:</strong> Bitwise XOR (⊕)</li>
      <li><strong>Bundle:</strong> Majority vote per bit</li>
      <li><strong>Similarity:</strong> 1 - (Hamming distance / geometry)</li>
    </ul>
    
    <h4>Properties</h4>
    <ul>
      <li>✅ Perfect self-inverse: bind(bind(a,b), b) = a</li>
      <li>✅ Perfect associative: bind(bind(a,b), c) = bind(a, bind(b,c))</li>
      <li>✅ Perfect commutative: bind(a,b) = bind(b,a)</li>
      <li>✅ Fast operations: O(n/32) complexity</li>
      <li>❌ Fixed dimensionality limits scalability</li>
    </ul>
    
    <h4>Performance</h4>
    <ul>
      <li>Binding: ~255K ops/sec</li>
      <li>Similarity: ~145K ops/sec</li>
      <li>Bundle: ~948 ops/sec</li>
      <li>Memory: 4KB per vector</li>
    </ul>
  </div>

  <div class="section-card">
    <h3>Fractal Semantic Polynomials (FSP)</h3>
    <p>Infinite-dimensional HDC using sparse integer exponents and statistical sampling.</p>
    <ul>
      <li><strong>Representation:</strong> Set of 64-bit integers (sparse, max 500 exponents)</li>
      <li><strong>Binding:</strong> Integer XOR (⊕) with Min-Hash sampling</li>
      <li><strong>Bundle:</strong> Set union with Min-Hash sampling</li>
      <li><strong>Similarity:</strong> Jaccard Index (|A ∩ B| / |A ∪ B|)</li>
    </ul>
    
    <h4>Properties</h4>
    <ul>
      <li>✅ Infinite dimensionality: No theoretical limits</li>
      <li>⚠️ Approximate self-inverse: bind(bind(a,b), b) ≈ a</li>
      <li>✅ Perfect commutative: bind(a,b) = bind(b,a)</li>
      <li>❌ Slower operations: O(k² log k) complexity</li>
      <li>✅ Memory efficient: ~4KB per vector</li>
    </ul>
    
    <h4>Performance</h4>
    <ul>
      <li>Binding: ~15 ops/sec</li>
      <li>Similarity: ~7K ops/sec</li>
      <li>Bundle: ~1.8K ops/sec</li>
      <li>Memory: 4KB per vector</li>
    </ul>
  </div>

  <h2>Mathematical Properties Comparison</h2>
  
  <table class="matrix-table">
    <tr>
      <td><strong>Property</strong></td>
      <td><strong>Dense Binary</strong></td>
      <td><strong>FSP</strong></td>
      <td><strong>Impact</strong></td>
    </tr>
    <tr>
      <td>Self-Inverse</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Approximate (sim ≈ 0.001-0.01)</td>
      <td>Fundamental trade-off of sparsification</td>
    </tr>
    <tr>
      <td>Associative</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Approximate (sim ≈ 0.0-0.1)</td>
      <td>Deterministic but limited by sampling</td>
    </tr>
    <tr>
      <td>Commutative</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Preserved by deterministic sorting</td>
    </tr>
    <tr>
      <td>Reflexive</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Both work perfectly</td>
    </tr>
    <tr>
      <td>Symmetric</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Both work perfectly</td>
    </tr>
  </table>

  <h2>Performance Comparison</h2>
  
  <h3>Binding Operation</h3>
  <p>Measures time to bind two vectors (average of 1000 iterations):</p>
  <table class="matrix-table">
    <tr>
      <td><strong>Vector Size</strong></td>
      <td><strong>Dense Binary</strong></td>
      <td><strong>FSP</strong></td>
      <td><strong>Ratio</strong></td>
    </tr>
    <tr>
      <td>50 exponents</td>
      <td>0.005ms</td>
      <td>64.6ms</td>
      <td>12,920× slower</td>
    </tr>
    <tr>
      <td>100 exponents</td>
      <td>0.007ms</td>
      <td>258ms</td>
      <td>36,857× slower</td>
    </tr>
    <tr>
      <td>500 exponents</td>
      <td>0.004ms</td>
      <td>64.6ms</td>
      <td>16,150× slower</td>
    </tr>
  </table>

  <h3>Similarity Calculation</h3>
  <p>Measures time to calculate similarity between vectors:</p>
  <table class="matrix-table">
    <tr>
      <td><strong>Vector Size</strong></td>
      <td><strong>Dense Binary</strong></td>
      <td><strong>FSP</strong></td>
      <td><strong>Ratio</strong></td>
    </tr>
    <tr>
      <td>50 exponents</td>
      <td>0.007ms</td>
      <td>0.14ms</td>
      <td>20× slower</td>
    </tr>
    <tr>
      <td>100 exponents</td>
      <td>0.007ms</td>
      <td>0.28ms</td>
      <td>40× slower</td>
    </tr>
    <tr>
      <td>500 exponents</td>
      <td>0.007ms</td>
      <td>0.14ms</td>
      <td>20× slower</td>
    </tr>
  </table>

  <h3>Bundle Operation</h3>
  <p>Measures time to bundle 5 vectors:</p>
  <table class="matrix-table">
    <tr>
      <td><strong>Vectors</strong></td>
      <td><strong>Dense Binary</strong></td>
      <td><strong>FSP</strong></td>
      <td><strong>Ratio</strong></td>
    </tr>
    <tr>
      <td>5 vectors</td>
      <td>1.06ms</td>
      <td>0.57ms</td>
      <td>2× faster</td>
    </tr>
  </table>

  <h2>Use Case Recommendations</h2>
  
  <div class="section-card">
    <h3>Choose Dense Binary when:</h3>
    <ul>
      <li>Maximum performance is required</li>
      <li>Working with smaller knowledge bases (&lt;10K facts)</li>
      <li>Need perfect mathematical properties</li>
      <li>Backward compatibility is important</li>
      <li>Simple, proven implementation preferred</li>
    </ul>
  </div>

  <div class="section-card">
    <h3>Choose FSP when:</h3>
    <ul>
      <li>Need infinite scalability for large knowledge bases</li>
      <li>Working with complex, hierarchical data structures</li>
      <li>Memory efficiency is critical</li>
      <li>Statistical robustness &gt; perfect properties</li>
      <li>Deterministic, reproducible results required</li>
    </ul>
  </div>

  <h2>Implementation Example</h2>
  
  <pre><code>// Initialize with FSP strategy
import { initHDC } from './src/hdc/facade.mjs';
initHDC('fractal-semantic');

// Create vectors
const fsp = getStrategy('fractal-semantic');
const vectorA = fsp.createFromName('ConceptA', 500);
const vectorB = fsp.createFromName('ConceptB', 500);

// Bind vectors (Integer XOR + Min-Hash)
const bound = fsp.bind(vectorA, vectorB);

// Calculate similarity (Jaccard Index)
const similarity = fsp.similarity(vectorA, vectorB);

// Bundle multiple vectors
const bundled = fsp.bundle([vectorA, vectorB, vectorC]);</code></pre>

  <h2>Advanced Topics</h2>
  
  <h3>Hybrid Strategies</h3>
  <p>Consider combining FSP and dense binary strategies:</p>
  <ul>
    <li>Use FSP for large-scale knowledge representation</li>
    <li>Use dense binary for high-performance queries</li>
    <li>Implement adaptive strategy selection based on workload</li>
  </ul>

  <h3>Performance Optimization</h3>
  <p>Techniques to improve FSP performance:</p>
  <ul>
    <li>Optimize Min-Hash sampling algorithm</li>
    <li>Use parallel processing for binding</li>
    <li>Cache frequent similarity calculations</li>
    <li>Adaptive vector sizes based on data</li>
  </ul>

  <div class="footer-nav">
    <a href="hdc-strategies.html">← Back to HDC Strategies</a>
  </div>
  </div>

  <style>
    .matrix-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    .matrix-table td {
      border: 1px solid #ddd;
      padding: 8px;
    }
    .matrix-table th {
      border: 1px solid #ddd;
      padding: 8px;
      background: #f5f5f5;
    }
  </style>
</body>
</html>
