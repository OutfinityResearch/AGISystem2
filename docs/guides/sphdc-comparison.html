<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>SPHDC vs Dense Binary Comparison - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>SPHDC vs Dense Binary: Strategy Comparison</h1>
    <small>
      <a href="index.html">Guides</a> ·
      <a href="hdc-strategies.html">HDC Strategies</a>
    </small>
    <small>Detailed comparison of Sparse Polynomial HDC and Dense Binary strategies</small>
  </div>

  <div class="section-intro">
    <p>This guide compares the two HDC strategies available in AGISystem2, helping you choose the right approach for your application.</p>
  </div>

  <h2>Architecture Overview</h2>

  <div class="section-card">
    <h3>Dense Binary Strategy</h3>
    <p>Traditional HDC using fixed-dimensional vectors and bitwise operations.</p>
    <ul>
      <li><strong>Representation:</strong> Uint32Array with fixed geometry (e.g., 32,768 bits)</li>
      <li><strong>Binding:</strong> Bitwise XOR (⊕)</li>
      <li><strong>Bundle:</strong> Majority vote per bit</li>
      <li><strong>Similarity:</strong> 1 - (Hamming distance / geometry)</li>
    </ul>

    <h4>Properties</h4>
    <ul>
      <li>✅ Perfect self-inverse: bind(bind(a,b), b) = a</li>
      <li>✅ Perfect associative: bind(bind(a,b), c) = bind(a, bind(b,c))</li>
      <li>✅ Perfect commutative: bind(a,b) = bind(b,a)</li>
      <li>✅ Fast operations: O(n/32) complexity</li>
      <li>❌ Fixed dimensionality limits scalability</li>
    </ul>

    <h4>Performance</h4>
    <ul>
      <li>Binding: ~255K ops/sec</li>
      <li>Similarity: ~145K ops/sec</li>
      <li>Bundle: ~948 ops/sec</li>
      <li>Memory: 256 bytes per vector</li>
    </ul>
  </div>

  <div class="section-card">
    <h3>Sparse Polynomial HDC (SPHDC)</h3>
    <p>Sparse HDC using k BigInt exponents with Cartesian XOR binding.</p>
    <ul>
      <li><strong>Representation:</strong> Set of k 64-bit integers (default k=4, 32 bytes)</li>
      <li><strong>Binding:</strong> Cartesian XOR (⊕) with Min-Hash sparsification</li>
      <li><strong>Bundle:</strong> Set union with Min-Hash sampling</li>
      <li><strong>Similarity:</strong> Jaccard Index (|A ∩ B| / |A ∪ B|)</li>
    </ul>

    <h4>Properties</h4>
    <ul>
      <li>✅ 8x smaller memory footprint</li>
      <li>✅ Self-inverse: bind(bind(a,b), b) = a (XOR property)</li>
      <li>✅ Perfect commutative: bind(a,b) = bind(b,a)</li>
      <li>✅ 1.5x faster than Dense Binary</li>
      <li>✅ Memory efficient: 32 bytes per vector (k=4)</li>
    </ul>

    <h4>Performance</h4>
    <ul>
      <li>Binding: O(k²) = O(16) XOR ops for k=4</li>
      <li>Similarity: O(k) with sorted sets</li>
      <li>Bundle: Set union + sparsification</li>
      <li>Memory: 32 bytes per vector (k=4)</li>
    </ul>
  </div>

  <h2>Mathematical Properties Comparison</h2>

  <table class="matrix-table">
    <tr>
      <td><strong>Property</strong></td>
      <td><strong>Dense Binary</strong></td>
      <td><strong>SPHDC</strong></td>
      <td><strong>Impact</strong></td>
    </tr>
    <tr>
      <td>Self-Inverse</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Perfect (XOR property)</td>
      <td>Both strategies preserve self-inverse</td>
    </tr>
    <tr>
      <td>Associative</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Perfect (XOR property)</td>
      <td>Both work perfectly</td>
    </tr>
    <tr>
      <td>Commutative</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Preserved by deterministic sorting</td>
    </tr>
    <tr>
      <td>Reflexive</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Both work perfectly</td>
    </tr>
    <tr>
      <td>Symmetric</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Perfect (sim = 1.0)</td>
      <td>Both work perfectly</td>
    </tr>
  </table>

  <h2>Performance Comparison</h2>

  <h3>Eval Suite Results</h3>
  <table class="matrix-table">
    <tr>
      <td><strong>Metric</strong></td>
      <td><strong>Dense Binary</strong></td>
      <td><strong>SPHDC (k=4)</strong></td>
      <td><strong>Winner</strong></td>
    </tr>
    <tr>
      <td>Pass Rate</td>
      <td>100% (126/126)</td>
      <td>100% (126/126)</td>
      <td>Tie</td>
    </tr>
    <tr>
      <td>Total Time</td>
      <td>91ms</td>
      <td>60ms</td>
      <td>SPHDC (1.5x faster)</td>
    </tr>
    <tr>
      <td>Memory/Vector</td>
      <td>256 bytes</td>
      <td>32 bytes</td>
      <td>SPHDC (8x smaller)</td>
    </tr>
    <tr>
      <td>HDC Retrieval</td>
      <td>35% success</td>
      <td>0% success</td>
      <td>Dense (better retrieval)</td>
    </tr>
  </table>

  <h2>Use Case Recommendations</h2>

  <div class="section-card">
    <h3>Choose Dense Binary when:</h3>
    <ul>
      <li>Similarity-based retrieval is required (HDC Master Equation)</li>
      <li>Research/comparison baseline needed</li>
      <li>Standard HDC semantics required</li>
      <li>Backward compatibility is important</li>
    </ul>
  </div>

  <div class="section-card">
    <h3>Choose SPHDC when:</h3>
    <ul>
      <li>Pure symbolic reasoning (KB matching, transitive chains)</li>
      <li>Memory-constrained environments (8x smaller vectors)</li>
      <li>Maximum speed needed (1.5x faster)</li>
      <li>Large knowledge bases</li>
      <li>Deterministic, reproducible results required</li>
    </ul>
  </div>

  <h2>Implementation Example</h2>

  <pre><code>// Initialize with SPHDC strategy
import { initHDC } from './src/hdc/facade.mjs';
initHDC('sparse-polynomial');

// Create vectors
const sphdc = getStrategy('sparse-polynomial');
const vectorA = sphdc.createFromName('ConceptA', 4);  // k=4
const vectorB = sphdc.createFromName('ConceptB', 4);

// Bind vectors (Cartesian XOR)
const bound = sphdc.bind(vectorA, vectorB);

// Calculate similarity (Jaccard Index)
const similarity = sphdc.similarity(vectorA, vectorB);

// Bundle multiple vectors
const bundled = sphdc.bundle([vectorA, vectorB, vectorC]);</code></pre>

  <h2>Advanced Topics</h2>

  <h3>Hybrid Strategies</h3>
  <p>Consider combining SPHDC and dense binary strategies:</p>
  <ul>
    <li>Use SPHDC for symbolic reasoning (faster, smaller)</li>
    <li>Use dense binary for similarity-based retrieval</li>
    <li>Implement adaptive strategy selection based on workload</li>
  </ul>

  <h3>k Parameter Tuning</h3>
  <p>SPHDC performance varies with k:</p>
  <ul>
    <li><strong>k=4 (default):</strong> Best balance of speed and safety margin</li>
    <li><strong>k=2 or k=1:</strong> Maximum speed for simple use cases</li>
    <li><strong>k=8+:</strong> Not recommended (slower, no accuracy benefit)</li>
  </ul>

  <div class="footer-nav">
    <a href="hdc-strategies.html">← Back to HDC Strategies</a>
  </div>
  </div>

  <style>
    .matrix-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    .matrix-table td {
      border: 1px solid #ddd;
      padding: 8px;
    }
    .matrix-table th {
      border: 1px solid #ddd;
      padding: 8px;
      background: #f5f5f5;
    }
    .section-card {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin: 15px 0;
    }
    .section-intro {
      background: #e3f2fd;
      padding: 15px 20px;
      border-radius: 8px;
      margin: 15px 0;
    }
    pre {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
      font-size: 13px;
    }
    code {
      font-family: 'Consolas', 'Monaco', monospace;
    }
    h2 {
      margin-top: 30px;
      border-bottom: 2px solid #1976d2;
      padding-bottom: 5px;
    }
  </style>
</body>
</html>
