<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deterministic Vector Generation - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
  <style>
    .pipeline-box {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
    }
    .pipeline-step {
      display: flex;
      align-items: center;
      margin: 10px 0;
    }
    .step-number {
      background: #007bff;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      margin-right: 15px;
      flex-shrink: 0;
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    .comparison-table th, .comparison-table td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: left;
    }
    .comparison-table th {
      background: #f5f5f5;
    }
    .formula-box {
      background: #e8f4fd;
      border-left: 4px solid #0066cc;
      padding: 15px;
      margin: 15px 0;
      font-family: monospace;
    }
    .warning-box {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin: 15px 0;
    }
    .privacy-box {
      background: #d4edda;
      border: 1px solid #28a745;
      border-left: 4px solid #28a745;
      padding: 15px;
      margin: 15px 0;
    }
    .code-block {
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 13px;
    }
    .code-block .comment { color: #6272a4; }
    .code-block .keyword { color: #ff79c6; }
    .code-block .string { color: #f1fa8c; }
    .code-block .number { color: #bd93f9; }
  </style>
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Deterministic Vector Generation</h1>
    <small>
      <a href="../index.html">Home</a> &middot;
      <a href="index.html">Theory</a> &middot;
      <a href="../syntax/index.html">Syntax</a> &middot;
      <a href="../api/index.html">APIs</a>
    </small>
    <small>How atom names become hypervectors</small>
  </div>

  <div class="section-intro">
    <p>AGISystem2 generates <strong>deterministic hypervectors</strong> from atom names. This ensures that the same concept name always produces the same vector, enabling reproducibility, distributed computation, and privacy-preserving architectures.</p>
  </div>

  <div class="privacy-box">
    <strong>Privacy-Preserving Implications:</strong> Deterministic generation is foundational for <a href="privacy-hdc.html">privacy-preserving HDC</a>, federated learning, and partial homomorphic computation. The secret lies not in the algorithm, but in the <em>seed</em>.
  </div>

  <h2>1. The Generation Pipeline</h2>

  <p>Both HDC strategies (Dense-Binary and SPHDC) follow the same core pipeline:</p>

  <div class="pipeline-box">
    <div class="pipeline-step">
      <div class="step-number">1</div>
      <div><strong>Name Scoping:</strong> Combine theory ID with atom name for namespace isolation</div>
    </div>
    <div class="pipeline-step">
      <div class="step-number">2</div>
      <div><strong>Hash:</strong> Apply <a href="concepts/hash.html">DJB2 hash</a> to get 32-bit seed</div>
    </div>
    <div class="pipeline-step">
      <div class="step-number">3</div>
      <div><strong>PRNG:</strong> Initialize xorshift128+ with seed</div>
    </div>
    <div class="pipeline-step">
      <div class="step-number">4</div>
      <div><strong>Vector Fill:</strong> Generate vector content using PRNG (strategy-specific)</div>
    </div>
  </div>

  <div class="formula-box">
    <strong>Pipeline:</strong><br>
    name &rarr; scope(theoryId, name) &rarr; DJB2(scoped) &rarr; PRNG(seed) &rarr; Vector
  </div>

  <h2>2. Hash Function: DJB2</h2>

  <p>The <a href="concepts/hash.html">DJB2 hash</a> converts any string into a 32-bit unsigned integer:</p>

  <div class="code-block">
<span class="keyword">function</span> djb2(str) {
  <span class="keyword">let</span> hash = <span class="number">5381</span>;  <span class="comment">// Magic initial value</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < str.length; i++) {
    hash = ((hash << <span class="number">5</span>) + hash) + str.charCodeAt(i);
    <span class="comment">// Equivalent to: hash = hash * 33 + char</span>
    hash = hash >>> <span class="number">0</span>;  <span class="comment">// Convert to unsigned 32-bit</span>
  }
  <span class="keyword">return</span> hash;
}
  </div>

  <p><strong>Properties:</strong></p>
  <ul>
    <li><strong>Deterministic:</strong> Same input &rarr; same output, always</li>
    <li><strong>Fast:</strong> O(n) where n is string length</li>
    <li><strong>Good distribution:</strong> Different names produce well-distributed seeds</li>
    <li><strong>Not cryptographic:</strong> Fast but not secure against adversarial inputs</li>
  </ul>

  <h2>3. PRNG: xorshift128+</h2>

  <p>The seeded PRNG ensures identical random sequences from identical seeds:</p>

  <div class="code-block">
<span class="keyword">class</span> PRNG {
  <span class="keyword">constructor</span>(seed) {
    <span class="comment">// Initialize two 64-bit state values from seed</span>
    <span class="keyword">this</span>.s0 = BigInt(seed) | <span class="number">1n</span>;
    <span class="keyword">this</span>.s1 = BigInt(seed * <span class="number">0x6C078965</span>) | <span class="number">1n</span>;
  }

  random() {
    <span class="comment">// xorshift128+ algorithm</span>
    <span class="keyword">let</span> s1 = <span class="keyword">this</span>.s0;
    <span class="keyword">const</span> s0 = <span class="keyword">this</span>.s1;
    <span class="keyword">this</span>.s0 = s0;
    s1 ^= s1 << <span class="number">23n</span>;
    s1 ^= s1 >> <span class="number">17n</span>;
    s1 ^= s0;
    s1 ^= s0 >> <span class="number">26n</span>;
    <span class="keyword">this</span>.s1 = s1;
    <span class="keyword">return</span> Number(BigInt.asUintN(<span class="number">32</span>, s0 + s1)) / <span class="number">0xFFFFFFFF</span>;
  }
}
  </div>

  <p><strong>Properties:</strong></p>
  <ul>
    <li><strong>Period:</strong> 2<sup>128</sup> - 1 (astronomically long)</li>
    <li><strong>Quality:</strong> Passes BigCrush statistical tests</li>
    <li><strong>Speed:</strong> Very fast (simple bitwise operations)</li>
    <li><strong>Deterministic:</strong> Same seed &rarr; same sequence, guaranteed</li>
  </ul>

  <h2>4. Strategy-Specific Vector Fill</h2>

  <h3>4.1 Dense-Binary: ASCII Stamping</h3>

  <p>Dense-Binary creates vectors using a recognizable ASCII pattern combined with PRNG variation:</p>

  <div class="code-block">
<span class="keyword">function</span> createFromName(name, geometry, theoryId = <span class="string">'default'</span>) {
  <span class="comment">// Step 1: Scope name with theory ID</span>
  <span class="keyword">const</span> scopedName = theoryId + <span class="string">':'</span> + name;
  <span class="keyword">const</span> seed = djb2(scopedName);
  <span class="keyword">const</span> prng = <span class="keyword">new</span> PRNG(seed);

  <span class="comment">// Step 2: Create ASCII base stamp (256 bits)</span>
  <span class="keyword">const</span> ascii = name.split(<span class="string">''</span>).map(c => c.charCodeAt(<span class="number">0</span>) & <span class="number">0xFF</span>);
  <span class="keyword">const</span> baseStamp = packAsciiToWords(ascii);  <span class="comment">// 8 × 32-bit words</span>

  <span class="comment">// Step 3: Fill vector with stamped + varied chunks</span>
  <span class="keyword">for</span> (chunk of vector) {
    chunk = baseStamp XOR prng.nextWords(<span class="number">8</span>);
  }
}
  </div>

  <p><strong>Key characteristics:</strong></p>
  <ul>
    <li><strong>Theory-scoped:</strong> "default:Dog" ≠ "physics:Dog"</li>
    <li><strong>Debuggable:</strong> ASCII pattern survives in the vector</li>
    <li><strong>High-dimensional:</strong> Default 32,768 bits (4 KB)</li>
  </ul>

  <h3>4.2 Sparse Polynomial (SPHDC): Random Exponents</h3>

  <p>SPHDC generates k random 64-bit integers as exponents:</p>

  <div class="code-block">
<span class="keyword">function</span> createFromName(name, geometry = <span class="number">4</span>) {
  <span class="comment">// Hash name to get seed</span>
  <span class="keyword">const</span> seed = djb2(name);
  <span class="keyword">const</span> prng = <span class="keyword">new</span> PRNG(seed);

  <span class="comment">// Generate k unique 64-bit exponents</span>
  <span class="keyword">const</span> exponents = <span class="keyword">new</span> Set();
  <span class="keyword">while</span> (exponents.size < geometry) {
    <span class="keyword">const</span> high = prng.randomUint32();
    <span class="keyword">const</span> low = prng.randomUint32();
    exponents.add((BigInt(high) << <span class="number">32n</span>) | BigInt(low));
  }
  <span class="keyword">return</span> <span class="keyword">new</span> SPVector(exponents, geometry);
}
  </div>

  <p><strong>Key characteristics:</strong></p>
  <ul>
    <li><strong>Compact:</strong> Only k × 8 bytes (default 32 bytes for k=4)</li>
    <li><strong>Uniform:</strong> Pure random generation, no ASCII pattern</li>
    <li><strong>Fast:</strong> Only 2k random numbers needed</li>
  </ul>

  <div class="warning-box">
    <strong>Implementation Note:</strong> The current SPHDC implementation does not use theory scoping (theoryId parameter is ignored). This means the same atom name produces identical vectors across all theories. This is a known limitation for namespace isolation in SPHDC.
  </div>

  <h2>5. Comparison: Dense-Binary vs SPHDC</h2>

  <table class="comparison-table">
    <tr>
      <th>Aspect</th>
      <th>Dense-Binary</th>
      <th>SPHDC</th>
    </tr>
    <tr>
      <td>Hash Function</td>
      <td>DJB2</td>
      <td>DJB2</td>
    </tr>
    <tr>
      <td>PRNG</td>
      <td>xorshift128+</td>
      <td>xorshift128+</td>
    </tr>
    <tr>
      <td>Theory Scoping</td>
      <td>Yes (theoryId:name)</td>
      <td>No (name only)</td>
    </tr>
    <tr>
      <td>Vector Size</td>
      <td>geometry/8 bytes (4 KB default)</td>
      <td>k × 8 bytes (32 bytes default)</td>
    </tr>
    <tr>
      <td>Content</td>
      <td>ASCII stamp + PRNG variation</td>
      <td>k random BigInts</td>
    </tr>
    <tr>
      <td>Debuggability</td>
      <td>High (ASCII visible)</td>
      <td>Low (opaque numbers)</td>
    </tr>
    <tr>
      <td>Storage Efficiency</td>
      <td>Low (4 KB/vector)</td>
      <td>High (32 B/vector)</td>
    </tr>
  </table>

  <h2>6. Privacy-Preserving Applications</h2>

  <p>Deterministic vector generation is foundational for <a href="privacy-hdc.html">privacy-preserving HDC</a>:</p>

  <h3>6.1 Secret Seed Architecture</h3>

  <div class="privacy-box">
    <strong>Key Insight:</strong> If the seed derivation includes a <em>secret master key</em>, the atom vectors become secret keys. Without knowing the master key, an adversary cannot generate or decode vectors.
  </div>

  <div class="formula-box">
    <strong>Secret Seed Generation:</strong><br>
    scopedName = masterSecret + ":" + theoryId + ":" + name<br>
    seed = DJB2(scopedName)<br>
    vector = PRNG(seed) &rarr; [...bits or exponents...]
  </div>

  <h3>6.2 Federated Learning</h3>

  <p>Multiple parties can share a master seed and contribute knowledge without revealing it:</p>

  <ol>
    <li><strong>Setup:</strong> All parties agree on master seed S</li>
    <li><strong>Encoding:</strong> Each party encodes local facts using deterministic vectors</li>
    <li><strong>Aggregation:</strong> Coordinator bundles all KB vectors</li>
    <li><strong>Query:</strong> Any party can query using shared encoding</li>
  </ol>

  <p>The coordinator sees only bundled vectors, not individual facts.</p>

  <h3>6.3 Partial Homomorphic Properties</h3>

  <p>HDC operations exhibit homomorphic-like behavior:</p>

  <ul>
    <li><strong>Bundling is additive:</strong> bundle(E(A), E(B)) = E(A ∪ B)</li>
    <li><strong>Binding is multiplicative:</strong> bind(E(A), E(B)) = E(A ⊗ B)</li>
    <li><strong>Unbinding recovers:</strong> unbind(bind(E(A), E(B)), E(B)) ≈ E(A)</li>
  </ul>

  <p>This enables computation on encoded data without decoding. See <a href="privacy-hdc.html">Privacy-Preserving HDC</a> for detailed analysis of security properties and limitations.</p>

  <h2>7. Core Theory Atoms</h2>

  <p>When AGISystem2 loads core theories (from <code>config/Core/*.sys2</code>), atoms like <code>isA</code>, <code>__TransitiveRelation</code>, etc. get vectors through the same pipeline:</p>

  <div class="formula-box">
    <strong>Example: Loading "isA"</strong><br>
    1. Parser encounters: <code>@isA:isA __TransitiveRelation</code><br>
    2. Executor resolves "isA" &rarr; vocabulary.getOrCreate("isA")<br>
    3. First time: createFromName("isA", 32768, "default")<br>
    4. Vector cached in vocabulary.atoms["isA"]<br>
    5. Same vector used for all subsequent "isA" references
  </div>

  <p>This ensures:</p>
  <ul>
    <li><strong>Consistency:</strong> Same atom &rarr; same vector throughout session</li>
    <li><strong>Reproducibility:</strong> Same session config &rarr; same vectors</li>
    <li><strong>Efficiency:</strong> Vectors computed once, cached for reuse</li>
  </ul>

  <h2>8. Security Considerations</h2>

  <h3>8.1 What DJB2 Provides</h3>
  <ul>
    <li>Good distribution (collision resistance for typical names)</li>
    <li>Fast computation</li>
    <li>Deterministic mapping</li>
  </ul>

  <h3>8.2 What DJB2 Does NOT Provide</h3>
  <ul>
    <li>Cryptographic security (not preimage-resistant)</li>
    <li>Protection against dictionary attacks</li>
    <li>Forward secrecy</li>
  </ul>

  <h3>8.3 For Stronger Security</h3>

  <p>For applications requiring cryptographic guarantees:</p>
  <ul>
    <li>Replace DJB2 with SHA-256 or BLAKE3</li>
    <li>Use cryptographic PRNG (e.g., ChaCha20)</li>
    <li>Implement proper key derivation (HKDF)</li>
  </ul>

  <p>See <a href="privacy-hdc.html#threat-model">Privacy-Preserving HDC: Threat Model</a> for detailed security analysis.</p>

  <h2>Related Pages</h2>

  <ul>
    <li><a href="concepts/hash.html">Hash Functions (DJB2)</a> &mdash; detailed hash algorithm documentation</li>
    <li><a href="privacy-hdc.html">Privacy-Preserving HDC</a> &mdash; security analysis and federated applications</li>
    <li><a href="strategies/dense-binary.html">Dense-Binary Strategy</a> &mdash; ASCII stamping implementation</li>
    <li><a href="strategies/sparse-polynomial.html">SPHDC Strategy</a> &mdash; sparse exponent implementation</li>
    <li><a href="concepts/gf2.html">GF(2) - Galois Field</a> &mdash; algebraic foundation for XOR binding</li>
  </ul>

  <div class="footer-nav">
    <p>
      <a href="index.html">&larr; Theory Overview</a>
    </p>
  </div>
  </div>
</body>
</html>
