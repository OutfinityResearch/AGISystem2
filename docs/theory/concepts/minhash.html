<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Min-Hash - AGISystem2</title>
  <link rel="stylesheet" href="../../reference/style.css">
  <style>
    .math { font-family: "Times New Roman", serif; font-style: italic; }
    .formula {
      background: #f8f9fa;
      padding: 1em;
      border-left: 3px solid #007bff;
      margin: 1em 0;
      overflow-x: auto;
    }
    .formula code { background: none; }
  </style>
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Min-Hash</h1>
    <small>
      <a href="../../index.html">Home</a> &middot;
      <a href="../index.html">Theory</a> &middot;
      <a href="index.html">Concepts</a>
    </small>
    <small>Locality-sensitive hashing for set similarity</small>
  </div>

  <div class="section-intro">
    <p><strong>Min-Hash</strong> (Minimum Hash) is a locality-sensitive hashing technique that efficiently estimates <a href="jaccard.html">Jaccard similarity</a> between sets. It enables fast approximate comparison without computing full set intersections.</p>
  </div>

  <h2>The Core Insight</h2>

  <p>Given a random hash function h and two sets A and B:</p>

  <div class="formula">
    <code>P(min(h(A)) = min(h(B))) = J(A, B)</code>
    <br><br>
    The probability that A and B have the same minimum hash value
    <br>
    equals their Jaccard similarity.
  </div>

  <p>This remarkable property allows us to estimate Jaccard similarity by simply comparing hash minima.</p>

  <h2>Why Does This Work?</h2>

  <h3>Intuitive Explanation</h3>

  <p>Imagine sorting all elements of A ∪ B by their hash values. The element with the smallest hash could come from:</p>

  <ul>
    <li>Only A (probability proportional to |A - B|)</li>
    <li>Only B (probability proportional to |B - A|)</li>
    <li>Both A and B (probability proportional to |A ∩ B|)</li>
  </ul>

  <p>The probability that the minimum comes from the intersection is:</p>

  <div class="formula">
    <code>|A ∩ B| / |A ∪ B| = J(A, B)</code>
  </div>

  <h3>Formal Proof</h3>

  <div class="formula">
    Let h be a uniform random hash function.
    <br>
    Let x* = argmin<sub>x ∈ A∪B</sub> h(x) be the element with minimum hash.
    <br><br>
    Since h is uniform, each element in A∪B is equally likely to be x*.
    <br><br>
    P(x* ∈ A ∩ B) = |A ∩ B| / |A ∪ B| = J(A, B)
    <br><br>
    If x* ∈ A ∩ B, then min(h(A)) = min(h(B)) = h(x*).
    <br>
    Therefore: P(min(h(A)) = min(h(B))) = J(A, B). ∎
  </div>

  <h2>Min-Hash Signature</h2>

  <p>To get a better estimate, we use multiple hash functions:</p>

  <div class="formula">
    Given k hash functions h<sub>1</sub>, h<sub>2</sub>, ..., h<sub>k</sub>:
    <br><br>
    Signature(A) = [min(h<sub>1</sub>(A)), min(h<sub>2</sub>(A)), ..., min(h<sub>k</sub>(A))]
    <br><br>
    Estimated Jaccard: J'(A,B) = (# matching components) / k
  </div>

  <h3>Estimation Accuracy</h3>

  <p>The estimate is unbiased with variance decreasing as k increases:</p>

  <div class="formula">
    E[J'(A,B)] = J(A,B) (unbiased)
    <br><br>
    Var[J'(A,B)] = J(A,B)(1 - J(A,B)) / k
    <br><br>
    Standard error ≈ 1/√k
  </div>

  <table>
    <tr>
      <th>k (hash functions)</th>
      <th>Standard Error</th>
      <th>95% Confidence</th>
    </tr>
    <tr>
      <td>4</td>
      <td>±0.50</td>
      <td>±1.00</td>
    </tr>
    <tr>
      <td>16</td>
      <td>±0.25</td>
      <td>±0.50</td>
    </tr>
    <tr>
      <td>64</td>
      <td>±0.125</td>
      <td>±0.25</td>
    </tr>
    <tr>
      <td>256</td>
      <td>±0.0625</td>
      <td>±0.125</td>
    </tr>
  </table>

  <h2>Application in SPHDC</h2>

  <p>In <a href="../strategies/sphdc-analysis.html">SPHDC</a>, Min-Hash serves a dual purpose:</p>

  <h3>1. Sparsification</h3>

  <p>When binding produces more than k elements, Min-Hash selects which elements to keep:</p>

  <div class="formula">
    <code>A BIND B = MinHashSelect({ a xor b | a ∈ A, b ∈ B }, k)</code>
    <br><br>
    From k² candidates, keep only the k with smallest hash values.
  </div>

  <p>This ensures bounded memory while preserving similarity structure.</p>

  <h3>2. Similarity Preservation</h3>

  <p>After sparsification, the remaining elements serve as a Min-Hash signature. Sets that were similar before sparsification remain similar after, because they share the same hash minima with probability equal to their original similarity.</p>

  <h2>Algorithmic Implementation</h2>

  <h3>Basic Algorithm</h3>

  <div class="formula">
    <pre style="margin: 0;">
function minHashSignature(set, k, hashFunctions) {
  const signature = [];
  for (let i = 0; i < k; i++) {
    let minHash = Infinity;
    for (const element of set) {
      const h = hashFunctions[i](element);
      if (h < minHash) minHash = h;
    }
    signature.push(minHash);
  }
  return signature;
}

function estimateJaccard(sigA, sigB) {
  let matches = 0;
  for (let i = 0; i < sigA.length; i++) {
    if (sigA[i] === sigB[i]) matches++;
  }
  return matches / sigA.length;
}</pre>
  </div>

  <h3>Single-Hash Variant (SPHDC Style)</h3>

  <p>Instead of multiple hash functions, use a single hash and keep k smallest:</p>

  <div class="formula">
    <pre style="margin: 0;">
function minHashSelect(set, k, hashFunc) {
  // Sort by hash value
  const sorted = [...set].sort((a, b) =>
    hashFunc(a) - hashFunc(b)
  );
  // Keep k smallest
  return new Set(sorted.slice(0, k));
}

function jaccardFromSets(setA, setB) {
  const intersection = [...setA].filter(x => setB.has(x));
  const union = new Set([...setA, ...setB]);
  return intersection.length / union.size;
}</pre>
  </div>

  <h2>Locality-Sensitive Hashing (LSH)</h2>

  <p>Min-Hash is a form of <strong>Locality-Sensitive Hashing</strong>: similar items hash to the same bucket with high probability.</p>

  <div class="formula">
    <strong>LSH Property:</strong>
    <br>
    If J(A,B) is high → P(same bucket) is high
    <br>
    If J(A,B) is low → P(same bucket) is low
  </div>

  <p>This enables sub-linear nearest neighbor search in large databases.</p>

  <h2>Historical Context</h2>

  <p>Min-Hash was developed by <strong>Andrei Broder</strong> in 1997 at Digital Equipment Corporation (DEC) for the AltaVista search engine.</p>

  <p>Original application: detecting near-duplicate web pages by comparing shingle sets (contiguous word sequences).</p>

  <h2>Trade-offs</h2>

  <h3>Advantages</h3>
  <ul>
    <li><strong>Memory efficient:</strong> Store only k values per set</li>
    <li><strong>Fast comparison:</strong> O(k) instead of O(|A| + |B|)</li>
    <li><strong>Unbiased estimation:</strong> Expected value equals true Jaccard</li>
    <li><strong>Streaming compatible:</strong> Can update incrementally</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li><strong>Statistical variance:</strong> Low k means high estimation error</li>
    <li><strong>Information loss:</strong> Cannot recover full set from signature</li>
    <li><strong>Hash quality dependent:</strong> Requires good hash functions</li>
  </ul>

  <h2>Relationship to Other Techniques</h2>

  <table>
    <tr>
      <th>Technique</th>
      <th>Similarity Metric</th>
      <th>Use Case</th>
    </tr>
    <tr>
      <td><strong>Min-Hash</strong></td>
      <td>Jaccard</td>
      <td>Set similarity</td>
    </tr>
    <tr>
      <td>SimHash</td>
      <td>Cosine</td>
      <td>Document vectors</td>
    </tr>
    <tr>
      <td>Random Projection</td>
      <td>Angular distance</td>
      <td>High-dimensional vectors</td>
    </tr>
    <tr>
      <td>Bloom Filter</td>
      <td>Set membership</td>
      <td>Fast membership test</td>
    </tr>
  </table>

  <h2>Further Reading</h2>

  <ul>
    <li><a href="jaccard.html">Jaccard Similarity</a> - The metric Min-Hash estimates</li>
    <li><a href="../strategies/sphdc-analysis.html">SPHDC Strategy</a> - Uses Min-Hash for sparsification</li>
    <li>Broder (1997). "On the resemblance and containment of documents"</li>
    <li>Leskovec et al. "Mining of Massive Datasets" - Chapter 3</li>
    <li>Wikipedia: <a href="https://en.wikipedia.org/wiki/MinHash">MinHash</a></li>
  </ul>

  <div class="footer-nav">
    <p>
      <a href="index.html">&larr; All Concepts</a> &middot;
      <a href="../index.html">Theory Overview</a>
    </p>
  </div>
  </div>
</body>
</html>
