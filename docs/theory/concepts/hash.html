<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hash Functions in HDC - AGISystem2</title>
  <link rel="stylesheet" href="../../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Hash Functions in HDC</h1>
    <small>
      <a href="../../index.html">Home</a> &middot;
      <a href="../index.html">Theory</a> &middot;
      <a href="index.html">Concepts</a>
    </small>
    <small>Deterministic vector generation from names</small>
  </div>

  <div class="section-intro">
    <p>AGISystem2 uses hash functions to generate <strong>deterministic concept vectors</strong> from string names. This ensures the same concept name always produces the same vector, enabling reproducibility and distributed computation.</p>
  </div>

  <h2>Why Hash Functions?</h2>

  <p>In HDC, each concept needs a unique high-dimensional representation. Rather than storing explicit mappings (concept &rarr; vector), we <strong>derive</strong> vectors from names using hash functions:</p>

  <ul>
    <li><strong>Determinism:</strong> "Dog" always produces the same vector</li>
    <li><strong>No storage overhead:</strong> Vectors are computed on-demand</li>
    <li><strong>Distributed consistency:</strong> Different machines compute identical vectors</li>
    <li><strong>Collision resistance:</strong> Different names produce different vectors</li>
  </ul>

  <h2>The DJB2 Hash Function</h2>

  <p>AGISystem2 uses <strong>DJB2</strong> (Daniel J. Bernstein hash 2) as the primary hash function for generating seeds. DJB2 is chosen for its simplicity, speed, and good distribution properties.</p>

  <h3>Algorithm</h3>

  <pre><code>function djb2(str) {
    let hash = 5381;
    for (let i = 0; i &lt; str.length; i++) {
        hash = ((hash &lt;&lt; 5) + hash) + str.charCodeAt(i);
        // Equivalent to: hash = hash * 33 + char
    }
    return hash >>> 0;  // Convert to unsigned 32-bit
}</code></pre>

  <h3>Properties</h3>

  <table>
    <tr>
      <th>Property</th>
      <th>Value</th>
    </tr>
    <tr>
      <td>Output size</td>
      <td>32 bits (unsigned integer)</td>
    </tr>
    <tr>
      <td>Initial value</td>
      <td>5381 (magic constant)</td>
    </tr>
    <tr>
      <td>Multiplier</td>
      <td>33 (via shift-and-add)</td>
    </tr>
    <tr>
      <td>Collision resistance</td>
      <td>Good for typical concept names</td>
    </tr>
    <tr>
      <td>Speed</td>
      <td>Very fast (simple arithmetic)</td>
    </tr>
  </table>

  <h2>From Hash to Vector</h2>

  <p>The hash value serves as a <strong>seed</strong> for a pseudo-random number generator (PRNG), which then generates the full vector:</p>

  <pre><code>// Concept name &rarr; Hash seed &rarr; PRNG &rarr; Vector

"Dog" &rarr; DJB2("Dog") = 0x7b8c3d2e
      &rarr; PRNG(seed=0x7b8c3d2e)
      &rarr; [random bits or exponents]</code></pre>

  <h3>For Dense-Binary HDC</h3>

  <p>The PRNG generates n random bits (typically 2048), with approximately 50% ones and 50% zeros:</p>

  <pre><code>seed = DJB2("Dog")
prng = new PRNG(seed)
vector = new Uint32Array(64)  // 64 * 32 = 2048 bits
for (i = 0; i &lt; 64; i++) {
    vector[i] = prng.next()
}</code></pre>

  <h3>For SPHDC</h3>

  <p>The PRNG generates k unique 64-bit integers (exponents):</p>

  <pre><code>seed = DJB2("Dog")
prng = new PRNG(seed)
exponents = new Set()
while (exponents.size &lt; k) {
    exponents.add(prng.next64())  // 64-bit value
}
vector = Array.from(exponents)</code></pre>

  <h2>The PRNG: Mulberry32</h2>

  <p>AGISystem2 uses <strong>Mulberry32</strong>, a fast 32-bit PRNG with good statistical properties:</p>

  <pre><code>function mulberry32(seed) {
    return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0);
    };
}</code></pre>

  <p>For 64-bit values (SPHDC), two 32-bit outputs are combined:</p>

  <pre><code>function next64(prng) {
    const high = prng();
    const low = prng();
    return BigInt(high) &lt;&lt; 32n | BigInt(low);
}</code></pre>

  <h2>Why Not Cryptographic Hashes?</h2>

  <p>Cryptographic hash functions (SHA-256, etc.) are not used because:</p>

  <ul>
    <li><strong>Speed:</strong> Crypto hashes are slower than DJB2</li>
    <li><strong>Overkill:</strong> We need distribution, not security</li>
    <li><strong>Sufficient quality:</strong> DJB2 provides adequate collision resistance for concept names</li>
  </ul>

  <p>However, for applications requiring privacy-preserving properties, cryptographic hashes could be used. See <a href="../privacy-hdc.html">Privacy-Preserving HDC</a> for analysis.</p>

  <h2>Collision Handling</h2>

  <p>Hash collisions (different names producing the same hash) are extremely rare with 32-bit hashes for typical vocabulary sizes:</p>

  <table>
    <tr>
      <th>Vocabulary Size</th>
      <th>Collision Probability</th>
    </tr>
    <tr>
      <td>1,000 concepts</td>
      <td>&lt; 0.01%</td>
    </tr>
    <tr>
      <td>10,000 concepts</td>
      <td>&lt; 1%</td>
    </tr>
    <tr>
      <td>100,000 concepts</td>
      <td>~11% (birthday paradox)</td>
    </tr>
  </table>

  <p>For very large vocabularies, the system could use 64-bit hashes or content-addressable naming schemes.</p>

  <h2>Related Pages</h2>

  <ul>
    <li><a href="index.html">All Theoretical Concepts</a></li>
    <li><a href="../strategies/dense-binary.html">Dense-Binary Strategy</a> &mdash; uses hash for vector generation</li>
    <li><a href="../strategies/sparse-polynomial.html">SPHDC Strategy</a> &mdash; uses hash for exponent generation</li>
    <li><a href="../privacy-hdc.html">Privacy-Preserving HDC</a> &mdash; hash function security considerations</li>
  </ul>

  <div class="footer-nav">
    <p>
      <a href="index.html">&larr; Concepts Index</a>
    </p>
  </div>
  </div>
</body>
</html>
