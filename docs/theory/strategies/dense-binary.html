<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dense-Binary HDC - Theory - AGISystem2</title>
  <link rel="stylesheet" href="../../reference/style.css">
  <style>
    .diagram-container { margin: 20px 0; }
    .concept-box {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      border-left: 4px solid #1976d2;
      padding: 20px;
      margin: 20px 0;
      border-radius: 0 8px 8px 0;
    }
    .concept-box h4 { margin-top: 0; color: #1565c0; }
    .math-block {
      background: #263238;
      color: #90caf9;
      padding: 20px;
      border-radius: 8px;
      font-family: monospace;
      overflow-x: auto;
      margin: 15px 0;
    }
    .definition {
      background: #fff3e0;
      border: 1px solid #ffb74d;
      padding: 15px 20px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .definition strong { color: #e65100; }
    .example-box {
      background: #e8f5e9;
      border: 1px solid #81c784;
      padding: 15px 20px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .intuition {
      background: #fce4ec;
      border-left: 4px solid #e91e63;
      padding: 15px 20px;
      margin: 15px 0;
      border-radius: 0 8px 8px 0;
    }
    .intuition em { color: #c2185b; font-style: normal; font-weight: bold; }
    .bit-visual {
      font-family: monospace;
      font-size: 14px;
      letter-spacing: 2px;
    }
    .bit-1 { background: #1976d2; color: white; padding: 2px 4px; border-radius: 2px; }
    .bit-0 { background: #e3f2fd; color: #1565c0; padding: 2px 4px; border-radius: 2px; }
  </style>
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Dense-Binary HDC</h1>
    <small>
      <a href="../../index.html">Home</a> &middot;
      <a href="../index.html">Theory</a> &middot;
      <a href="dense-binary.html"><strong>Dense-Binary</strong></a> &middot;
      <a href="sparse-polynomial.html">SPHDC</a>
    </small>
    <small>Conceptual Foundation: Classic Hyperdimensional Computing</small>
  </div>

  <div class="section-intro">
    <p>Dense-Binary HDC represents concepts as <strong>fixed-length binary vectors</strong> where approximately half the bits are 1 and half are 0. This is the classic approach to Hyperdimensional Computing, providing robust distributed representations.</p>
  </div>

  <h2>1. The Core Idea: Binary Patterns as Representations</h2>

  <div class="concept-box">
    <h4>Fundamental Insight</h4>
    <p>In Dense-Binary HDC, a <strong>concept</strong> is a long binary string. The key insight is that in high-dimensional spaces (thousands of bits), randomly generated binary vectors are almost orthogonal - they share approximately 50% of bits with any other random vector, which is the mathematical "neutral" point.</p>
  </div>

  <div class="definition">
    <strong>Definition: Binary Hypervector</strong>
    <p>A binary hypervector V is a fixed-length sequence of bits:</p>
    <p style="text-align: center; font-family: monospace; font-size: 14px;">
      V = [b<sub>0</sub>, b<sub>1</sub>, ..., b<sub>n-1</sub>] where b<sub>i</sub> &isin; {0, 1}
    </p>
    <p>Typical dimensions: n = 2048 bits (256 bytes) or n = 32768 bits (4KB).</p>
  </div>

  <h3>Why Binary?</h3>

  <div class="intuition">
    <em>Intuition:</em> Binary vectors are the simplest possible representation. Each bit is a yes/no answer to an abstract question about the concept. With thousands of such questions, concepts become uniquely identifiable patterns.
  </div>

  <div class="diagram-container">
    <svg viewBox="0 0 800 180" xmlns="http://www.w3.org/2000/svg" style="width: 100%; max-width: 800px;">
      <!-- Title -->
      <text x="400" y="25" text-anchor="middle" font-weight="bold" font-size="14" fill="#1976d2">Binary Hypervector Structure (2048 bits)</text>

      <!-- Main vector bar -->
      <rect x="50" y="40" width="700" height="50" rx="5" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>

      <!-- Bit cells visualization -->
      <g font-family="monospace" font-size="12">
        <rect x="60" y="50" width="25" height="30" fill="#1976d2"/>
        <text x="72" y="70" text-anchor="middle" fill="white">1</text>

        <rect x="85" y="50" width="25" height="30" fill="#e3f2fd" stroke="#1976d2"/>
        <text x="97" y="70" text-anchor="middle" fill="#1565c0">0</text>

        <rect x="110" y="50" width="25" height="30" fill="#1976d2"/>
        <text x="122" y="70" text-anchor="middle" fill="white">1</text>

        <rect x="135" y="50" width="25" height="30" fill="#1976d2"/>
        <text x="147" y="70" text-anchor="middle" fill="white">1</text>

        <rect x="160" y="50" width="25" height="30" fill="#e3f2fd" stroke="#1976d2"/>
        <text x="172" y="70" text-anchor="middle" fill="#1565c0">0</text>

        <rect x="185" y="50" width="25" height="30" fill="#e3f2fd" stroke="#1976d2"/>
        <text x="197" y="70" text-anchor="middle" fill="#1565c0">0</text>

        <rect x="210" y="50" width="25" height="30" fill="#1976d2"/>
        <text x="222" y="70" text-anchor="middle" fill="white">1</text>

        <rect x="235" y="50" width="25" height="30" fill="#e3f2fd" stroke="#1976d2"/>
        <text x="247" y="70" text-anchor="middle" fill="#1565c0">0</text>

        <text x="280" y="70" fill="#666" font-size="16">. . .</text>

        <rect x="680" y="50" width="25" height="30" fill="#1976d2"/>
        <text x="692" y="70" text-anchor="middle" fill="white">1</text>

        <rect x="705" y="50" width="25" height="30" fill="#e3f2fd" stroke="#1976d2"/>
        <text x="717" y="70" text-anchor="middle" fill="#1565c0">0</text>
      </g>

      <!-- Labels -->
      <text x="75" y="105" text-anchor="middle" font-size="9" fill="#666">bit 0</text>
      <text x="700" y="105" text-anchor="middle" font-size="9" fill="#666">bit 2047</text>

      <!-- Memory layout -->
      <rect x="50" y="120" width="700" height="45" rx="5" fill="#f5f5f5" stroke="#ddd"/>
      <text x="400" y="140" text-anchor="middle" font-weight="bold" font-size="11">Storage: 64 &times; 32-bit words = 2048 bits = 256 bytes</text>
      <text x="400" y="155" text-anchor="middle" font-size="10" fill="#666">Operations use native 32-bit bitwise instructions (fast!)</text>
    </svg>
  </div>

  <h2>2. The Quasi-Orthogonality Principle</h2>

  <p>The power of high-dimensional binary spaces comes from a remarkable statistical property.</p>

  <div class="definition">
    <strong>Theorem: Quasi-Orthogonality</strong>
    <p>In a binary space of n dimensions, two randomly generated vectors share approximately n/2 bits:</p>
    <ul>
      <li>Expected match: 50%</li>
      <li>Standard deviation: O(1/&radic;n)</li>
      <li>For n=2048: 99.9% of random pairs have 48-52% match</li>
    </ul>
  </div>

  <div class="concept-box">
    <h4>Why This Matters</h4>
    <p>Because random vectors are "equidistant" from each other (all at ~50% similarity), the space can accommodate an essentially unlimited number of distinct concepts. Each new random vector is guaranteed to be "far enough" from all existing vectors.</p>
  </div>

  <div class="diagram-container">
    <svg viewBox="0 0 700 200" xmlns="http://www.w3.org/2000/svg" style="width: 100%; max-width: 700px;">
      <!-- Title -->
      <text x="350" y="25" text-anchor="middle" font-weight="bold" font-size="12" fill="#1976d2">Similarity Distribution in High Dimensions</text>

      <!-- Axes -->
      <line x1="80" y1="150" x2="620" y2="150" stroke="#333" stroke-width="2"/>
      <line x1="80" y1="150" x2="80" y2="50" stroke="#333" stroke-width="2"/>

      <!-- Bell curve -->
      <path d="M100 148 Q200 148 250 130 Q300 80 350 50 Q400 80 450 130 Q500 148 600 148" fill="#e3f2fd" stroke="#1976d2" stroke-width="3"/>

      <!-- Labels -->
      <text x="80" y="170" font-size="10" fill="#666">0.0</text>
      <text x="230" y="170" font-size="10" fill="#666">0.25</text>
      <text x="350" y="170" font-size="10" fill="#c62828" font-weight="bold">0.5</text>
      <text x="470" y="170" font-size="10" fill="#666">0.75</text>
      <text x="600" y="170" font-size="10" fill="#666">1.0</text>
      <text x="350" y="185" text-anchor="middle" font-size="11" fill="#333">Similarity</text>

      <!-- Mean marker -->
      <line x1="350" y1="50" x2="350" y2="150" stroke="#c62828" stroke-width="2" stroke-dasharray="5,5"/>
      <text x="370" y="65" font-size="10" fill="#c62828">mean = 0.5</text>

      <!-- Interpretation zones -->
      <text x="150" y="135" font-size="9" fill="#c62828">Inverse</text>
      <text x="540" y="135" font-size="9" fill="#2e7d32">Related</text>

      <!-- Y-axis label -->
      <text x="70" y="100" text-anchor="middle" font-size="10" fill="#666" transform="rotate(-90,70,100)">Frequency</text>
    </svg>
  </div>

  <h2>3. Binding: XOR Operation</h2>

  <p>Binding creates associations between concepts by combining their bit patterns using bitwise XOR.</p>

  <div class="definition">
    <strong>Definition: XOR Binding</strong>
    <p>Given vectors A and B, their binding A &oplus; B is computed bit-by-bit:</p>
    <p style="text-align: center; font-family: monospace; font-size: 14px;">
      (A &oplus; B)<sub>i</sub> = A<sub>i</sub> XOR B<sub>i</sub>
    </p>
    <p>XOR produces 1 when bits differ, 0 when they match.</p>
  </div>

  <div class="diagram-container">
    <svg viewBox="0 0 750 220" xmlns="http://www.w3.org/2000/svg" style="width: 100%; max-width: 750px;">
      <!-- Vector A -->
      <rect x="50" y="30" width="280" height="45" rx="5" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
      <text x="80" y="48" font-size="10" fill="#1565c0" font-weight="bold">A:</text>
      <g font-family="monospace" font-size="14">
        <text x="100" y="62" fill="#1565c0">1</text>
        <text x="120" y="62" fill="#1565c0">0</text>
        <text x="140" y="62" fill="#1565c0">1</text>
        <text x="160" y="62" fill="#1565c0">1</text>
        <text x="180" y="62" fill="#1565c0">0</text>
        <text x="200" y="62" fill="#1565c0">0</text>
        <text x="220" y="62" fill="#1565c0">1</text>
        <text x="240" y="62" fill="#1565c0">0</text>
        <text x="270" y="62" fill="#666">...</text>
      </g>

      <!-- Vector B -->
      <rect x="50" y="85" width="280" height="45" rx="5" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
      <text x="80" y="103" font-size="10" fill="#2e7d32" font-weight="bold">B:</text>
      <g font-family="monospace" font-size="14">
        <text x="100" y="117" fill="#2e7d32">0</text>
        <text x="120" y="117" fill="#2e7d32">1</text>
        <text x="140" y="117" fill="#2e7d32">1</text>
        <text x="160" y="117" fill="#2e7d32">0</text>
        <text x="180" y="117" fill="#2e7d32">0</text>
        <text x="200" y="117" fill="#2e7d32">1</text>
        <text x="220" y="117" fill="#2e7d32">1</text>
        <text x="240" y="117" fill="#2e7d32">0</text>
        <text x="270" y="117" fill="#666">...</text>
      </g>

      <!-- XOR symbol -->
      <circle cx="400" cy="80" r="30" fill="#fff3e0" stroke="#ff9800" stroke-width="3"/>
      <text x="400" y="75" text-anchor="middle" font-weight="bold" font-size="16" fill="#e65100">XOR</text>
      <text x="400" y="92" text-anchor="middle" font-size="10" fill="#e65100">(&oplus;)</text>

      <!-- Result -->
      <rect x="470" y="57" width="250" height="45" rx="5" fill="#fce4ec" stroke="#e91e63" stroke-width="2"/>
      <text x="490" y="75" font-size="10" fill="#c2185b" font-weight="bold">A&oplus;B:</text>
      <g font-family="monospace" font-size="14">
        <text x="530" y="87" fill="#c2185b">1</text>
        <text x="550" y="87" fill="#c2185b">1</text>
        <text x="570" y="87" fill="#c2185b">0</text>
        <text x="590" y="87" fill="#c2185b">1</text>
        <text x="610" y="87" fill="#c2185b">0</text>
        <text x="630" y="87" fill="#c2185b">1</text>
        <text x="650" y="87" fill="#c2185b">0</text>
        <text x="670" y="87" fill="#c2185b">0</text>
        <text x="700" y="87" fill="#666">...</text>
      </g>

      <!-- Bit-by-bit explanation -->
      <g font-size="9" fill="#666">
        <text x="100" y="145" text-anchor="middle">1&oplus;0</text>
        <text x="120" y="145" text-anchor="middle">0&oplus;1</text>
        <text x="140" y="145" text-anchor="middle">1&oplus;1</text>
        <text x="160" y="145" text-anchor="middle">1&oplus;0</text>
        <text x="100" y="160" text-anchor="middle">=1</text>
        <text x="120" y="160" text-anchor="middle">=1</text>
        <text x="140" y="160" text-anchor="middle">=0</text>
        <text x="160" y="160" text-anchor="middle">=1</text>
      </g>

      <!-- Properties box -->
      <rect x="50" y="175" width="670" height="35" rx="5" fill="#f5f5f5" stroke="#ddd"/>
      <text x="360" y="195" text-anchor="middle" font-size="10" fill="#333">
        <tspan font-weight="bold">Properties:</tspan>
        Commutative (A&oplus;B = B&oplus;A) | Self-inverse (A&oplus;A = 0) | Reversible ((A&oplus;B)&oplus;B = A)
      </text>
    </svg>
  </div>

  <h3>Why XOR?</h3>

  <div class="concept-box">
    <h4>The Self-Inverse Property</h4>
    <p>XOR is its own inverse: A &oplus; A = 0 (all zeros). This enables <strong>reversible encoding</strong>:</p>
    <p style="font-family: monospace; text-align: center; font-size: 14px;">
      (A &oplus; B) &oplus; B = A &oplus; (B &oplus; B) = A &oplus; 0 = A
    </p>
    <p>Binding with B, then binding again with B, perfectly recovers A. This is the mathematical foundation for querying knowledge bases.</p>
  </div>

  <h2>4. Bundling: Majority Vote</h2>

  <p>Bundling combines multiple vectors into one by voting on each bit position.</p>

  <div class="definition">
    <strong>Definition: Majority Vote Bundling</strong>
    <p>Given vectors V<sub>1</sub>, V<sub>2</sub>, ..., V<sub>k</sub>, their bundle is computed bit-by-bit:</p>
    <p style="text-align: center; font-family: monospace; font-size: 14px;">
      bundle(V<sub>1</sub>...V<sub>k</sub>)<sub>i</sub> = 1 if majority of V<sub>j,i</sub> are 1, else 0
    </p>
  </div>

  <div class="diagram-container">
    <svg viewBox="0 0 750 280" xmlns="http://www.w3.org/2000/svg" style="width: 100%; max-width: 750px;">
      <!-- Title -->
      <text x="375" y="25" text-anchor="middle" font-weight="bold" font-size="12" fill="#9c27b0">Majority Vote Bundling</text>

      <!-- Input vectors -->
      <rect x="50" y="40" width="250" height="35" rx="4" fill="#e3f2fd" stroke="#1976d2"/>
      <text x="70" y="62" font-size="10" fill="#1565c0" font-weight="bold">A:</text>
      <text x="100" y="62" font-family="monospace" font-size="12" fill="#1565c0">1 0 1 1 0 0 1 0</text>

      <rect x="50" y="80" width="250" height="35" rx="4" fill="#e8f5e9" stroke="#4caf50"/>
      <text x="70" y="102" font-size="10" fill="#2e7d32" font-weight="bold">B:</text>
      <text x="100" y="102" font-family="monospace" font-size="12" fill="#2e7d32">0 1 1 0 0 1 1 0</text>

      <rect x="50" y="120" width="250" height="35" rx="4" fill="#fff3e0" stroke="#ff9800"/>
      <text x="70" y="142" font-size="10" fill="#e65100" font-weight="bold">C:</text>
      <text x="100" y="142" font-family="monospace" font-size="12" fill="#e65100">1 1 1 0 1 0 0 0</text>

      <!-- Majority operation -->
      <circle cx="380" cy="95" r="35" fill="#f3e5f5" stroke="#9c27b0" stroke-width="3"/>
      <text x="380" y="90" text-anchor="middle" font-weight="bold" font-size="12" fill="#7b1fa2">MAJ</text>
      <text x="380" y="105" text-anchor="middle" font-size="9" fill="#7b1fa2">vote</text>

      <!-- Result -->
      <rect x="470" y="77" width="250" height="35" rx="4" fill="#fce4ec" stroke="#e91e63" stroke-width="2"/>
      <text x="490" y="99" font-size="10" fill="#c2185b" font-weight="bold">Result:</text>
      <text x="545" y="99" font-family="monospace" font-size="12" fill="#c2185b">1 1 1 0 0 0 1 0</text>

      <!-- Bit-by-bit breakdown -->
      <rect x="50" y="170" width="670" height="100" rx="5" fill="#f5f5f5" stroke="#ddd"/>
      <text x="385" y="195" text-anchor="middle" font-weight="bold" font-size="11">Bit-by-Bit Voting:</text>

      <g font-size="10">
        <text x="100" y="220" text-anchor="middle" fill="#333">Bit 0:</text>
        <text x="100" y="235" text-anchor="middle" fill="#666">1+0+1=2</text>
        <text x="100" y="250" text-anchor="middle" fill="#2e7d32" font-weight="bold">&rarr; 1</text>

        <text x="200" y="220" text-anchor="middle" fill="#333">Bit 1:</text>
        <text x="200" y="235" text-anchor="middle" fill="#666">0+1+1=2</text>
        <text x="200" y="250" text-anchor="middle" fill="#2e7d32" font-weight="bold">&rarr; 1</text>

        <text x="300" y="220" text-anchor="middle" fill="#333">Bit 2:</text>
        <text x="300" y="235" text-anchor="middle" fill="#666">1+1+1=3</text>
        <text x="300" y="250" text-anchor="middle" fill="#2e7d32" font-weight="bold">&rarr; 1</text>

        <text x="400" y="220" text-anchor="middle" fill="#333">Bit 3:</text>
        <text x="400" y="235" text-anchor="middle" fill="#666">1+0+0=1</text>
        <text x="400" y="250" text-anchor="middle" fill="#c62828" font-weight="bold">&rarr; 0</text>

        <text x="500" y="220" text-anchor="middle" fill="#333">Bit 4:</text>
        <text x="500" y="235" text-anchor="middle" fill="#666">0+0+1=1</text>
        <text x="500" y="250" text-anchor="middle" fill="#c62828" font-weight="bold">&rarr; 0</text>

        <text x="600" y="220" text-anchor="middle" fill="#333">...</text>
      </g>
    </svg>
  </div>

  <div class="intuition">
    <em>Intuition:</em> The bundle is a "consensus" vector. It preserves features that appear in most inputs while filtering out idiosyncratic features. The result is similar to ALL inputs - this is content-addressable memory.
  </div>

  <h3>Bundle Capacity</h3>

  <p>As more vectors are bundled, similarity to each original decreases.</p>

  <table>
    <tr>
      <th>Vectors Bundled</th>
      <th>Expected Similarity to Each</th>
      <th>Quality</th>
    </tr>
    <tr>
      <td>3</td>
      <td>~0.67</td>
      <td>Excellent</td>
    </tr>
    <tr>
      <td>10</td>
      <td>~0.60</td>
      <td>Good</td>
    </tr>
    <tr>
      <td>50</td>
      <td>~0.54</td>
      <td>Usable</td>
    </tr>
    <tr>
      <td>100</td>
      <td>~0.52</td>
      <td>Marginal</td>
    </tr>
    <tr>
      <td>200+</td>
      <td>~0.51</td>
      <td>Near noise</td>
    </tr>
  </table>

  <h2>5. Similarity: Hamming Distance</h2>

  <p>Similarity measures how many bits two vectors share.</p>

  <div class="definition">
    <strong>Definition: Normalized Hamming Similarity</strong>
    <p style="text-align: center; font-family: monospace; font-size: 16px;">
      sim(A, B) = 1 - (popcount(A &oplus; B) / n)
    </p>
    <p>Where popcount counts the number of 1-bits (differing positions) and n is the dimension.</p>
  </div>

  <div class="diagram-container">
    <svg viewBox="0 0 700 150" xmlns="http://www.w3.org/2000/svg" style="width: 100%; max-width: 700px;">
      <!-- Similarity scale -->
      <rect x="50" y="30" width="600" height="50" rx="8" fill="url(#simScale)" stroke="#333" stroke-width="2"/>

      <!-- Labels -->
      <text x="50" y="100" text-anchor="middle" font-size="10" fill="#c62828">0.0</text>
      <text x="50" y="115" text-anchor="middle" font-size="9" fill="#666">Inverse</text>

      <text x="225" y="100" text-anchor="middle" font-size="10" fill="#ff9800">0.25</text>
      <text x="225" y="115" text-anchor="middle" font-size="9" fill="#666">Very different</text>

      <text x="350" y="100" text-anchor="middle" font-size="10" fill="#333" font-weight="bold">0.5</text>
      <text x="350" y="115" text-anchor="middle" font-size="9" fill="#666">Random/Unrelated</text>

      <text x="475" y="100" text-anchor="middle" font-size="10" fill="#2e7d32">0.75</text>
      <text x="475" y="115" text-anchor="middle" font-size="9" fill="#666">Related</text>

      <text x="650" y="100" text-anchor="middle" font-size="10" fill="#2e7d32">1.0</text>
      <text x="650" y="115" text-anchor="middle" font-size="9" fill="#666">Identical</text>

      <!-- 0.5 marker -->
      <line x1="350" y1="30" x2="350" y2="80" stroke="#333" stroke-width="3"/>

      <defs>
        <linearGradient id="simScale" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" style="stop-color:#f44336"/>
          <stop offset="25%" style="stop-color:#ff9800"/>
          <stop offset="50%" style="stop-color:#ffeb3b"/>
          <stop offset="75%" style="stop-color:#8bc34a"/>
          <stop offset="100%" style="stop-color:#4caf50"/>
        </linearGradient>
      </defs>
    </svg>
  </div>

  <div class="example-box">
    <strong>Example: Computing Similarity</strong>
    <pre style="margin: 10px 0;">
A = 10110010... (2048 bits)
B = 01100110... (2048 bits)

A &oplus; B = 11010100...  (bits that differ)
popcount(A &oplus; B) = 980  (number of differing bits)

similarity = 1 - (980 / 2048) = 1 - 0.478 = 0.522

Interpretation: Nearly random (close to 0.5)</pre>
  </div>

  <h2>6. Creating Concept Vectors</h2>

  <p>Each concept gets a deterministic binary vector generated from its name.</p>

  <div class="definition">
    <strong>Algorithm: Deterministic Vector Creation</strong>
    <ol>
      <li>Hash the concept name to get a seed: <code>seed = <a href="../concepts/hash.html">DJB2</a>("Dog")</code></li>
      <li>Initialize a PRNG with the seed</li>
      <li>Generate n random bits (50% ones, 50% zeros)</li>
    </ol>
    <p><a href="../concepts/hash.html">Read more about hash functions in HDC &rarr;</a></p>
  </div>

  <div class="concept-box">
    <h4>Why Deterministic?</h4>
    <p>The same name always produces the same vector. This enables:</p>
    <ul>
      <li>Reproducible computations across sessions</li>
      <li>No need to store explicit concept-vector mappings</li>
      <li>Distributed systems with shared vocabulary</li>
    </ul>
  </div>

  <h2>7. Encoding Relations</h2>

  <p>Structured knowledge is encoded by binding concepts with position vectors.</p>

  <div class="definition">
    <strong>Relation Encoding Formula</strong>
    <p style="font-family: monospace; text-align: center; font-size: 13px;">
      fact(loves, John, Mary) = Loves &oplus; (Pos1 &oplus; John) &oplus; (Pos2 &oplus; Mary)
    </p>
    <p>Position vectors (Pos1, Pos2, ...) distinguish argument positions.</p>
  </div>

  <div class="diagram-container">
    <svg viewBox="0 0 800 180" xmlns="http://www.w3.org/2000/svg" style="width: 100%; max-width: 800px;">
      <!-- Components -->
      <rect x="50" y="50" width="90" height="45" rx="5" fill="#9c27b0"/>
      <text x="95" y="78" text-anchor="middle" fill="white" font-size="10">Loves</text>

      <text x="155" y="78" text-anchor="middle" font-size="16" fill="#333">&oplus;</text>

      <rect x="170" y="50" width="140" height="45" rx="5" fill="#1976d2"/>
      <text x="240" y="73" text-anchor="middle" fill="white" font-size="9">(Pos1 &oplus; John)</text>

      <text x="325" y="78" text-anchor="middle" font-size="16" fill="#333">&oplus;</text>

      <rect x="340" y="50" width="140" height="45" rx="5" fill="#4caf50"/>
      <text x="410" y="73" text-anchor="middle" fill="white" font-size="9">(Pos2 &oplus; Mary)</text>

      <text x="495" y="78" text-anchor="middle" font-size="16" fill="#333">=</text>

      <rect x="510" y="40" width="240" height="65" rx="5" fill="#e91e63"/>
      <text x="630" y="68" text-anchor="middle" fill="white" font-size="10" font-weight="bold">Fact Vector</text>
      <text x="630" y="85" text-anchor="middle" fill="white" font-size="9">[2048-bit encoding of</text>
      <text x="630" y="98" text-anchor="middle" fill="white" font-size="9">"loves(John, Mary)"]</text>

      <!-- Explanation -->
      <rect x="50" y="115" width="700" height="50" rx="5" fill="#f5f5f5" stroke="#ddd"/>
      <text x="400" y="135" text-anchor="middle" font-weight="bold" font-size="11">Position Vectors Preserve Order</text>
      <text x="400" y="152" text-anchor="middle" font-size="10" fill="#666">loves(John, Mary) &ne; loves(Mary, John) because Pos1 &ne; Pos2</text>
    </svg>
  </div>

  <h2>8. Querying: The Unbind Operation</h2>

  <p>Since XOR is self-inverse, queries "subtract" known parts to find unknowns.</p>

  <div class="definition">
    <strong>Query Principle</strong>
    <p>To find ?who in "loves(?who, Mary)", unbind the known parts:</p>
    <p style="font-family: monospace; text-align: center;">
      candidate = KB &oplus; Loves &oplus; (Pos2 &oplus; Mary)
    </p>
    <p>Then extract the answer by unbinding Pos1 and matching against vocabulary.</p>
  </div>

  <div class="example-box">
    <strong>Example: Query Resolution</strong>
    <pre style="margin: 10px 0;">
# KB contains: loves(John, Mary) encoded as fact_vector

# Query: Who loves Mary?  (loves(?who, Mary))
partial = Loves &oplus; (Pos2 &oplus; Mary)

# Unbind from KB (XOR is reversible!)
candidate = KB &oplus; partial
         = fact_vector &oplus; Loves &oplus; (Pos2 &oplus; Mary)
         = (Pos1 &oplus; John)

# Extract answer
raw_answer = candidate &oplus; Pos1 = John

# Match against vocabulary
similarity(raw_answer, "John") &asymp; 1.0  &rarr; Answer: John</pre>
  </div>

  <h2>9. Mathematical Properties</h2>

  <div class="concept-box">
    <h4>Key Properties of Dense-Binary HDC</h4>
    <ul>
      <li><strong>Perfect Self-Inverse:</strong> (A &oplus; B) &oplus; B = A exactly</li>
      <li><strong>Commutativity:</strong> A &oplus; B = B &oplus; A</li>
      <li><strong>Associativity:</strong> (A &oplus; B) &oplus; C = A &oplus; (B &oplus; C)</li>
      <li><strong>Determinism:</strong> Same inputs always produce same outputs</li>
      <li><strong>Fixed Memory:</strong> All vectors have exactly n bits</li>
      <li><strong>Graceful Degradation:</strong> Bundle capacity decreases smoothly</li>
    </ul>
  </div>

  <div class="footer-nav">
    <p>
      <a href="../index.html">&larr; Back to Theory</a> &middot;
      <a href="sparse-polynomial.html">SPHDC Strategy &rarr;</a>
    </p>
  </div>
  </div>
</body>
</html>
