<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>DS01 - Theoretical Foundation - AGISystem2</title>
  <link rel="stylesheet" href="../../reference/style.css">
  <style>
    .math-box {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
      font-family: monospace;
      border-left: 4px solid #1976d2;
    }
    .property-table {
      width: 100%;
      margin: 15px 0;
    }
    .property-table th, .property-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    .property-table th {
      background-color: #f8f9fa;
    }
  </style>
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>DS01 - Theoretical Foundation</h1>
    <small>
      <a href="../../index.html">Home</a> &middot;
      <a href="../../architecture/index.html">Architecture</a> &middot;
      <a href="../../theory/index.html">Theory</a> &middot;
      <a href="../../syntax/index.html">Syntax</a> &middot;
      <a href="../../api/index.html">APIs</a> &middot;
      <a href="../../wiki/index.html">Wiki</a> &middot;
      <a href="../matrix.html">Specs</a>
    </small>
    <small>Hyperdimensional Computing for neuro-symbolic AI</small>
  </div>

  <div class="section-intro">
    <p>AGISystem2 is built on <strong>Hyperdimensional Computing (HDC)</strong>, a computational paradigm that represents information as high-dimensional binary vectors. This foundation enables deterministic, explainable reasoning with mathematical guarantees.</p>
  </div>

  <h2>Why Hyperdimensional Computing?</h2>

  <div class="diagram-container">
    <div class="diagram-title">HDC Bridges Symbolic AI and Neural Networks</div>
    <svg viewBox="0 0 800 200" xmlns="http://www.w3.org/2000/svg">
      <!-- Symbolic AI -->
      <rect x="50" y="30" width="200" height="100" rx="10" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
      <text x="150" y="55" text-anchor="middle" font-weight="bold" font-size="12" fill="#1976d2">Symbolic AI</text>
      <text x="150" y="75" text-anchor="middle" font-size="10" fill="#333">✓ Compositionality</text>
      <text x="150" y="90" text-anchor="middle" font-size="10" fill="#333">✓ Reasoning</text>
      <text x="150" y="105" text-anchor="middle" font-size="10" fill="#333">✗ Brittle</text>
      <text x="150" y="120" text-anchor="middle" font-size="10" fill="#333">✗ No graceful degradation</text>

      <!-- Neural Networks -->
      <rect x="550" y="30" width="200" height="100" rx="10" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
      <text x="650" y="55" text-anchor="middle" font-weight="bold" font-size="12" fill="#4caf50">Neural Networks</text>
      <text x="650" y="75" text-anchor="middle" font-size="10" fill="#333">✓ Noise tolerance</text>
      <text x="650" y="90" text-anchor="middle" font-size="10" fill="#333">✓ Learning</text>
      <text x="650" y="105" text-anchor="middle" font-size="10" fill="#333">✗ Black box</text>
      <text x="650" y="120" text-anchor="middle" font-size="10" fill="#333">✗ No structure</text>

      <!-- HDC in middle -->
      <rect x="300" y="60" width="200" height="40" rx="10" fill="#fce4ec" stroke="#e91e63" stroke-width="3"/>
      <text x="400" y="85" text-anchor="middle" font-weight="bold" font-size="14" fill="#c2185b">HDC</text>
      <text x="400" y="100" text-anchor="middle" font-size="10" fill="#333">Both: compositional AND robust</text>

      <!-- Arrows -->
      <path d="M250 80 L295 80" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
      <path d="M500 80 L545 80" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>

      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
        </marker>
      </defs>
    </svg>
  </div>

  <h2>Key Insight: Quasi-Orthogonality</h2>

  <p>In high dimensions (16K-64K bits), random vectors are <strong>nearly perpendicular</strong>:</p>

  <div class="math-box">
    At d=32,768 bits:
    - Two random vectors share ~50% ± 0.3% bits
    - Similarity of random vectors: 0.500 ± 0.003
    - Probability of similarity > 0.55: < 0.0001%
  </div>

  <p><strong>Implication:</strong> Random vectors can serve as unique symbols that don't interfere with each other.</p>

  <h2>The Two Fundamental Operations</h2>

  <h3>1. BIND (XOR) - Association</h3>

  <div class="diagram-container">
    <div class="diagram-title">Bind Operation: C = A ⊕ B (bitwise XOR)</div>
    <svg viewBox="0 0 600 150" xmlns="http://www.w3.org/2000/svg">
      <!-- Vector A -->
      <rect x="50" y="20" width="200" height="30" rx="3" fill="#e3f2fd" stroke="#1976d2"/>
      <text x="150" y="40" text-anchor="middle" font-size="11">A: 1 0 1 1 0 0 1 0 ...</text>

      <!-- Vector B -->
      <rect x="50" y="60" width="200" height="30" rx="3" fill="#e8f5e9" stroke="#4caf50"/>
      <text x="150" y="80" text-anchor="middle" font-size="11">B: 0 1 1 0 0 1 1 0 ...</text>

      <!-- XOR symbol -->
      <circle cx="300" cy="55" r="20" fill="#fff3e0" stroke="#ff9800" stroke-width="2"/>
      <text x="300" y="60" text-anchor="middle" font-size="14" font-weight="bold">XOR</text>

      <!-- Result -->
      <rect x="350" y="40" width="200" height="30" rx="3" fill="#fce4ec" stroke="#e91e63"/>
      <text x="450" y="60" text-anchor="middle" font-size="11">A⊕B: 1 1 0 1 0 1 0 0 ...</text>

      <!-- Properties -->
      <text x="50" y="120" font-size="10" fill="#666">Properties: Commutative, Associative, Self-inverse (A⊕A=0), Reversible ((A⊕B)⊕B=A)</text>
    </svg>
  </div>

  <div class="math-box">
    Bind properties:
    - Associative: (A ⊕ B) ⊕ C = A ⊕ (B ⊕ C)
    - Commutative: A ⊕ B = B ⊕ A
    - Self-inverse: A ⊕ A = 0
    - Reversible: (A ⊕ B) ⊕ B = A
    - Preserves extension: [v|v] ⊕ [u|u] = [v⊕u | v⊕u]
  </div>

  <h3>2. BUNDLE (Majority Vote) - Superposition</h3>

  <div class="diagram-container">
    <div class="diagram-title">Bundle Operation: C = Majority([A, B, D, ...])</div>
    <svg viewBox="0 0 600 180" xmlns="http://www.w3.org/2000/svg">
      <!-- Vectors -->
      <rect x="50" y="20" width="180" height="25" rx="3" fill="#e3f2fd" stroke="#1976d2"/>
      <text x="140" y="37" text-anchor="middle" font-size="10">A: 1 0 1 1 0 0 1 0</text>

      <rect x="50" y="50" width="180" height="25" rx="3" fill="#e8f5e9" stroke="#4caf50"/>
      <text x="140" y="67" text-anchor="middle" font-size="10">B: 0 1 1 0 0 1 1 0</text>

      <rect x="50" y="80" width="180" height="25" rx="3" fill="#fff3e0" stroke="#ff9800"/>
      <text x="140" y="97" text-anchor="middle" font-size="10">C: 1 1 1 0 1 0 0 0</text>

      <!-- Majority symbol -->
      <circle cx="300" cy="67" r="25" fill="#f3e5f5" stroke="#9c27b0" stroke-width="2"/>
      <text x="300" y="62" text-anchor="middle" font-size="10">MAJ</text>
      <text x="300" y="75" text-anchor="middle" font-size="10">vote</text>

      <!-- Result -->
      <rect x="360" y="55" width="190" height="25" rx="3" fill="#fce4ec" stroke="#e91e63"/>
      <text x="455" y="72" text-anchor="middle" font-size="10">Result: 1 1 1 0 0 0 1 0</text>

      <!-- Explanation -->
      <text x="50" y="130" font-size="10" fill="#666">Each bit: majority wins (2/3 or more)</text>
      <text x="50" y="145" font-size="10" fill="#666">Bit 0: A=1, B=0, C=1 → majority=1</text>
      <text x="50" y="160" font-size="10" fill="#666">Result is similar to ALL inputs (sim > 0.5)</text>
    </svg>
  </div>

  <div class="math-box">
    Bundle properties:
    - Preserves similarity: C is similar to all inputs
    - Capacity limited: ~100-200 items before saturation
    - Non-reversible: Cannot extract individual items
    - Preserves extension: Works with cloned vectors
  </div>

  <h2>Why NOT Permutation?</h2>

  <div class="alert alert-warning">
    <strong>Permutation breaks geometry extension:</strong>
    <p>When extending a 16K vector to 32K by cloning, permutation produces different results than permuting then extending. Position vectors (XOR-based) extend correctly because XOR distributes over cloning.</p>
  </div>

  <div class="diagram-container">
    <div class="diagram-title">Permutation Problem with Vector Extension</div>
    <svg viewBox="0 0 800 200" xmlns="http://www.w3.org/2000/svg">
      <!-- Original -->
      <rect x="50" y="30" width="200" height="40" rx="5" fill="#e3f2fd" stroke="#1976d2"/>
      <text x="150" y="55" text-anchor="middle" font-size="11">Original 8-bit: [A B C D E F G H]</text>

      <!-- Cloned -->
      <rect x="50" y="80" width="300" height="40" rx="5" fill="#e8f5e9" stroke="#4caf50"/>
      <text x="200" y="105" text-anchor="middle" font-size="11">Cloned to 16: [A B C D E F G H | A B C D E F G H]</text>

      <!-- Permute wrong -->
      <rect x="400" y="80" width="350" height="40" rx="5" fill="#ffebee" stroke="#f44336"/>
      <text x="575" y="105" text-anchor="middle" font-size="11" fill="#c62828">Permute by 1: [H A B C D E F G | H A B C D E F G]</text>
      <text x="575" y="120" text-anchor="middle" font-size="10" fill="#c62828">Bits cross clone boundary!</text>

      <!-- Arrow -->
      <path d="M350 95 L395 95" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>

      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
        </marker>
      </defs>
    </svg>
  </div>

  <h2>Vector Geometry</h2>

  <h3>Dimensionality Tiers</h3>

  <table class="property-table">
    <tr>
      <th>Tier</th>
      <th>Bits</th>
      <th>Bytes</th>
      <th>Bundle Capacity</th>
      <th>Use Case</th>
    </tr>
    <tr>
      <td>Small</td>
      <td>16,384</td>
      <td>2 KB</td>
      <td>~50-100 items</td>
      <td>Simple domains</td>
    </tr>
    <tr>
      <td>Standard</td>
      <td>32,768</td>
      <td>4 KB</td>
      <td>~100-200 items</td>
      <td>General purpose</td>
    </tr>
    <tr>
      <td>Large</td>
      <td>65,536</td>
      <td>8 KB</td>
      <td>~200-400 items</td>
      <td>Complex domains</td>
    </tr>
  </table>

  <h3>Vector Extension (Cloning)</h3>

  <div class="diagram-container">
    <div class="diagram-title">Vector Extension Mechanism</div>
    <svg viewBox="0 0 800 150" xmlns="http://www.w3.org/2000/svg">
      <!-- Small -->
      <rect x="50" y="30" width="150" height="40" rx="5" fill="#e3f2fd" stroke="#1976d2"/>
      <text x="125" y="55" text-anchor="middle" font-size="11">Small (16K): [v]</text>

      <!-- Extended 32K -->
      <rect x="250" y="30" width="250" height="40" rx="5" fill="#e8f5e9" stroke="#4caf50"/>
      <text x="375" y="55" text-anchor="middle" font-size="11">Extended (32K): [v | v]</text>

      <!-- Extended 64K -->
      <rect x="550" y="30" width="200" height="40" rx="5" fill="#fff3e0" stroke="#ff9800"/>
      <text x="650" y="55" text-anchor="middle" font-size="11">Extended (64K): [v|v|v|v]</text>

      <!-- Arrows -->
      <path d="M200 55 L245 55" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
      <path d="M500 55 L545 55" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>

      <!-- Properties -->
      <text x="400" y="110" text-anchor="middle" font-size="12" fill="#666">XOR preserves pattern: [v|v] ⊕ [u|u] = [v⊕u | v⊕u]</text>
    </svg>
  </div>

  <h2>Position Encoding with Role Vectors</h2>

  <h3>The Problem</h3>
  <p>We need to distinguish: <code>loves(John, Mary) ≠ loves(Mary, John)</code></p>

  <h3>The Solution: Position Vectors</h3>

  <div class="diagram-container">
    <div class="diagram-title">Position Vectors Solve Argument Order</div>
    <svg viewBox="0 0 700 160" xmlns="http://www.w3.org/2000/svg">
      <!-- Without positions (wrong) -->
      <rect x="20" y="20" width="300" height="60" rx="5" fill="#ffebee" stroke="#f44336"/>
      <text x="170" y="40" text-anchor="middle" font-size="11" fill="#c62828">WITHOUT positions:</text>
      <text x="170" y="55" text-anchor="middle" font-size="10" fill="#333">loves(John, Mary) = Loves XOR John XOR Mary</text>
      <text x="170" y="70" text-anchor="middle" font-size="10" fill="#333">loves(Mary, John) = Loves XOR Mary XOR John</text>
      <text x="300" y="100" text-anchor="end" font-size="12" fill="#f44336" font-weight="bold">IDENTICAL! (wrong)</text>

      <!-- With positions (correct) -->
      <rect x="380" y="20" width="300" height="60" rx="5" fill="#e8f5e9" stroke="#4caf50"/>
      <text x="530" y="40" text-anchor="middle" font-size="11" fill="#2e7d32">WITH positions:</text>
      <text x="530" y="55" text-anchor="middle" font-size="10" fill="#333">loves(J,M) = Loves XOR (Pos1 XOR J) XOR (Pos2 XOR M)</text>
      <text x="530" y="70" text-anchor="middle" font-size="10" fill="#333">loves(M,J) = Loves XOR (Pos1 XOR M) XOR (Pos2 XOR J)</text>
      <text x="680" y="100" text-anchor="end" font-size="12" fill="#4caf50" font-weight="bold">DIFFERENT! (correct)</text>

      <!-- Pos vectors list -->
      <text x="350" y="140" text-anchor="middle" font-size="11" fill="#666">Pre-defined: Pos1, Pos2, Pos3, ..., Pos20</text>
    </svg>
  </div>

  <div class="math-box">
    Position vector formula:
    fact = Verb ⊕ (Pos1 ⊕ Arg1) ⊕ (Pos2 ⊕ Arg2) ⊕ (Pos3 ⊕ Arg3)
    
    Recovery (unbinding):
    temp = fact ⊕ Verb ⊕ (Pos2 ⊕ Arg2)
    # temp ≈ Pos1 ⊕ Arg1
    Arg1 = temp ⊕ Pos1
  </div>

  <h2>Deterministic Initialization: ASCII Stamping</h2>

  <div class="diagram-container">
    <div class="diagram-title">ASCII Stamping Algorithm</div>
    <svg viewBox="0 0 800 250" xmlns="http://www.w3.org/2000/svg">
      <!-- Step 1 -->
      <rect x="50" y="30" width="180" height="50" rx="5" fill="#e3f2fd" stroke="#1976d2"/>
      <text x="140" y="50" text-anchor="middle" font-size="11">Step 1: ASCII bytes</text>
      <text x="140" y="65" text-anchor="middle" font-size="10">"John" → [74, 111, 104, 110]</text>

      <!-- Step 2 -->
      <rect x="260" y="30" width="180" height="50" rx="5" fill="#e8f5e9" stroke="#4caf50"/>
      <text x="350" y="50" text-anchor="middle" font-size="11">Step 2: Base stamp</text>
      <text x="350" y="65" text-anchor="middle" font-size="10">Repeat ASCII to 256 bits</text>

      <!-- Step 3 -->
      <rect x="470" y="30" width="180" height="50" rx="5" fill="#fff3e0" stroke="#ff9800"/>
      <text x="560" y="50" text-anchor="middle" font-size="11">Step 3: Add variation</text>
      <text x="560" y="65" text-anchor="middle" font-size="10">XOR with PRNG bits</text>

      <!-- Step 4 -->
      <rect x="680" y="30" width="80" height="50" rx="5" fill="#fce4ec" stroke="#e91e63"/>
      <text x="720" y="50" text-anchor="middle" font-size="11">Vector</text>

      <!-- Arrows -->
      <path d="M230 55 L255 55" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
      <path d="M450 55 L465 55" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
      <path d="M660 55 L675 55" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>

      <!-- Visual example -->
      <rect x="50" y="100" width="700" height="100" rx="5" fill="#f5f5f5" stroke="#ddd"/>
      <text x="100" y="125" text-anchor="start" font-size="11">Name: "John"</text>
      <text x="100" y="145" text-anchor="start" font-size="11">ASCII: [01001010, 01101111, 01101000, 01101110]</text>
      <text x="100" y="165" text-anchor="start" font-size="11">Base pattern: [JohnJohnJohn...]</text>
      <text x="100" y="185" text-anchor="start" font-size="11">Vector: 128 stamps with PRNG variation</text>

      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
        </marker>
      </defs>
    </svg>
  </div>

  <h2>Core Position Vectors</h2>

  <div class="math-box">
    Core predefines position vectors:
    Pos1  = initVector("__Pos1__",  "Core", geometry)
    Pos2  = initVector("__Pos2__",  "Core", geometry)
    Pos3  = initVector("__Pos3__",  "Core", geometry)
    ...
    Pos20 = initVector("__Pos20__", "Core", geometry)
    
    Properties:
    - Deterministic across all systems
    - Quasi-orthogonal to each other
    - Quasi-orthogonal to user vectors
    - Extend correctly via cloning
  </div>

  <h2>Memory Architecture</h2>

  <h3>Hot Memory (RAM)</h3>

  <table class="property-table">
    <tr>
      <th>Aspect</th>
      <th>Specification</th>
    </tr>
    <tr>
      <td>Format</td>
      <td>Dense binary, uint64[] arrays</td>
    </tr>
    <tr>
      <td>Operations</td>
      <td>XOR, popcount: O(geometry/64)</td>
    </tr>
    <tr>
      <td>Storage</td>
      <td>Native geometry per theory</td>
    </tr>
  </table>

  <h3>Cold Storage (Disk)</h3>

  <table class="property-table">
    <tr>
      <th>Aspect</th>
      <th>Specification</th>
    </tr>
    <tr>
      <td>Format</td>
      <td>Sparse indices + Roaring Bitmap</td>
    </tr>
    <tr>
      <td>Threshold</td>
      <td>Top 2% bits retained</td>
    </tr>
    <tr>
      <td>Compression</td>
      <td>~15-20× reduction</td>
    </tr>
  </table>

  <h2>The Complete Binding Formula</h2>

  <h3>Statement Encoding</h3>

  <div class="math-box">
    @dest Op Arg1 Arg2 ... ArgN
    
    Becomes:
    dest = Op ⊕ (Pos1 ⊕ Arg1) ⊕ (Pos2 ⊕ Arg2) ⊕ ... ⊕ (PosN ⊕ ArgN)
  </div>

  <h3>Query Execution</h3>

  <div class="math-box">
    Query: @q Op ?who Arg2 (hole at position 1)
    
    # Build partial (without the hole)
    partial = Op ⊕ (Pos2 ⊕ Arg2)
    
    # Unbind from knowledge base
    result = KB ⊕ partial
    
    # Result contains Pos1 ⊕ who (plus noise from other KB facts)
    # Find nearest match in vocabulary after unbinding Pos1:
    candidate = result ⊕ Pos1
    answer = findMostSimilar(candidate, vocabulary)
  </div>

  <h2>Mathematical Guarantees</h2>

  <ul>
    <li><strong>Closure:</strong> All operations produce valid hypervectors</li>
    <li><strong>Determinism:</strong> Same inputs always produce same outputs</li>
    <li><strong>Approximate reversibility:</strong> Bind is perfectly reversible; Bundle is approximately recoverable via similarity</li>
    <li><strong>Compositionality:</strong> Complex structures built from simple parts</li>
    <li><strong>Graceful degradation:</strong> Accuracy decreases smoothly with capacity</li>
  </ul>

  <h2>Summary</h2>

  <table class="property-table">
    <tr>
      <th>Concept</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><strong>Two operations only</strong></td>
      <td>XOR (bind) and Bundle (superposition)</td>
    </tr>
    <tr>
      <td><strong>No permutation</strong></td>
      <td>Breaks vector extension</td>
    </tr>
    <tr>
      <td><strong>Position vectors</strong></td>
      <td>Pos1, Pos2, ... encode argument order</td>
    </tr>
    <tr>
      <td><strong>Extension</strong></td>
      <td>Clone: [v] → [v|v] → [v|v|v|v]</td>
    </tr>
    <tr>
      <td><strong>ASCII stamping</strong></td>
      <td>Name → ASCII bits → repeated stamp + PRNG variation</td>
    </tr>
    <tr>
      <td><strong>Binding formula</strong></td>
      <td>result = Op ⊕ (Pos1⊕A1) ⊕ (Pos2⊕A2) ⊕ ...</td>
    </tr>
    <tr>
      <td><strong>Query</strong></td>
      <td>Unbind known parts, search vocabulary</td>
    </tr>
  </table>

  <h2>Further Reading</h2>

  <ul>
    <li><a href="../../theory/index.html">Theory Overview</a> - Visual introduction to HDC</li>
    <li><a href="DS09-Core-HDC-Implementation.html">DS09 - Core HDC Implementation</a> - Implementation details</li>
    <li><a href="DS00-Vision.html">DS00 - Vision</a> - Why this matters</li>
  </ul>

  <div class="footer-nav">
    <p>HDC provides the mathematical foundation for deterministic, explainable AI with formal guarantees.</p>
  </div>
  </div>
</body>
</html>