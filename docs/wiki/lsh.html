<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Locality-Sensitive Hashing</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>AGISystem2 – Locality-Sensitive Hashing</h1>
    <small>
      <a href="../index.html">Home</a> ·
      <a href="../guides/conceptual_spaces.html">Theory</a> ·
      <a href="../architecture/index.html">Architecture</a> ·
      <a href="../api/index.html">APIs</a> ·
      <a href="../syntax/index.html">Syntax</a> ·
      <a href="../usage-cli/index.html">CLI</a> ·
      <a href="index.html">Wiki</a> ·
      <a href="../specs/matrix.html">Specs</a>
    </small>
  </div>

  <p>Locality-Sensitive Hashing (LSH) is the retrieval mechanism that makes AGISystem2 fast. Instead of comparing a query against every stored concept, LSH groups similar vectors into buckets. Only concepts in the same bucket need exact comparison, reducing search from O(n) to approximately O(1).</p>

  <div class="diagram">
    <svg viewBox="0 0 560 320" role="img" aria-label="LSH bucket retrieval">
      <defs>
        <marker id="arrow-lsh" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L6,3 L0,6 z" fill="#0f4c81" />
        </marker>
      </defs>

      <!-- Background -->
      <rect x="0" y="0" width="560" height="320" fill="#fafbfc"/>

      <!-- Query vector -->
      <rect x="20" y="130" width="80" height="60" rx="4" fill="#e1ecf7" stroke="#0f4c81" stroke-width="2"/>
      <text x="60" y="155" font-size="10" font-weight="bold" fill="#0f4c81" text-anchor="middle">Query</text>
      <text x="60" y="175" font-size="9" fill="#4a5670" text-anchor="middle">vector</text>

      <!-- Hash function -->
      <rect x="130" y="130" width="80" height="60" rx="4" fill="#fff3e0" stroke="#e65100" stroke-width="2"/>
      <text x="170" y="150" font-size="10" font-weight="bold" fill="#e65100" text-anchor="middle">Hash</text>
      <text x="170" y="165" font-size="9" fill="#4a5670" text-anchor="middle">h(v) → bucket</text>
      <text x="170" y="180" font-size="9" fill="#e65100" text-anchor="middle">= 42</text>

      <!-- Arrow to hash -->
      <line x1="100" y1="160" x2="128" y2="160" stroke="#0f4c81" stroke-width="1.5" marker-end="url(#arrow-lsh)"/>

      <!-- Buckets -->
      <rect x="240" y="20" width="300" height="280" rx="4" fill="#f5f7fb" stroke="#b0b6c4" stroke-width="1"/>
      <text x="390" y="40" font-size="11" font-weight="bold" fill="#4a5670" text-anchor="middle">Hash Buckets</text>

      <!-- Bucket 41 -->
      <rect x="260" y="55" width="260" height="45" rx="4" fill="#fff" stroke="#b0b6c4" stroke-width="1"/>
      <text x="275" y="75" font-size="9" fill="#b0b6c4">Bucket 41:</text>
      <circle cx="350" cy="77" r="8" fill="#e0e0e0"/>
      <circle cx="375" cy="77" r="8" fill="#e0e0e0"/>
      <circle cx="400" cy="77" r="8" fill="#e0e0e0"/>

      <!-- Bucket 42 (highlighted) -->
      <rect x="260" y="110" width="260" height="70" rx="4" fill="#e8f5e9" stroke="#2e7d32" stroke-width="2"/>
      <text x="275" y="130" font-size="10" font-weight="bold" fill="#2e7d32">Bucket 42:</text>
      <circle cx="350" cy="145" r="10" fill="#2e7d32"/>
      <text x="350" y="149" font-size="8" fill="#fff" text-anchor="middle">A</text>
      <circle cx="380" cy="145" r="10" fill="#2e7d32"/>
      <text x="380" y="149" font-size="8" fill="#fff" text-anchor="middle">B</text>
      <circle cx="410" cy="145" r="10" fill="#2e7d32"/>
      <text x="410" y="149" font-size="8" fill="#fff" text-anchor="middle">C</text>
      <circle cx="440" cy="145" r="10" fill="#2e7d32"/>
      <text x="440" y="149" font-size="8" fill="#fff" text-anchor="middle">D</text>
      <text x="275" y="168" font-size="8" fill="#2e7d32">← Only these 4 need exact comparison</text>

      <!-- Bucket 43 -->
      <rect x="260" y="190" width="260" height="45" rx="4" fill="#fff" stroke="#b0b6c4" stroke-width="1"/>
      <text x="275" y="210" font-size="9" fill="#b0b6c4">Bucket 43:</text>
      <circle cx="350" cy="212" r="8" fill="#e0e0e0"/>
      <circle cx="375" cy="212" r="8" fill="#e0e0e0"/>

      <!-- Bucket 44 -->
      <rect x="260" y="245" width="260" height="45" rx="4" fill="#fff" stroke="#b0b6c4" stroke-width="1"/>
      <text x="275" y="265" font-size="9" fill="#b0b6c4">Bucket 44:</text>
      <circle cx="350" cy="267" r="8" fill="#e0e0e0"/>
      <circle cx="375" cy="267" r="8" fill="#e0e0e0"/>
      <circle cx="400" cy="267" r="8" fill="#e0e0e0"/>
      <circle cx="425" cy="267" r="8" fill="#e0e0e0"/>
      <circle cx="450" cy="267" r="8" fill="#e0e0e0"/>

      <!-- Arrow to bucket -->
      <line x1="210" y1="160" x2="258" y2="145" stroke="#e65100" stroke-width="1.5" marker-end="url(#arrow-lsh)"/>

      <!-- Stats -->
      <text x="20" y="240" font-size="9" fill="#4a5670">Total concepts: 10,000</text>
      <text x="20" y="255" font-size="9" fill="#4a5670">Bucket 42 size: 4</text>
      <text x="20" y="270" font-size="9" fill="#2e7d32" font-weight="bold">Speedup: 2,500×</text>
    </svg>
    <p class="diagram-caption">LSH maps similar vectors to the same bucket. Instead of comparing the query against all 10,000 concepts, we only compare against the 4 concepts in bucket 42. Similar vectors hash to nearby buckets with high probability.</p>
  </div>

  <h2>How It Works</h2>

  <p>LSH uses random hyperplane projections to create hash codes. Each bit of the hash is determined by which side of a random hyperplane the vector falls on. Similar vectors tend to fall on the same side of most hyperplanes, producing similar hash codes and landing in the same or adjacent buckets.</p>

  <p>The <a href="../architecture/reasoning.html#retriever">Retriever</a> maintains multiple hash tables with different random projections. This reduces false negatives: if two similar vectors end up in different buckets in one table, they're likely to share a bucket in another table.</p>

  <h2>Two-Stage Retrieval</h2>

  <p>Retrieval happens in two stages:</p>

  <ol>
    <li><strong>Candidate selection</strong> – Hash the query, fetch all vectors in matching buckets across all tables</li>
    <li><strong>Exact ranking</strong> – Compute <a href="masked_l1_distance.html">masked L1 distance</a> for candidates, return top-k</li>
  </ol>

  <p>This combines LSH's speed (sublinear candidate selection) with exact distance accuracy (precise ranking of candidates).</p>

  <h2>Implementation</h2>

  <p>The <a href="../architecture/reasoning.html#retriever">Retriever</a> component manages LSH tables:</p>

  <table class="table-concept-index">
    <thead>
      <tr><th>Operation</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code>index(vector, id)</code></td>
        <td>Add vector to all hash tables</td>
      </tr>
      <tr>
        <td><code>query(vector, k)</code></td>
        <td>Find k nearest neighbors</td>
      </tr>
      <tr>
        <td><code>remove(id)</code></td>
        <td>Remove from all tables</td>
      </tr>
      <tr>
        <td><code>rehash()</code></td>
        <td>Rebuild tables (after many changes)</td>
      </tr>
    </tbody>
  </table>

  <h2>Configuration</h2>

  <p>LSH parameters are set via <a href="../architecture/configuration.html">configuration profiles</a>:</p>

  <table class="table-concept-index">
    <thead>
      <tr><th>Parameter</th><th>auto_test</th><th>prod</th><th>Effect</th></tr>
    </thead>
    <tbody>
      <tr>
        <td>numTables</td>
        <td>4</td>
        <td>16</td>
        <td>More tables = fewer false negatives</td>
      </tr>
      <tr>
        <td>hashBits</td>
        <td>8</td>
        <td>12</td>
        <td>More bits = smaller buckets</td>
      </tr>
      <tr>
        <td>probeRadius</td>
        <td>1</td>
        <td>2</td>
        <td>Check adjacent buckets too</td>
      </tr>
    </tbody>
  </table>

  <h2>Trade-offs</h2>

  <ul>
    <li><strong>Speed vs accuracy</strong> – More tables improve recall but cost memory and time</li>
    <li><strong>Memory vs precision</strong> – More hash bits create smaller buckets but more overhead</li>
    <li><strong>Build vs query</strong> – Indexing is slower than exact search; queries are much faster</li>
  </ul>

  <h2>Related Documentation</h2>

  <ul>
    <li><a href="../architecture/reasoning.html#retriever">Retriever Implementation</a> – LSH tables and query processing</li>
    <li><a href="masked_l1_distance.html">Masked L1 Distance</a> – The exact distance used for ranking</li>
    <li><a href="../architecture/configuration.html">Configuration</a> – Profile settings for LSH</li>
    <li><a href="hyperdimensional_computing.html">Hyperdimensional Computing</a> – Why high dimensions work well with LSH</li>
  </ul>

  <div class="footer-nav">
    <a href="masked_l1_distance.html">← Masked L1 Distance</a> ·
    <a href="theory_layers.html">Theory Layers →</a>
  </div>
  </div>
  <script src="../reference/nav2.js"></script>
</body>
</html>
