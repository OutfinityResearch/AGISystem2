<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Wiki - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Quick Wiki</h1>
    <small>
      <a href="../index.html">Home</a> &middot;
      <a href="../architecture/index.html">Architecture</a> &middot;
      <a href="../theory/index.html">Theory</a> &middot;
      <a href="../syntax/index.html">Syntax</a> &middot;
      <a href="../api/index.html">APIs</a> &middot;
      <a href="index.html">Wiki</a> &middot;
      <a href="../specs/matrix.html">Specs</a>
    </small>
    <small>Glossary of terms and concepts</small>
  </div>

  <div class="section-intro">
    <p>A compact glossary of AGISystem2 terms, concepts, and their relationships. Click any term for detailed documentation.</p>
  </div>

  <h2>Core Concepts</h2>

  <table>
    <tr>
      <th>Term</th>
      <th>Definition</th>
      <th>See Also</th>
    </tr>
    <tr>
      <td><strong>Hypervector</strong></td>
      <td>A high-dimensional representation of a concept, fact, or relationship. The fundamental data structure of AGISystem2. Can be binary (Dense-Binary) or set-based (SPHDC).</td>
      <td><a href="../theory/index.html">Theory</a></td>
    </tr>
    <tr>
      <td><strong>Geometry</strong></td>
      <td>The size parameter for vectors. For Dense-Binary: number of bits (default 2048). For SPHDC: cardinality k (default 4).</td>
      <td><a href="../api/index.html">API</a></td>
    </tr>
    <tr>
      <td><strong>Atom</strong></td>
      <td>A named hypervector representing a primitive concept (e.g., "Person", "loves", "John"). Atoms are the building blocks of knowledge.</td>
      <td><a href="../syntax/index.html">Syntax</a></td>
    </tr>
    <tr>
      <td><strong>Fact</strong></td>
      <td>A bound hypervector encoding a relationship (e.g., "John loves Mary"). Created by binding atoms with position markers.</td>
      <td><a href="../syntax/index.html">Syntax</a></td>
    </tr>
    <tr>
      <td><strong>Session</strong></td>
      <td>An isolated reasoning context with its own scope, knowledge base, and vocabulary. Sessions are independent and can run in parallel.</td>
      <td><a href="../api/index.html">API</a></td>
    </tr>
    <tr>
      <td><strong>Knowledge Base (KB)</strong></td>
      <td>A bundled hypervector containing all facts learned in a session. Used for query resolution via unbinding.</td>
      <td><a href="../theory/index.html">Theory</a></td>
    </tr>
    <tr>
      <td><strong>Vocabulary</strong></td>
      <td>The set of all known atoms in a session. Used for similarity matching when resolving queries.</td>
      <td><a href="../api/index.html">API</a></td>
    </tr>
  </table>

  <h2>HDC Strategies</h2>

  <table>
    <tr>
      <th>Strategy</th>
      <th>Representation</th>
      <th>Binding</th>
      <th>Similarity</th>
      <th>Documentation</th>
    </tr>
    <tr>
      <td><strong>Dense-Binary</strong></td>
      <td>Fixed-length binary vector (d bits)</td>
      <td>XOR (exact self-inverse)</td>
      <td><a href="../theory/concepts/hamming.html">Hamming</a></td>
      <td><a href="../theory/strategies/dense-binary.html">Full docs</a></td>
    </tr>
    <tr>
      <td><strong>SPHDC</strong></td>
      <td>Set of k 64-bit integers</td>
      <td>Cartesian XOR (statistical)</td>
      <td><a href="../theory/concepts/jaccard.html">Jaccard</a></td>
      <td><a href="../theory/strategies/sparse-polynomial.html">Full docs</a>, <a href="../theory/strategies/sphdc-analysis.html">Analysis</a></td>
    </tr>
  </table>

  <h2>Mathematical Foundations</h2>

  <table>
    <tr>
      <th>Concept</th>
      <th>Definition</th>
      <th>Learn More</th>
    </tr>
    <tr>
      <td><strong><a href="../theory/concepts/gf2.html">GF(2)</a></strong></td>
      <td>Galois Field with two elements {0, 1}. Addition in GF(2) is XOR. Foundation for reversible binding (a ⊕ a = 0).</td>
      <td><a href="../theory/concepts/gf2.html">Full explanation</a></td>
    </tr>
    <tr>
      <td><strong><a href="../theory/concepts/jaccard.html">Jaccard Similarity</a></strong></td>
      <td>Set similarity: |A ∩ B| / |A ∪ B|. Range [0,1]. Used by SPHDC strategy.</td>
      <td><a href="../theory/concepts/jaccard.html">Full explanation</a></td>
    </tr>
    <tr>
      <td><strong><a href="../theory/concepts/minhash.html">Min-Hash</a></strong></td>
      <td>Locality-sensitive hashing for efficient Jaccard estimation. Used for SPHDC sparsification.</td>
      <td><a href="../theory/concepts/minhash.html">Full explanation</a></td>
    </tr>
    <tr>
      <td><strong>Hamming Similarity</strong></td>
      <td>Binary vector similarity: 1 - (bit differences / total bits). Range [0,1]. Used by Dense-Binary strategy.</td>
      <td><a href="../theory/strategies/dense-binary.html">Dense-Binary docs</a></td>
    </tr>
    <tr>
      <td><strong><a href="../theory/holographic-representations.html">Holographic Representation</a></strong></td>
      <td>Distributed encoding where information is spread across all dimensions. Enables content-addressable retrieval.</td>
      <td><a href="../theory/holographic-representations.html">Full explanation</a></td>
    </tr>
  </table>

  <h2>Operations</h2>

  <table>
    <tr>
      <th>Term</th>
      <th>Definition</th>
      <th>Properties</th>
    </tr>
    <tr>
      <td><strong>Bind</strong></td>
      <td>Creates associations between concepts. Dense-Binary: XOR. SPHDC: Cartesian XOR.</td>
      <td>Commutative, Associative, Self-inverse (reversible)</td>
    </tr>
    <tr>
      <td><strong>Bundle</strong></td>
      <td>Combines multiple vectors. Dense-Binary: majority vote. SPHDC: set union + Min-Hash.</td>
      <td>Result similar to all inputs, Capacity-limited</td>
    </tr>
    <tr>
      <td><strong>Similarity</strong></td>
      <td>Measures relatedness. Dense-Binary: Hamming. SPHDC: Jaccard.</td>
      <td>1.0=identical, ~0.5=random, 0.0=maximally different</td>
    </tr>
    <tr>
      <td><strong>Unbind</strong></td>
      <td>Extracts unknown components from composite vectors. Same operation as Bind (self-inverse).</td>
      <td>Key to query resolution</td>
    </tr>
  </table>

  <h2>DSL Terms</h2>

  <table>
    <tr>
      <th>Term</th>
      <th>Syntax</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><strong>Hole</strong></td>
      <td><code>?name</code></td>
      <td>Unknown value to find in query</td>
    </tr>
    <tr>
      <td><strong>Position Vector</strong></td>
      <td><code>Pos1...Pos20</code></td>
      <td>Markers for argument order in relations</td>
    </tr>
    <tr>
      <td><strong>Implication</strong></td>
      <td><code>Implies (cond) (result)</code></td>
      <td>Rule for inference</td>
    </tr>
    <tr>
      <td><strong>Fact</strong></td>
      <td><code>relation arg1 arg2</code></td>
      <td>Assertion of relationship</td>
    </tr>
    <tr>
      <td><strong>Query</strong></td>
      <td><code>relation ?var arg</code></td>
      <td>Question with holes</td>
    </tr>
  </table>

  <h2>Reasoning Terms</h2>

  <table>
    <tr>
      <th>Term</th>
      <th>Definition</th>
      <th>See Also</th>
    </tr>
    <tr>
      <td><strong>Query</strong></td>
      <td>A statement with holes that retrieves matching information from the KB.</td>
      <td><a href="../api/index.html">API: query()</a></td>
    </tr>
    <tr>
      <td><strong>Proof</strong></td>
      <td>A tree of reasoning steps that derives a goal from known facts and rules.</td>
      <td><a href="../api/index.html">API: prove()</a></td>
    </tr>
    <tr>
      <td><strong>Backward Chaining</strong></td>
      <td>Proving a goal by recursively proving the premises of applicable rules.</td>
      <td><a href="../theory/index.html">Theory</a></td>
    </tr>
    <tr>
      <td><strong>Rule</strong></td>
      <td>An implication (Implies P Q) used for inference.</td>
      <td><a href="../syntax/index.html">Syntax</a></td>
    </tr>
    <tr>
      <td><strong>Transitive Closure</strong></td>
      <td>Following chains of relations (e.g., isA Dog Animal, isA Animal LivingThing → isA Dog LivingThing).</td>
      <td><a href="../theory/index.html">Theory</a></td>
    </tr>
    <tr>
      <td><strong>Disjoint Proof</strong></td>
      <td>Proving something is NOT the case (e.g., Dog is NOT a Plant if Animal and Plant are disjoint).</td>
      <td><a href="../theory/index.html">Theory</a></td>
    </tr>
  </table>

  <h2>Output & Decoding</h2>

  <table>
    <tr>
      <th>Term</th>
      <th>Definition</th>
      <th>See Also</th>
    </tr>
    <tr>
      <td><strong>Decode</strong></td>
      <td>Extract operator and arguments from a vector using similarity search against vocabulary.</td>
      <td><a href="../api/index.html">API: decode()</a></td>
    </tr>
    <tr>
      <td><strong>Generate Text</strong></td>
      <td>Convert decoded structure to natural language using templates.</td>
      <td><a href="../api/index.html">API: generateText()</a></td>
    </tr>
    <tr>
      <td><strong>Elaborate</strong></td>
      <td>Generate detailed explanation from a proof result.</td>
      <td><a href="../api/index.html">API: elaborate()</a></td>
    </tr>
    <tr>
      <td><strong>Summarize</strong></td>
      <td>Generate natural language summary of a vector.</td>
      <td><a href="../api/index.html">API: summarize()</a></td>
    </tr>
  </table>

  <h2>Privacy & Security</h2>

  <table>
    <tr>
      <th>Term</th>
      <th>Definition</th>
      <th>See Also</th>
    </tr>
    <tr>
      <td><strong>Secret Atoms</strong></td>
      <td>Concept vectors generated from private seed. Cloud cannot decode without the seed.</td>
      <td><a href="../theory/privacy-hdc.html">Privacy-HDC</a></td>
    </tr>
    <tr>
      <td><strong>Structural Leakage</strong></td>
      <td>Information revealed by similarity patterns even when atoms are secret.</td>
      <td><a href="../theory/privacy-hdc.html">Privacy-HDC</a></td>
    </tr>
    <tr>
      <td><strong>Federated Aggregation</strong></td>
      <td>Combining knowledge from multiple parties without revealing individual contributions.</td>
      <td><a href="../theory/privacy-hdc.html">Privacy-HDC</a></td>
    </tr>
    <tr>
      <td><strong>Homomorphic Property</strong></td>
      <td>Ability to compute on encoded data. HDC provides partial homomorphism (not cryptographic security).</td>
      <td><a href="../theory/privacy-hdc.html">Privacy-HDC</a></td>
    </tr>
  </table>

  <h2>Architectural Terms</h2>

  <table>
    <tr>
      <th>Term</th>
      <th>Definition</th>
    </tr>
    <tr>
      <td><strong>HDC Facade</strong></td>
      <td>Strategy-agnostic interface to vector operations. Allows switching between Dense-Binary and SPHDC.</td>
    </tr>
    <tr>
      <td><strong>Core Layer</strong></td>
      <td>Vector operations: Bind, Bundle, Similarity, position vectors.</td>
    </tr>
    <tr>
      <td><strong>Runtime Layer</strong></td>
      <td>State management: sessions, scopes, vocabulary, executor.</td>
    </tr>
    <tr>
      <td><strong>Parser Layer</strong></td>
      <td>DSL processing: lexer, parser, AST generation.</td>
    </tr>
    <tr>
      <td><strong>Reasoning Layer</strong></td>
      <td>Inference: query resolution, proof engine, transitive closure.</td>
    </tr>
    <tr>
      <td><strong>Decoding Layer</strong></td>
      <td>Output: structural decoder, text generator, phrasing templates.</td>
    </tr>
  </table>

  <h2>Thresholds Reference</h2>

  <table>
    <tr>
      <th>Threshold</th>
      <th>Value</th>
      <th>Meaning</th>
    </tr>
    <tr>
      <td>Strong Match</td>
      <td>&gt; 0.80</td>
      <td>High confidence, trust result</td>
    </tr>
    <tr>
      <td>Good Match</td>
      <td>0.65 - 0.80</td>
      <td>Solid match, probably correct</td>
    </tr>
    <tr>
      <td>Weak Match</td>
      <td>0.55 - 0.65</td>
      <td>Marginal, verify if critical</td>
    </tr>
    <tr>
      <td>No Match</td>
      <td>&lt; 0.55</td>
      <td>Near random, don't trust</td>
    </tr>
  </table>

  <h2>Acronyms</h2>

  <table>
    <tr>
      <th>Acronym</th>
      <th>Full Name</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>HDC</td>
      <td>Hyperdimensional Computing</td>
      <td>Computing paradigm using high-dimensional vectors</td>
    </tr>
    <tr>
      <td>VSA</td>
      <td>Vector Symbolic Architecture</td>
      <td>Umbrella term for HDC-like systems</td>
    </tr>
    <tr>
      <td>SPHDC</td>
      <td>Sparse Polynomial HDC</td>
      <td>Set-based HDC strategy using k exponents</td>
    </tr>
    <tr>
      <td>GF(2)</td>
      <td>Galois Field with 2 elements</td>
      <td>Algebraic foundation for XOR operations</td>
    </tr>
    <tr>
      <td>KB</td>
      <td>Knowledge Base</td>
      <td>Bundled vector containing all facts</td>
    </tr>
    <tr>
      <td>DSL</td>
      <td>Domain-Specific Language</td>
      <td>AGISystem2's fact/rule language</td>
    </tr>
    <tr>
      <td>AST</td>
      <td>Abstract Syntax Tree</td>
      <td>Parsed representation of DSL code</td>
    </tr>
    <tr>
      <td>FHE</td>
      <td>Fully Homomorphic Encryption</td>
      <td>Cryptographic computation on encrypted data</td>
    </tr>
    <tr>
      <td>LSH</td>
      <td>Locality-Sensitive Hashing</td>
      <td>Hashing that preserves similarity (e.g., Min-Hash)</td>
    </tr>
  </table>

  <h2>Related Pages</h2>

  <div class="section-grid">
    <div class="section-card">
      <h3><a href="../theory/index.html">Theory</a></h3>
      <p>Mathematical foundations of HDC</p>
    </div>
    <div class="section-card">
      <h3><a href="../theory/concepts/index.html">Concepts</a></h3>
      <p>GF(2), Jaccard, Min-Hash explained</p>
    </div>
    <div class="section-card">
      <h3><a href="../theory/privacy-hdc.html">Privacy</a></h3>
      <p>Privacy-preserving HDC analysis</p>
    </div>
    <div class="section-card">
      <h3><a href="../syntax/index.html">Syntax</a></h3>
      <p>Complete DSL reference</p>
    </div>
    <div class="section-card">
      <h3><a href="../api/index.html">API</a></h3>
      <p>JavaScript Session API</p>
    </div>
    <div class="section-card">
      <h3><a href="../architecture/index.html">Architecture</a></h3>
      <p>System design and modules</p>
    </div>
  </div>

  <h2>Strategy Comparison</h2>

  <table>
    <tr>
      <th>Aspect</th>
      <th>Dense-Binary</th>
      <th>SPHDC</th>
    </tr>
    <tr>
      <td>Default geometry</td>
      <td>2048 bits</td>
      <td>k=4 exponents</td>
    </tr>
    <tr>
      <td>Memory per vector</td>
      <td>256 bytes</td>
      <td>32 bytes</td>
    </tr>
    <tr>
      <td>Binding reversibility</td>
      <td>Exact</td>
      <td>Statistical</td>
    </tr>
    <tr>
      <td>Best for</td>
      <td>Deep reasoning chains</td>
      <td>Large vocabularies, low memory</td>
    </tr>
    <tr>
      <td>Full documentation</td>
      <td><a href="../theory/strategies/dense-binary.html">Dense-Binary</a></td>
      <td><a href="../theory/strategies/sparse-polynomial.html">SPHDC</a>, <a href="../theory/strategies/sphdc-analysis.html">Analysis</a></td>
    </tr>
  </table>

  <div class="footer-nav">
    <p>For detailed information, follow the links to specific documentation pages.</p>
  </div>
  </div>
</body>
</html>
