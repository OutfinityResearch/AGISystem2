<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>API Reference - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>API Reference</h1>
    <small>
      <a href="../index.html">Home</a> &middot;
      <a href="../architecture/index.html">Architecture</a> &middot;
      <a href="../theory/index.html">Theory</a> &middot;
      <a href="../syntax/index.html">Syntax</a> &middot;
      <a href="index.html">APIs</a> &middot;
      <a href="../wiki/index.html">Wiki</a> &middot;
      <a href="../specs/matrix.html">Specs</a>
    </small>
    <small>JavaScript/ES Module API documentation</small>
  </div>

  <div class="section-intro">
    <p>AGISystem2 provides a JavaScript/ES Module API for creating reasoning sessions, learning facts, querying knowledge, proving goals, and generating explanations. All methods return structured result objects.</p>
  </div>

  <h2>Quick Start</h2>

  <pre><code>import { Session } from 'agisystem2';

// Create a session with default geometry
const session = new Session({ geometry: 2048 });

// Learn some facts
session.learn(`
  isA Socrates Human
  Implies (isA ?x Human) (isA ?x Mortal)
`);

// Prove a goal
const result = session.prove('isA Socrates Mortal');
console.log(result.valid);   // true
console.log(result.steps);   // Proof chain

// Query the knowledge
const query = session.query('isA ?who Mortal');
console.log(query.bindings); // Map with answers

// Clean up
session.close();</code></pre>

  <h2>Installation</h2>

  <pre><code># Clone the repository
git clone https://github.com/OutfinityResearch/AGISystem2

# Import directly
import { Session } from './src/runtime/session.mjs';</code></pre>

  <h2>Session API</h2>

  <h3>new Session(options?)</h3>

  <p>Creates a new reasoning session.</p>

  <table>
    <tr>
      <th>Option</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>geometry</code></td>
      <td>number</td>
      <td>2048</td>
      <td>Vector dimension (Dense-Binary: 2048, SPHDC: 4)</td>
    </tr>
  </table>

  <pre><code>import { Session } from 'agisystem2';
import { initHDC } from './src/hdc/facade.mjs';

// Default: Dense-Binary strategy
const session = new Session({ geometry: 2048 });

// Alternative: SPHDC strategy (smaller, faster)
initHDC('sparse-polynomial');
const sphdcSession = new Session({ geometry: 4 });</code></pre>

  <h3>session.learn(dsl)</h3>

  <p>Parses and executes DSL statements, adding facts and rules to the session.</p>

  <pre><code>const result = session.learn(`
  loves John Mary
  loves Bob Alice
  parent John Charlie
`);

// Result structure
{
  success: true,
  facts: 3,
  errors: [],
  warnings: []
}</code></pre>

  <h3>session.query(dsl)</h3>

  <p>Executes a query with holes (?variables) and returns bindings.</p>

  <pre><code>const result = session.query('loves ?who Mary');

// Result structure
{
  success: true,
  bindings: Map { "who" => { answer: "John", similarity: 0.85 } },
  allResults: [
    { bindings: Map {...}, score: 0.85, method: "kb_match" }
  ]
}</code></pre>

  <h3>session.prove(goal, options?)</h3>

  <p>Attempts to prove a goal through backward chaining and returns a proof structure.</p>

  <table>
    <tr>
      <th>Option</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>timeout</code></td>
      <td>number</td>
      <td>2000</td>
      <td>Maximum time in milliseconds</td>
    </tr>
  </table>

  <pre><code>const result = session.prove('isA Socrates Mortal');

// Result structure
{
  valid: true,        // true if proven, false if disproven/cannot prove
  result: true,       // true = positive proof, false = disjoint proof
  goal: "isA Socrates Mortal",
  method: "rule_derivation",
  steps: [
    { operation: "match", goal: "...", result: "rule found" },
    { operation: "chain_step", from: "Socrates", to: "Human" }
  ],
  confidence: 0.92
}</code></pre>

  <h3>session.abduce(dsl, options?)</h3>

  <p>Abductive reasoning: finds the best explanation for an observation.</p>

  <pre><code>const result = session.abduce('wet Grass');

// Returns ranked explanations
{
  success: true,
  explanations: [
    { hypothesis: "rained", confidence: 0.8 },
    { hypothesis: "sprinklerOn", confidence: 0.6 }
  ]
}</code></pre>

  <h3>session.induce(options?)</h3>

  <p>Inductive reasoning: discovers patterns and suggests rules from the knowledge base.</p>

  <pre><code>const result = session.induce();

// Returns discovered patterns
{
  success: true,
  patterns: [
    { rule: "Implies (isA ?x Bird) (canFly ?x)", support: 0.9 }
  ]
}</code></pre>

  <h3>session.generateText(operator, args)</h3>

  <p>Generates natural language from operator and arguments.</p>

  <pre><code>const text = session.generateText('loves', ['John', 'Mary']);
// "John loves Mary."</code></pre>

  <h3>session.elaborate(proof)</h3>

  <p>Generates detailed explanation from a proof result.</p>

  <pre><code>const explanation = session.elaborate(proofResult);
// { text: "Socrates is mortal because Socrates is human...", ... }</code></pre>

  <h3>session.decode(vector)</h3>

  <p>Decodes a vector to its structural representation.</p>

  <pre><code>const structure = session.decode(someVector);

{
  success: true,
  structure: {
    operator: "loves",
    operatorConfidence: 0.85,
    arguments: [
      { position: 1, value: "John", confidence: 0.82 },
      { position: 2, value: "Mary", confidence: 0.79 }
    ]
  }
}</code></pre>

  <h3>session.summarize(vector)</h3>

  <p>Returns natural language summary of a vector.</p>

  <pre><code>const summary = session.summarize(factVector);

{
  success: true,
  text: "John loves Mary.",
  structure: { operator: "loves", arguments: [...] }
}</code></pre>

  <h3>session.dump()</h3>

  <p>Returns session state for debugging.</p>

  <pre><code>const state = session.dump();

{
  geometry: 2048,
  factCount: 15,
  ruleCount: 3,
  vocabularySize: 45,
  scopeBindings: ["f1", "f2", "r1", ...]
}</code></pre>

  <h3>session.getReasoningStats(reset?)</h3>

  <p>Returns reasoning statistics. Pass <code>true</code> to reset counters.</p>

  <pre><code>const stats = session.getReasoningStats();

{
  queries: 10,
  proofs: 5,
  kbScans: 23,
  similarityChecks: 156,
  ruleAttempts: 12,
  transitiveSteps: 8,
  maxProofDepth: 4,
  avgProofLength: "3.2",
  methods: { "kb_match": 6, "rule_derivation": 4 },
  hdcQueries: 3,
  hdcSuccesses: 2
}</code></pre>

  <h3>session.close()</h3>

  <p>Cleans up session resources.</p>

  <pre><code>session.close();</code></pre>

  <h2>Core Operations API</h2>

  <p>Low-level vector operations for advanced use.</p>

  <pre><code>import {
  bind,
  bindAll,
  bundle,
  similarity,
  distance,
  topKSimilar,
  unbind
} from 'agisystem2';

// Bind two vectors
const composite = bind(vectorA, vectorB);

// Unbind (same as bind - XOR is self-inverse)
const recovered = unbind(composite, vectorB); // â‰ˆ vectorA

// Bundle multiple vectors
const kb = bundle([fact1, fact2, fact3]);

// Calculate similarity
const sim = similarity(vectorA, vectorB); // 0.0 to 1.0

// Find most similar vectors
const matches = topKSimilar(query, vocabulary, 5);</code></pre>

  <h2>Position Vectors API</h2>

  <pre><code>import {
  getPositionVector,
  withPosition,
  removePosition,
  extractAtPosition
} from 'agisystem2';

// Get position vector (1-20)
const pos1 = getPositionVector(1, 2048);

// Add position to a vector
const positioned = withPosition(1, johnVector);

// Remove position from a vector
const extracted = removePosition(1, positionedVector);</code></pre>

  <h2>HDC Strategy Selection</h2>

  <pre><code>import { initHDC, getStrategyId } from './src/hdc/facade.mjs';

// Initialize specific strategy
initHDC('dense-binary');     // Classic: 2048-bit binary vectors
initHDC('sparse-polynomial'); // SPHDC: k=4 exponent sets

// Check current strategy
console.log(getStrategyId()); // "dense-binary" or "sparse-polynomial"</code></pre>

  <h2>Parser API</h2>

  <pre><code>import { parse, Lexer, Parser, ParseError } from 'agisystem2';

// Parse DSL to AST
const ast = parse('loves John Mary');

// Manual lexing
const lexer = new Lexer('loves John Mary');
const tokens = lexer.tokenize();

// Manual parsing
const parser = new Parser(tokens);
const ast = parser.parse();</code></pre>

  <h2>Test Library</h2>

  <pre><code>import { TestSession, Assertions } from 'agisystem2';

const test = new TestSession({ geometry: 2048 });

test.learn('isA Dog Animal');
test.assertProves('isA Dog Animal');
test.assertNotProves('isA Cat Dog');
test.assertQueryReturns('isA ?x Animal', 'x', 'Dog');</code></pre>

  <h2>Result Types</h2>

  <h3>LearnResult</h3>

  <pre><code>interface LearnResult {
  success: boolean;
  facts: number;
  errors: string[];
  warnings: string[];
}</code></pre>

  <h3>QueryResult</h3>

  <pre><code>interface QueryResult {
  success: boolean;
  bindings: Map&lt;string, { answer: string, similarity: number }&gt;;
  allResults: Array&lt;{
    bindings: Map&lt;string, any&gt;,
    score: number,
    method: string
  }&gt;;
}</code></pre>

  <h3>ProveResult</h3>

  <pre><code>interface ProveResult {
  valid: boolean;
  result?: boolean;        // true = positive, false = disjoint proof
  goal: string;
  method?: string;
  steps: ProofStep[];
  confidence?: number;
  reason?: string;         // If invalid, why
}

interface ProofStep {
  operation: string;
  goal?: string;
  from?: string;
  to?: string;
  result?: string;
}</code></pre>

  <h2>Error Handling</h2>

  <pre><code>import { ParseError, ExecutionError } from 'agisystem2';

try {
  session.learn('invalid!!! syntax @@@');
} catch (e) {
  if (e instanceof ParseError) {
    console.log(`Parse error at line ${e.line}: ${e.message}`);
  } else if (e instanceof ExecutionError) {
    console.log(`Execution error: ${e.message}`);
  }
}</code></pre>

  <h2>Complete Example</h2>

  <pre><code>import { Session } from 'agisystem2';

async function reasoningDemo() {
  const session = new Session({ geometry: 2048 });

  // Define knowledge
  session.learn(`
    # Facts
    isA Socrates Human
    isA Plato Human
    teaches Socrates Plato

    # Rules
    Implies (isA ?x Human) (isA ?x Mortal)
    Implies (teaches ?x ?y) (knows ?y ?x)
  `);

  // Query: Who is mortal?
  const q1 = session.query('isA ?who Mortal');
  if (q1.success) {
    console.log('Mortals:', q1.bindings.get('who')?.answer);
  }

  // Prove with explanation
  const proof = session.prove('isA Socrates Mortal');
  console.log('Proof valid:', proof.valid);
  console.log('Method:', proof.method);
  console.log('Steps:', proof.steps.length);

  // Natural language
  const text = session.generateText('isA', ['Socrates', 'Mortal']);
  console.log('Generated:', text);

  // Stats
  console.log('Stats:', session.getReasoningStats());

  session.close();
}

reasoningDemo();</code></pre>

  <h2>Related Documentation</h2>

  <ul>
    <li><a href="../syntax/index.html">DSL Syntax Reference</a></li>
    <li><a href="../theory/index.html">Theoretical Foundation</a></li>
    <li><a href="../architecture/index.html">System Architecture</a></li>
    <li><a href="../specsLoader.html?spec=DS/DS03-Architecture.md">DS03 - Architecture Specification</a></li>
  </ul>

  <div class="footer-nav">
    <p>All API methods return structured results for transparent, verifiable reasoning.</p>
  </div>
  </div>
</body>
</html>
