<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Geometry Layer</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>AGISystem2 – Geometry Layer</h1>
    <small>
      <a href="../index.html">Home</a> ·
      <a href="../guides/conceptual_spaces.html">Theory</a> ·
      <a href="index.html">Architecture</a> ·
      <a href="../api/index.html">APIs</a> ·
      <a href="../syntax/index.html">Syntax</a> ·
      <a href="../usage-cli/index.html">CLI</a> ·
      <a href="../wiki/index.html">Wiki</a> ·
      <a href="../specs/matrix.html">Specs</a>
    </small>
    <div class="sub-nav">
      <strong>Architecture:</strong>
      <a href="index.html">Overview</a> ·
      <a href="geometry.html">Geometry</a> ·
      <a href="knowledge.html">Knowledge</a> ·
      <a href="reasoning.html">Reasoning</a> ·
      <a href="language.html">Language</a> ·
      <a href="storage.html">Storage</a> ·
      <a href="configuration.html">Configuration</a> ·
      <a href="evalsuite.html">Eval Suite</a>
    </div>
  </div>

  <p>The Geometry Layer provides the mathematical foundation for all knowledge representation in AGISystem2. It implements a deterministic, high-dimensional vector space where concepts exist as geometric shapes and reasoning becomes distance computation. This layer contains no semantic knowledge—it only manipulates arrays of integers according to well-defined operations.</p>

  <div class="section-intro">
    <p><strong>Specification:</strong> DS(/core/geometry) · DS(/core/vector_space) · DS(/core/math_engine)</p>
  </div>

  <h2>Vector Space</h2>

  <p>The VectorSpace module manages allocation and basic operations on int8 arrays. All vectors have a fixed dimensionality determined by the configuration profile (typically 512, 1024, or 4096 dimensions). Using int8 instead of floating-point ensures deterministic arithmetic across platforms.</p>

  <div class="diagram">
    <svg viewBox="0 0 500 140" role="img" aria-label="Vector structure showing ontology and axiology partitions">
      <defs>
        <marker id="arrow-vec" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L6,3 L0,6 z" fill="#0f4c81" />
        </marker>
      </defs>

      <!-- Full vector bar -->
      <rect x="30" y="40" width="440" height="40" rx="4" fill="#f5f7fb" stroke="#0f4c81" stroke-width="2"/>

      <!-- Ontology partition -->
      <rect x="30" y="40" width="280" height="40" rx="4" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1"/>
      <text x="170" y="55" font-size="9" font-weight="bold" fill="#0f4c81" text-anchor="middle">Ontology Dimensions</text>
      <text x="170" y="70" font-size="8" fill="#4a5670" text-anchor="middle">Indices 0–255 (fixed)</text>

      <!-- Axiology partition -->
      <rect x="310" y="40" width="160" height="40" rx="4" fill="#fff3e0" stroke="#e65100" stroke-width="1"/>
      <text x="390" y="55" font-size="9" font-weight="bold" fill="#e65100" text-anchor="middle">Axiology Dimensions</text>
      <text x="390" y="70" font-size="8" fill="#4a5670" text-anchor="middle">Indices 256–383 (fixed)</text>

      <!-- Dimension labels -->
      <text x="30" y="100" font-size="7" fill="#4a5670">0</text>
      <text x="305" y="100" font-size="7" fill="#4a5670">255</text>
      <text x="315" y="100" font-size="7" fill="#4a5670">256</text>
      <text x="460" y="100" font-size="7" fill="#4a5670">383+</text>

      <!-- Arrows showing range -->
      <line x1="30" y1="90" x2="30" y2="82" stroke="#4a5670" stroke-width="1"/>
      <line x1="310" y1="90" x2="310" y2="82" stroke="#4a5670" stroke-width="1"/>
      <line x1="470" y1="90" x2="470" y2="82" stroke="#4a5670" stroke-width="1"/>

      <!-- Title -->
      <text x="250" y="25" font-size="10" font-weight="bold" fill="#0f4c81" text-anchor="middle">Int8 Vector (D dimensions)</text>
    </svg>
    <p class="diagram-caption">Vector structure with fixed partitions. Ontology dimensions (0–255) encode factual properties like physical attributes, taxonomic relations, and spatial features. Axiology dimensions (256–383) encode values, preferences, and normative properties. These partitions never change, enabling consistent separation of facts from values.</p>
  </div>

  <h3>Core Operations</h3>

  <table class="table-concept-index">
    <thead>
      <tr><th>Operation</th><th>Description</th><th>Complexity</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code>allocate(dim)</code></td>
        <td>Create new int8 array of given dimensionality</td>
        <td>O(D)</td>
      </tr>
      <tr>
        <td><code>copy(src, dst)</code></td>
        <td>Copy vector contents</td>
        <td>O(D)</td>
      </tr>
      <tr>
        <td><code>fill(vec, val)</code></td>
        <td>Set all dimensions to a value</td>
        <td>O(D)</td>
      </tr>
      <tr>
        <td><code>clamp(vec)</code></td>
        <td>Ensure all values in [-127, 127]</td>
        <td>O(D)</td>
      </tr>
    </tbody>
  </table>

  <h3>Saturation Arithmetic</h3>

  <p>All arithmetic operations use saturation to prevent overflow. When a sum exceeds 127, it is clamped to 127; when it goes below -127, it is clamped to -127. This ensures that results are always valid int8 values and that operations are reversible up to saturation.</p>

  <pre>
// Saturating addition
function addSaturate(a, b) {
  const sum = a + b;
  if (sum > 127) return 127;
  if (sum < -127) return -127;
  return sum;
}</pre>

  <h2 id="math-engine">Math Engine</h2>

  <p>The MathEngine module implements the geometric operations used throughout the system. All operations are pure functions with no side effects.</p>

  <h3>Masked L1 Distance</h3>

  <p>The primary similarity measure is masked L1 (Manhattan) distance. A relevance mask specifies which dimensions participate in the distance calculation. This allows comparing concepts along specific dimensions while ignoring others.</p>

  <div class="diagram">
    <svg viewBox="0 0 500 180" role="img" aria-label="Masked L1 distance computation">
      <defs>
        <marker id="arrow-l1" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L6,3 L0,6 z" fill="#0f4c81" />
        </marker>
      </defs>

      <!-- Vector A -->
      <rect x="30" y="30" width="180" height="25" rx="3" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1"/>
      <text x="40" y="47" font-size="8" fill="#0f4c81">A = [ 10, -5, 20, 8, -12, 3, ... ]</text>

      <!-- Vector B -->
      <rect x="30" y="65" width="180" height="25" rx="3" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1"/>
      <text x="40" y="82" font-size="8" fill="#0f4c81">B = [ 12, -3, 18, 5, -10, 7, ... ]</text>

      <!-- Mask -->
      <rect x="30" y="100" width="180" height="25" rx="3" fill="#fff3e0" stroke="#e65100" stroke-width="1"/>
      <text x="40" y="117" font-size="8" fill="#e65100">M = [ 1, 0, 1, 1, 0, 1, ... ]</text>

      <!-- Computation -->
      <rect x="260" y="30" width="220" height="95" rx="6" fill="#f5f7fb" stroke="#b0b6c4" stroke-width="1"/>
      <text x="280" y="50" font-size="9" font-weight="bold" fill="#0f4c81">Masked L1 Distance</text>
      <text x="280" y="70" font-size="8" fill="#4a5670">|10-12|×1 = 2</text>
      <text x="280" y="85" font-size="8" fill="#4a5670">|-5-(-3)|×0 = 0 (masked)</text>
      <text x="280" y="100" font-size="8" fill="#4a5670">|20-18|×1 = 2</text>
      <text x="280" y="115" font-size="8" fill="#4a5670">...</text>

      <!-- Result -->
      <rect x="260" y="135" width="220" height="30" rx="4" fill="#e1ecf7" stroke="#0f4c81" stroke-width="2"/>
      <text x="370" y="155" font-size="10" font-weight="bold" fill="#0f4c81" text-anchor="middle">d(A,B,M) = Σ|Aᵢ-Bᵢ|×Mᵢ</text>

      <!-- Arrows -->
      <line x1="210" y1="55" x2="258" y2="55" stroke="#0f4c81" stroke-width="1.5" marker-end="url(#arrow-l1)"/>
    </svg>
    <p class="diagram-caption">Masked L1 distance computation. Only dimensions where the mask is 1 contribute to the distance. This enables selective comparison—for example, comparing physical properties while ignoring value judgments, or vice versa.</p>
  </div>

  <pre>
function maskedL1Distance(a, b, mask) {
  let distance = 0;
  for (let i = 0; i < a.length; i++) {
    if (mask[i]) {
      distance += Math.abs(a[i] - b[i]);
    }
  }
  return distance;
}</pre>

  <h3>Permutation</h3>

  <p>Permutation reorders vector dimensions according to a fixed mapping. Different relations use different permutations, which allows the same base concept to participate in multiple relationships while maintaining distinguishable representations.</p>

  <pre>
function permute(vec, perm) {
  const result = new Int8Array(vec.length);
  for (let i = 0; i < vec.length; i++) {
    result[perm[i]] = vec[i];
  }
  return result;
}</pre>

  <h3>Temporal Rotation</h3>

  <p>Temporal encoding uses rotation to shift vector dimensions cyclically. Each time step applies a fixed rotation, and time can be "rewound" by applying the inverse rotation. This enables reasoning about past and future states without separate storage structures.</p>

  <pre>
function rotate(vec, steps, stride) {
  const result = new Int8Array(vec.length);
  const offset = (steps * stride) % vec.length;
  for (let i = 0; i < vec.length; i++) {
    result[(i + offset) % vec.length] = vec[i];
  }
  return result;
}</pre>

  <h2 id="bounded-diamond">Bounded Diamond</h2>

  <p>A BoundedDiamond is the geometric representation of a concept. It defines a region in the vector space using L1 distance (which creates diamond-shaped regions in high dimensions). The structure stores:</p>

  <ul>
    <li><strong>center</strong> – The centroid of the concept region</li>
    <li><strong>min/max</strong> – Per-dimension bounds that constrain the region</li>
    <li><strong>radius</strong> – The L1 distance from center to boundary</li>
    <li><strong>mask</strong> – Relevance mask indicating which dimensions matter</li>
  </ul>

  <div class="diagram">
    <svg viewBox="0 0 400 200" role="img" aria-label="Bounded diamond shape in 2D projection">
      <defs>
        <marker id="arrow-dia" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L6,3 L0,6 z" fill="#0f4c81" />
        </marker>
      </defs>

      <!-- Diamond shape -->
      <polygon points="200,30 320,100 200,170 80,100" fill="#e1ecf7" fill-opacity="0.5" stroke="#0f4c81" stroke-width="2"/>

      <!-- Center point -->
      <circle cx="200" cy="100" r="5" fill="#0f4c81"/>
      <text x="210" y="95" font-size="9" fill="#0f4c81">center</text>

      <!-- Radius lines -->
      <line x1="200" y1="100" x2="200" y2="30" stroke="#0f4c81" stroke-width="1" stroke-dasharray="4,2"/>
      <text x="205" y="65" font-size="8" fill="#4a5670">r</text>

      <!-- Min/Max bounds -->
      <line x1="80" y1="100" x2="320" y2="100" stroke="#b0b6c4" stroke-width="1" stroke-dasharray="2,2"/>
      <text x="85" y="115" font-size="8" fill="#4a5670">min</text>
      <text x="300" y="115" font-size="8" fill="#4a5670">max</text>

      <!-- Axis labels -->
      <text x="200" y="190" font-size="9" fill="#4a5670" text-anchor="middle">Dimension i</text>
      <text x="50" y="100" font-size="9" fill="#4a5670" text-anchor="middle" transform="rotate(-90,50,100)">Dimension j</text>

      <!-- Title -->
      <text x="200" y="15" font-size="10" font-weight="bold" fill="#0f4c81" text-anchor="middle">Bounded Diamond (2D projection)</text>
    </svg>
    <p class="diagram-caption">A bounded diamond in 2D projection. The L1 distance metric creates diamond-shaped regions. The min/max bounds provide per-dimension constraints that can further restrict the region. A point is inside the concept if it is within the radius of the center AND within all min/max bounds.</p>
  </div>

  <h3>Inclusion Test</h3>

  <p>A point is inside a bounded diamond if:</p>
  <ol>
    <li>The masked L1 distance from point to center is ≤ radius</li>
    <li>Each dimension value is within [min, max] bounds</li>
  </ol>

  <pre>
function isInside(point, diamond) {
  // Check L1 distance
  const dist = maskedL1Distance(point, diamond.center, diamond.mask);
  if (dist > diamond.radius) return false;

  // Check per-dimension bounds
  for (let i = 0; i < point.length; i++) {
    if (diamond.mask[i]) {
      if (point[i] < diamond.min[i] || point[i] > diamond.max[i]) {
        return false;
      }
    }
  }
  return true;
}</pre>

  <h3>Concept Unions</h3>

  <p>When a concept has multiple distinct meanings (polysemy), it can be represented as a union of bounded diamonds. The concept "bank" might be a union of {financial institution diamond} and {river edge diamond}. A point is inside the concept if it is inside any constituent diamond.</p>

  <h2 id="relation-permuter">Relation Permuter</h2>

  <p>The RelationPermuter module manages permutation tables for each relation type. When encoding a fact like "Dog IS_A Animal", the permuter provides the IS_A permutation to apply to the Animal vector before combining it with Dog.</p>

  <h3>Permutation Properties</h3>

  <ul>
    <li><strong>Deterministic</strong> – Permutations are derived from seeded random generators, ensuring reproducibility</li>
    <li><strong>Invertible</strong> – Each permutation has an inverse, enabling relation reversal</li>
    <li><strong>Symmetric handling</strong> – Symmetric relations (SIMILAR_TO) reuse the same permutation in both directions</li>
    <li><strong>Inverse pairs</strong> – Inverse relations (CAUSES/CAUSED_BY) use inverse permutations</li>
  </ul>

  <table class="table-concept-index">
    <thead>
      <tr><th>Relation</th><th>Inverse</th><th>Symmetric</th></tr>
    </thead>
    <tbody>
      <tr><td>IS_A</td><td>HAS_INSTANCE</td><td>No</td></tr>
      <tr><td>PART_OF</td><td>HAS_PART</td><td>No</td></tr>
      <tr><td>CAUSES</td><td>CAUSED_BY</td><td>No</td></tr>
      <tr><td>BEFORE</td><td>AFTER</td><td>No</td></tr>
      <tr><td>SIMILAR_TO</td><td>SIMILAR_TO</td><td>Yes</td></tr>
      <tr><td>PERMITS</td><td>PERMITTED_BY</td><td>No</td></tr>
      <tr><td>PROHIBITS</td><td>PROHIBITED_BY</td><td>No</td></tr>
    </tbody>
  </table>

  <h2>Configuration</h2>

  <p>Geometry Layer parameters are set through configuration profiles:</p>

  <table class="table-concept-index">
    <thead>
      <tr><th>Parameter</th><th>auto_test</th><th>manual_test</th><th>prod</th></tr>
    </thead>
    <tbody>
      <tr><td>Dimensionality</td><td>512</td><td>1024</td><td>4096</td></tr>
      <tr><td>Ontology range</td><td>0–255</td><td>0–255</td><td>0–255</td></tr>
      <tr><td>Axiology range</td><td>256–383</td><td>256–383</td><td>256–511</td></tr>
      <tr><td>Permutation seed</td><td>42</td><td>42</td><td>configurable</td></tr>
    </tbody>
  </table>

  <h2>Related Documentation</h2>

  <ul>
    <li><a href="../guides/conceptual_spaces.html">Conceptual Spaces Theory</a> – Theoretical foundation</li>
    <li><a href="../wiki/hyperdimensional_computing.html">Hyperdimensional Computing</a> – Background on HD computing</li>
    <li><a href="../wiki/bounded_diamonds.html">Bounded Diamonds</a> – Detailed wiki entry</li>
    <li><a href="../wiki/masked_l1_distance.html">Masked L1 Distance</a> – Distance metric details</li>
    <li><a href="../wiki/permutation_binding.html">Permutation Binding</a> – Role encoding</li>
  </ul>

  <div class="footer-nav">
    <a href="index.html">← Overview</a> ·
    <a href="knowledge.html">Knowledge Layer →</a>
  </div>
  </div>
  <script src="../reference/nav2.js"></script>
</body>
</html>
