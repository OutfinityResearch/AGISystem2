<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Knowledge Layer</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>AGISystem2 – Knowledge Layer</h1>
    <small>
      <a href="../index.html">Home</a> ·
      <a href="../guides/conceptual_spaces.html">Theory</a> ·
      <a href="index.html">Architecture</a> ·
      <a href="../api/index.html">APIs</a> ·
      <a href="../syntax/index.html">Syntax</a> ·
      <a href="../usage-cli/index.html">CLI</a> ·
      <a href="../wiki/index.html">Wiki</a> ·
      <a href="../specs/matrix.html">Specs</a>
    </small>
    <div class="sub-nav">
      <strong>Architecture:</strong>
      <a href="index.html">Overview</a> ·
      <a href="geometry.html">Geometry</a> ·
      <a href="knowledge.html">Knowledge</a> ·
      <a href="reasoning.html">Reasoning</a> ·
      <a href="language.html">Language</a> ·
      <a href="storage.html">Storage</a> ·
      <a href="configuration.html">Configuration</a> ·
      <a href="evalsuite.html">Eval Suite</a>
    </div>
  </div>

  <p>The Knowledge Layer manages the organization and persistence of concepts in AGISystem2. It builds on the <a href="geometry.html">Geometry Layer</a> to store bounded diamonds, manage their evolution through clustering, and enable layered contexts through the theory stack. This layer provides the semantic substrate on which reasoning operates.</p>

  <div class="section-intro">
    <p><strong>Specification:</strong> DS(/storage/concepts) · DS(/storage/cluster_manager) · DS(/core/theory_stack)</p>
  </div>

  <h2>ConceptStore</h2>

  <p>The ConceptStore is the primary repository for concepts. Each concept is identified by a canonical name and stored as one or more bounded diamonds. The store provides fast lookup by name and supports iteration over all stored concepts.</p>

  <div class="diagram">
    <svg viewBox="0 0 520 200" role="img" aria-label="ConceptStore structure">
      <defs>
        <marker id="arrow-cs" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L6,3 L0,6 z" fill="#0f4c81" />
        </marker>
      </defs>

      <!-- ConceptStore box -->
      <rect x="20" y="20" width="480" height="160" rx="8" fill="#f5f7fb" stroke="#0f4c81" stroke-width="2"/>
      <text x="40" y="45" font-size="11" font-weight="bold" fill="#0f4c81">ConceptStore</text>

      <!-- Name index -->
      <rect x="40" y="60" width="140" height="100" rx="4" fill="#fff" stroke="#b0b6c4" stroke-width="1"/>
      <text x="110" y="80" font-size="9" font-weight="bold" fill="#4a5670" text-anchor="middle">Name Index</text>
      <text x="50" y="100" font-size="8" fill="#4a5670">"Dog" → ptr</text>
      <text x="50" y="115" font-size="8" fill="#4a5670">"Cat" → ptr</text>
      <text x="50" y="130" font-size="8" fill="#4a5670">"Animal" → ptr</text>
      <text x="50" y="145" font-size="8" fill="#4a5670">...</text>

      <!-- Diamond storage -->
      <rect x="200" y="60" width="140" height="100" rx="4" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1"/>
      <text x="270" y="80" font-size="9" font-weight="bold" fill="#0f4c81" text-anchor="middle">Diamond Storage</text>
      <polygon points="240,100 270,115 240,130 210,115" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1"/>
      <polygon points="300,100 330,115 300,130 270,115" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1"/>
      <text x="240" y="150" font-size="7" fill="#4a5670">Diamond 1</text>
      <text x="300" y="150" font-size="7" fill="#4a5670">Diamond 2</text>

      <!-- Persistence -->
      <rect x="360" y="60" width="120" height="100" rx="4" fill="#fff" stroke="#b0b6c4" stroke-width="1"/>
      <text x="420" y="80" font-size="9" font-weight="bold" fill="#4a5670" text-anchor="middle">Persistence</text>
      <text x="370" y="100" font-size="8" fill="#4a5670">StorageAdapter</text>
      <text x="370" y="115" font-size="8" fill="#4a5670">→ disk/memory</text>
      <rect x="380" y="125" width="80" height="25" rx="3" fill="#f5f7fb" stroke="#b0b6c4" stroke-width="1"/>
      <text x="420" y="142" font-size="7" fill="#4a5670" text-anchor="middle">.AGISystem2/</text>

      <!-- Arrows -->
      <line x1="180" y1="110" x2="198" y2="110" stroke="#0f4c81" stroke-width="1.5" marker-end="url(#arrow-cs)"/>
      <line x1="340" y1="110" x2="358" y2="110" stroke="#b0b6c4" stroke-width="1.5" marker-end="url(#arrow-cs)"/>
    </svg>
    <p class="diagram-caption">ConceptStore architecture. The name index provides O(1) lookup by concept name. Diamond storage holds the geometric representations. The persistence layer syncs changes to disk or other storage backends.</p>
  </div>

  <h3>Operations</h3>

  <table class="table-concept-index">
    <thead>
      <tr><th>Operation</th><th>Description</th><th>Complexity</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code>get(name)</code></td>
        <td>Retrieve concept by canonical name</td>
        <td>O(1)</td>
      </tr>
      <tr>
        <td><code>put(name, diamond)</code></td>
        <td>Store or update concept</td>
        <td>O(1) amortized</td>
      </tr>
      <tr>
        <td><code>exists(name)</code></td>
        <td>Check if concept exists</td>
        <td>O(1)</td>
      </tr>
      <tr>
        <td><code>listConcepts()</code></td>
        <td>Return all concept names</td>
        <td>O(N)</td>
      </tr>
      <tr>
        <td><code>delete(name)</code></td>
        <td>Remove concept</td>
        <td>O(1)</td>
      </tr>
    </tbody>
  </table>

  <h3>Concept Structure</h3>

  <p>Each concept in the store contains:</p>

  <pre>
{
  name: "Dog",                    // Canonical name
  diamonds: [                     // One or more bounded diamonds
    {
      center: Int8Array,          // Centroid vector
      min: Int8Array,             // Per-dimension minimums
      max: Int8Array,             // Per-dimension maximums
      radius: number,             // L1 radius
      mask: Uint8Array,           // Relevance mask
      observationCount: number    // Training observations
    }
  ],
  metadata: {
    created: timestamp,
    lastModified: timestamp,
    source: "assertion" | "inference"
  }
}</pre>

  <h2 id="cluster-manager">ClusterManager</h2>

  <p>The ClusterManager decides how new observations affect concept shapes. When a new point is observed for a concept, the manager must choose: expand an existing diamond, create a new diamond, or split an overgrown diamond.</p>

  <div class="diagram">
    <svg viewBox="0 0 520 220" role="img" aria-label="ClusterManager decision tree">
      <defs>
        <marker id="arrow-cm" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L6,3 L0,6 z" fill="#0f4c81" />
        </marker>
      </defs>

      <!-- New observation -->
      <rect x="200" y="10" width="120" height="35" rx="6" fill="#e1ecf7" stroke="#0f4c81" stroke-width="2"/>
      <text x="260" y="32" font-size="9" font-weight="bold" fill="#0f4c81" text-anchor="middle">New Observation</text>

      <!-- Decision point -->
      <polygon points="260,65 310,95 260,125 210,95" fill="#fff3e0" stroke="#e65100" stroke-width="2"/>
      <text x="260" y="100" font-size="8" fill="#e65100" text-anchor="middle">Inside?</text>

      <!-- Yes path - already inside -->
      <rect x="50" y="140" width="100" height="50" rx="4" fill="#e8f5e9" stroke="#2e7d32" stroke-width="1"/>
      <text x="100" y="160" font-size="8" font-weight="bold" fill="#2e7d32" text-anchor="middle">Inside</text>
      <text x="100" y="175" font-size="7" fill="#4a5670" text-anchor="middle">No change needed</text>

      <!-- No path - outside -->
      <polygon points="340,140 390,170 340,200 290,170" fill="#fff3e0" stroke="#e65100" stroke-width="2"/>
      <text x="340" y="170" font-size="7" fill="#e65100" text-anchor="middle">Expand OK?</text>

      <!-- Expand -->
      <rect x="420" y="120" width="90" height="40" rx="4" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1"/>
      <text x="465" y="140" font-size="8" font-weight="bold" fill="#0f4c81" text-anchor="middle">Expand</text>
      <text x="465" y="152" font-size="7" fill="#4a5670" text-anchor="middle">Widen diamond</text>

      <!-- New diamond -->
      <rect x="420" y="175" width="90" height="40" rx="4" fill="#e1ecf7" stroke="#0f4c81" stroke-width="1"/>
      <text x="465" y="195" font-size="8" font-weight="bold" fill="#0f4c81" text-anchor="middle">New Diamond</text>
      <text x="465" y="207" font-size="7" fill="#4a5670" text-anchor="middle">Create cluster</text>

      <!-- Arrows -->
      <line x1="260" y1="45" x2="260" y2="63" stroke="#0f4c81" stroke-width="1.5" marker-end="url(#arrow-cm)"/>
      <line x1="210" y1="95" x2="100" y2="138" stroke="#2e7d32" stroke-width="1.5" marker-end="url(#arrow-cm)"/>
      <text x="140" y="110" font-size="7" fill="#2e7d32">Yes</text>
      <line x1="310" y1="95" x2="340" y2="138" stroke="#e65100" stroke-width="1.5" marker-end="url(#arrow-cm)"/>
      <text x="340" y="110" font-size="7" fill="#e65100">No</text>
      <line x1="390" y1="160" x2="418" y2="145" stroke="#0f4c81" stroke-width="1.5" marker-end="url(#arrow-cm)"/>
      <text x="395" y="145" font-size="7" fill="#0f4c81">Yes</text>
      <line x1="390" y1="180" x2="418" y2="190" stroke="#0f4c81" stroke-width="1.5" marker-end="url(#arrow-cm)"/>
      <text x="395" y="195" font-size="7" fill="#0f4c81">No</text>
    </svg>
    <p class="diagram-caption">ClusterManager decision flow. If the new observation is already inside an existing diamond, no change is needed. If outside, the manager decides whether to expand the nearest diamond or create a new one based on distance thresholds and concept coherence.</p>
  </div>

  <h3>Expansion Policy</h3>

  <p>The expansion policy controls when a diamond grows versus when a new diamond is created. Key parameters:</p>

  <ul>
    <li><strong>maxRadius</strong> – Maximum L1 radius before forcing a new cluster</li>
    <li><strong>expansionThreshold</strong> – Maximum distance from boundary for expansion</li>
    <li><strong>coherenceCheck</strong> – Whether to verify semantic coherence before expansion</li>
  </ul>

  <pre>
function handleObservation(concept, point) {
  // Find nearest diamond
  const nearest = findNearestDiamond(concept.diamonds, point);
  const dist = distanceToSurface(nearest, point);

  if (dist <= 0) {
    // Already inside
    return { action: 'none' };
  }

  if (dist < expansionThreshold && nearest.radius + dist < maxRadius) {
    // Expand existing diamond
    return expandDiamond(nearest, point);
  }

  // Create new diamond
  return createNewDiamond(concept, point);
}</pre>

  <h3>Splitting</h3>

  <p>When a diamond grows too large or becomes incoherent (covering semantically distant points), it can be split into multiple smaller diamonds. Splitting uses k-means clustering on the observation history to find natural subclusters.</p>

  <h2 id="theory-stack">TheoryStack</h2>

  <p>The TheoryStack enables layered knowledge contexts. Each layer can override specific aspects of concepts without modifying the base knowledge. This mechanism supports:</p>

  <ul>
    <li><strong>Hypothetical reasoning</strong> – "What if X were true?"</li>
    <li><strong>Contradictory contexts</strong> – Hold conflicting views simultaneously</li>
    <li><strong>Domain-specific overlays</strong> – Apply domain knowledge on top of general knowledge</li>
    <li><strong>Undo/rollback</strong> – Pop a layer to discard changes</li>
  </ul>

  <div class="diagram">
    <svg viewBox="0 0 400 220" role="img" aria-label="Theory stack layered structure">
      <defs>
        <marker id="arrow-ts" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L6,3 L0,6 z" fill="#0f4c81" />
        </marker>
      </defs>

      <!-- Base layer -->
      <rect x="50" y="150" width="300" height="50" rx="6" fill="#e1ecf7" stroke="#0f4c81" stroke-width="2"/>
      <text x="200" y="175" font-size="10" font-weight="bold" fill="#0f4c81" text-anchor="middle">Base Knowledge</text>
      <text x="200" y="190" font-size="8" fill="#4a5670" text-anchor="middle">Dog IS_A Animal, Cat IS_A Animal, ...</text>

      <!-- Layer 1 -->
      <rect x="70" y="95" width="260" height="45" rx="6" fill="#fff3e0" stroke="#e65100" stroke-width="2"/>
      <text x="200" y="115" font-size="9" font-weight="bold" fill="#e65100" text-anchor="middle">Theory Layer: medical_context</text>
      <text x="200" y="130" font-size="8" fill="#4a5670" text-anchor="middle">Aspirin REDUCES Inflammation</text>

      <!-- Layer 2 (top) -->
      <rect x="90" y="40" width="220" height="45" rx="6" fill="#e8f5e9" stroke="#2e7d32" stroke-width="2"/>
      <text x="200" y="60" font-size="9" font-weight="bold" fill="#2e7d32" text-anchor="middle">Theory Layer: hypothetical_1</text>
      <text x="200" y="75" font-size="8" fill="#4a5670" text-anchor="middle">Dog CAN Fly (hypothetical)</text>

      <!-- Stack direction arrow -->
      <line x1="380" y1="180" x2="380" y2="60" stroke="#0f4c81" stroke-width="1.5" marker-end="url(#arrow-ts)"/>
      <text x="390" y="120" font-size="8" fill="#0f4c81" transform="rotate(90,390,120)">Stack grows up</text>

      <!-- Labels -->
      <text x="30" y="175" font-size="8" fill="#4a5670">depth 0</text>
      <text x="30" y="118" font-size="8" fill="#4a5670">depth 1</text>
      <text x="30" y="63" font-size="8" fill="#4a5670">depth 2</text>
    </svg>
    <p class="diagram-caption">Theory stack structure. The base layer contains permanent knowledge. Upper layers add or override facts for specific contexts. When querying, the system composes layers from top to bottom, with upper layers taking precedence.</p>
  </div>

  <h3>Stack Operations</h3>

  <table class="table-concept-index">
    <thead>
      <tr><th>Operation</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code>push(name)</code></td>
        <td>Create and push new layer with given name</td>
      </tr>
      <tr>
        <td><code>pop()</code></td>
        <td>Remove top layer, discarding its changes</td>
      </tr>
      <tr>
        <td><code>peek()</code></td>
        <td>Get current top layer without removing</td>
      </tr>
      <tr>
        <td><code>depth()</code></td>
        <td>Return current stack depth</td>
      </tr>
      <tr>
        <td><code>compose(conceptName)</code></td>
        <td>Get runtime view of concept through all layers</td>
      </tr>
      <tr>
        <td><code>save(filename)</code></td>
        <td>Persist current top layer to file</td>
      </tr>
      <tr>
        <td><code>load(filename)</code></td>
        <td>Load layer from file and push</td>
      </tr>
    </tbody>
  </table>

  <h3>Layer Composition</h3>

  <p>When a concept is requested, the stack composes a runtime view by merging all layers:</p>

  <pre>
function getComposedConcept(name) {
  // Start with base concept
  let result = baseStore.get(name) || createEmpty(name);

  // Apply each layer from bottom to top
  for (const layer of stack) {
    if (layer.has(name)) {
      const override = layer.get(name);
      result = mergeConceptOverride(result, override);
    }
  }

  return result;
}</pre>

  <h2 id="theory-layer">TheoryLayer</h2>

  <p>Each TheoryLayer contains concept overrides that modify the base knowledge. Overrides can:</p>

  <ul>
    <li><strong>Add new concepts</strong> – Concepts that exist only in this context</li>
    <li><strong>Modify dimensions</strong> – Change specific min/max/center values</li>
    <li><strong>Adjust masks</strong> – Enable or disable dimensions for comparison</li>
    <li><strong>Change radius</strong> – Expand or contract concept boundaries</li>
  </ul>

  <h3>Override Structure</h3>

  <pre>
{
  name: "medical_context",
  overrides: {
    "Aspirin": {
      // New concept added in this layer
      diamonds: [{ center: [...], min: [...], max: [...], radius: 50, mask: [...] }]
    },
    "Inflammation": {
      // Dimension override for existing concept
      dimensionOverrides: {
        42: { min: -20, max: 20 },  // Override dimension 42 bounds
        87: { min: -10, max: 30 }   // Override dimension 87 bounds
      }
    }
  },
  facts: [
    { subject: "Aspirin", relation: "REDUCES", object: "Inflammation" }
  ]
}</pre>

  <h2>Persistence</h2>

  <p>The Knowledge Layer uses the StorageAdapter to persist concepts and theories. The default adapter writes to the <code>.AGISystem2/</code> directory structure:</p>

  <pre>
.AGISystem2/
├── data/
│   ├── concepts/
│   │   ├── Dog.bin          # Binary diamond data
│   │   ├── Cat.bin
│   │   └── ...
│   └── index.json           # Name → file mapping
└── theories/
    ├── base.sys2dsl         # Base theory (optional)
    ├── medical_context.sys2dsl
    └── ...</pre>

  <p>Binary format stores vectors efficiently; text format (<code>.sys2dsl</code>) stores human-readable fact lists for portability and version control.</p>

  <h2>Configuration</h2>

  <table class="table-concept-index">
    <thead>
      <tr><th>Parameter</th><th>auto_test</th><th>manual_test</th><th>prod</th></tr>
    </thead>
    <tbody>
      <tr><td>maxRadius</td><td>100</td><td>150</td><td>200</td></tr>
      <tr><td>expansionThreshold</td><td>30</td><td>40</td><td>50</td></tr>
      <tr><td>maxDiamondsPerConcept</td><td>3</td><td>5</td><td>10</td></tr>
      <tr><td>persistenceInterval</td><td>immediate</td><td>10 ops</td><td>100 ops</td></tr>
    </tbody>
  </table>

  <h2>Related Documentation</h2>

  <ul>
    <li><a href="geometry.html">Geometry Layer</a> – The mathematical foundation</li>
    <li><a href="storage.html">Storage Layer</a> – Persistence details</li>
    <li><a href="../wiki/theory_layers.html">Theory Layers Wiki</a> – Background theory</li>
    <li><a href="../syntax/syntax_theories.html">Theory Syntax</a> – Command syntax for theories</li>
  </ul>

  <div class="footer-nav">
    <a href="geometry.html">← Geometry</a> ·
    <a href="reasoning.html">Reasoning Layer →</a>
  </div>
  </div>
  <script src="../reference/nav2.js"></script>
</body>
</html>
