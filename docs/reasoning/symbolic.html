<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Symbolic Reasoning Engine - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Symbolic Reasoning Engine <span class="badge badge-success">Core</span></h1>
    <small>
      <a href="../index.html">Home</a> &middot;
      <a href="index.html">Reasoning</a> &middot;
      <a href="symbolic.html">Symbolic</a> &middot;
      <a href="holographic.html">Holographic</a>
    </small>
    <small>Classical logic with HDC acceleration - <code>symbolicPriority</code> mode</small>
  </div>

  <div class="breadcrumb">
    <a href="../index.html">Docs</a> &rarr; <a href="index.html">Reasoning</a> &rarr; Symbolic Engine
  </div>

  <div class="section-intro">
    <p>The <strong>Symbolic Reasoning Engine</strong> implements classical logical reasoning with explicit proof steps. HDC (Hyperdimensional Computing) is used as an acceleration layer for storage and retrieval, but all reasoning decisions are made through symbolic pattern matching and rule application.</p>
  </div>

  <h2>Design Philosophy</h2>

  <div class="alert alert-success">
    <strong>Core Principle:</strong> Symbolic reasoning first, HDC for efficiency. Every proof step is deterministic and traceable. No approximate matching affects correctness.
  </div>

  <p>The symbolic engine prioritizes:</p>
  <ul>
    <li><strong>Determinism</strong>: Same input always produces same output</li>
    <li><strong>Traceability</strong>: Proof traces for every conclusion (audit logging/export is external)</li>
    <li><strong>Correctness</strong>: No false positives from similarity thresholds</li>
    <li><strong>Explainability</strong>: Every step can be explained and verified</li>
  </ul>

  <h2>Architecture Overview</h2>

  <div class="diagram-container">
    <div class="diagram-title">Symbolic Engine Component Architecture</div>
    <svg viewBox="0 0 750 500" xmlns="http://www.w3.org/2000/svg" style="max-width: 750px;">
      <!-- Main ProofEngine box -->
      <rect x="200" y="20" width="350" height="60" rx="10" fill="#4caf50" stroke="#2e7d32" stroke-width="2"/>
      <text x="375" y="45" text-anchor="middle" font-weight="bold" font-size="16" fill="white">ProofEngine</text>
      <text x="375" y="65" text-anchor="middle" font-size="11" fill="#c8e6c9">Orchestrates all reasoning components</text>

      <!-- Components -->
      <rect x="20" y="120" width="150" height="70" rx="8" fill="#66bb6a"/>
      <text x="95" y="145" text-anchor="middle" font-weight="bold" font-size="12" fill="white">TransitiveReasoner</text>
      <text x="95" y="165" text-anchor="middle" font-size="10" fill="#e8f5e9">isA, locatedIn, partOf</text>
      <text x="95" y="178" text-anchor="middle" font-size="10" fill="#e8f5e9">chain inference</text>

      <rect x="190" y="120" width="150" height="70" rx="8" fill="#66bb6a"/>
      <text x="265" y="145" text-anchor="middle" font-weight="bold" font-size="12" fill="white">KBMatcher</text>
      <text x="265" y="165" text-anchor="middle" font-size="10" fill="#e8f5e9">Direct KB search</text>
      <text x="265" y="178" text-anchor="middle" font-size="10" fill="#e8f5e9">Pattern matching</text>

      <rect x="360" y="120" width="150" height="70" rx="8" fill="#66bb6a"/>
      <text x="435" y="145" text-anchor="middle" font-weight="bold" font-size="12" fill="white">UnificationEngine</text>
      <text x="435" y="165" text-anchor="middle" font-size="10" fill="#e8f5e9">Variable binding</text>
      <text x="435" y="178" text-anchor="middle" font-size="10" fill="#e8f5e9">Rule instantiation</text>

      <rect x="530" y="120" width="150" height="70" rx="8" fill="#66bb6a"/>
      <text x="605" y="145" text-anchor="middle" font-weight="bold" font-size="12" fill="white">ConditionProver</text>
      <text x="605" y="165" text-anchor="middle" font-size="10" fill="#e8f5e9">And/Or conditions</text>
      <text x="605" y="178" text-anchor="middle" font-size="10" fill="#e8f5e9">Backtracking</text>

      <rect x="105" y="220" width="150" height="70" rx="8" fill="#81c784"/>
      <text x="180" y="245" text-anchor="middle" font-weight="bold" font-size="12" fill="white">PropertyInheritance</text>
      <text x="180" y="265" text-anchor="middle" font-size="10" fill="#e8f5e9">Class property</text>
      <text x="180" y="278" text-anchor="middle" font-size="10" fill="#e8f5e9">inheritance</text>

      <rect x="275" y="220" width="150" height="70" rx="8" fill="#81c784"/>
      <text x="350" y="245" text-anchor="middle" font-weight="bold" font-size="12" fill="white">DisjointProver</text>
      <text x="350" y="265" text-anchor="middle" font-size="10" fill="#e8f5e9">Spatial negation</text>
      <text x="350" y="278" text-anchor="middle" font-size="10" fill="#e8f5e9">Disjoint proofs</text>

      <rect x="445" y="220" width="150" height="70" rx="8" fill="#81c784"/>
      <text x="520" y="245" text-anchor="middle" font-weight="bold" font-size="12" fill="white">SynonymMatcher</text>
      <text x="520" y="265" text-anchor="middle" font-size="10" fill="#e8f5e9">Synonym expansion</text>
      <text x="520" y="278" text-anchor="middle" font-size="10" fill="#e8f5e9">ComponentKB lookup</text>

      <!-- Query Engine section -->
      <rect x="20" y="330" width="350" height="60" rx="10" fill="#2e7d32" stroke="#1b5e20" stroke-width="2"/>
      <text x="195" y="355" text-anchor="middle" font-weight="bold" font-size="16" fill="white">QueryEngine</text>
      <text x="195" y="375" text-anchor="middle" font-size="11" fill="#c8e6c9">Hole-filling queries with Master Equation</text>

      <!-- Query sources -->
      <rect x="20" y="410" width="100" height="50" rx="5" fill="#a5d6a7"/>
      <text x="70" y="432" text-anchor="middle" font-size="10" fill="#1b5e20" font-weight="bold">HDC Search</text>
      <text x="70" y="448" text-anchor="middle" font-size="9" fill="#2e7d32">KB BIND Query⁻¹</text>

      <rect x="130" y="410" width="100" height="50" rx="5" fill="#a5d6a7"/>
      <text x="180" y="432" text-anchor="middle" font-size="10" fill="#1b5e20" font-weight="bold">Direct KB</text>
      <text x="180" y="448" text-anchor="middle" font-size="9" fill="#2e7d32">Exact match</text>

      <rect x="240" y="410" width="100" height="50" rx="5" fill="#a5d6a7"/>
      <text x="290" y="432" text-anchor="middle" font-size="10" fill="#1b5e20" font-weight="bold">Transitive</text>
      <text x="290" y="448" text-anchor="middle" font-size="9" fill="#2e7d32">Chain search</text>

      <!-- CSP Solver section -->
      <rect x="400" y="330" width="280" height="60" rx="10" fill="#1b5e20" stroke="#0d330d" stroke-width="2"/>
      <text x="540" y="355" text-anchor="middle" font-weight="bold" font-size="16" fill="white">CSPSolver</text>
      <text x="540" y="375" text-anchor="middle" font-size="11" fill="#c8e6c9">Constraint Satisfaction Problems</text>

      <rect x="400" y="410" width="85" height="50" rx="5" fill="#c8e6c9"/>
      <text x="442" y="432" text-anchor="middle" font-size="10" fill="#1b5e20" font-weight="bold">Domains</text>
      <text x="442" y="448" text-anchor="middle" font-size="9" fill="#2e7d32">Variables</text>

      <rect x="495" y="410" width="85" height="50" rx="5" fill="#c8e6c9"/>
      <text x="537" y="432" text-anchor="middle" font-size="10" fill="#1b5e20" font-weight="bold">Constraints</text>
      <text x="537" y="448" text-anchor="middle" font-size="9" fill="#2e7d32">Rules</text>

      <rect x="590" y="410" width="90" height="50" rx="5" fill="#c8e6c9"/>
      <text x="635" y="432" text-anchor="middle" font-size="10" fill="#1b5e20" font-weight="bold">Backtrack</text>
      <text x="635" y="448" text-anchor="middle" font-size="9" fill="#2e7d32">Search</text>

      <!-- Connection lines -->
      <line x1="375" y1="80" x2="95" y2="120" stroke="#4caf50" stroke-width="1.5"/>
      <line x1="375" y1="80" x2="265" y2="120" stroke="#4caf50" stroke-width="1.5"/>
      <line x1="375" y1="80" x2="435" y2="120" stroke="#4caf50" stroke-width="1.5"/>
      <line x1="375" y1="80" x2="605" y2="120" stroke="#4caf50" stroke-width="1.5"/>

      <line x1="180" y1="190" x2="180" y2="220" stroke="#66bb6a" stroke-width="1.5"/>
      <line x1="350" y1="190" x2="350" y2="220" stroke="#66bb6a" stroke-width="1.5"/>
      <line x1="520" y1="190" x2="520" y2="220" stroke="#66bb6a" stroke-width="1.5"/>
    </svg>
  </div>

  <h2>Proof Strategy</h2>

  <p>The ProofEngine tries strategies in strict priority order. The first successful strategy returns the result:</p>

  <table>
    <tr>
      <th>Priority</th>
      <th>Strategy</th>
      <th>Description</th>
      <th>Confidence</th>
    </tr>
    <tr>
      <td><span class="badge badge-primary">1</span></td>
      <td><strong>Direct KB Match</strong></td>
      <td>Exact vector match in knowledge base (strong threshold)</td>
      <td>Very high (&gt;0.95)</td>
    </tr>
    <tr>
      <td><span class="badge badge-primary">1.5</span></td>
      <td><strong>Synonym Match</strong></td>
      <td>Match via ComponentKB synonym expansion</td>
      <td>High (0.95)</td>
    </tr>
    <tr>
      <td><span class="badge badge-success">2</span></td>
      <td><strong>Transitive Chain</strong></td>
      <td>Follow isA/locatedIn/partOf chains to target</td>
      <td>Decays with chain length</td>
    </tr>
    <tr>
      <td><span class="badge badge-success">2.5</span></td>
      <td><strong>Property Inheritance</strong></td>
      <td>Inherit properties from parent classes</td>
      <td>Based on chain confidence</td>
    </tr>
    <tr>
      <td><span class="badge badge-warning">3</span></td>
      <td><strong>Rule Matching</strong></td>
      <td>Backward chaining through rules (If/Then)</td>
      <td>Product of condition confidences</td>
    </tr>
    <tr>
      <td><span class="badge badge-warning">4</span></td>
      <td><strong>Weak Direct Match</strong></td>
      <td>Accept lower-threshold KB matches</td>
      <td>Moderate (&gt;0.85)</td>
    </tr>
    <tr>
      <td><span class="badge badge-error">5</span></td>
      <td><strong>Disjoint Proof</strong></td>
      <td>Prove via spatial/set negation</td>
      <td>Variable</td>
    </tr>
  </table>

  <h2>Core Classes</h2>

  <h3>ProofEngine</h3>

  <p>Main orchestrator for proof search. Coordinates all reasoning components.</p>

  <pre><code>import { ProofEngine } from './reasoning/prove.mjs';

const engine = new ProofEngine(session, {
  maxDepth: 10,      // Maximum recursion depth
  timeout: 5000      // Timeout in milliseconds
});

// Prove a goal
const result = engine.prove({
  type: 'Statement',
  operator: { name: 'isA' },
  args: [{ name: 'Tweety' }, { name: 'Animal' }]
});

console.log(result);
// {
//   valid: true,
//   confidence: 0.9025,
//   method: 'transitive_chain',
//   steps: [
//     { operation: 'transitive_step', fact: 'isA Tweety Bird' },
//     { operation: 'transitive_step', fact: 'isA Bird Animal' }
//   ],
//   reasoningSteps: 4
// }</code></pre>

  <h4>Key Methods</h4>

  <table>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>prove(goal)</code></td>
      <td>Main entry point. Proves a goal statement and returns result with steps.</td>
    </tr>
    <tr>
      <td><code>tryDirectMatch(vec, str)</code></td>
      <td>Attempt direct KB match for goal vector.</td>
    </tr>
    <tr>
      <td><code>combineConfidences(results)</code></td>
      <td>Combine confidences from multiple sub-proofs with decay.</td>
    </tr>
    <tr>
      <td><code>isGoalNegated(goal)</code></td>
      <td>Check if goal is explicitly negated in KB.</td>
    </tr>
  </table>

  <h3>QueryEngine</h3>

  <p>Handles queries with "holes" (unknown values to find). Uses the HDC Master Equation.</p>

  <pre><code>import { QueryEngine } from './reasoning/query.mjs';

const engine = new QueryEngine(session);

// Query: "What is Tweety?" (isA Tweety ?what)
const result = engine.execute({
  type: 'Statement',
  operator: { name: 'isA' },
  args: [
    { name: 'Tweety', type: 'Identifier' },
    { name: 'what', type: 'Hole' }
  ]
});

console.log(result);
// {
//   success: true,
//   bindings: Map { 'what' => { answer: 'Bird', similarity: 0.95, method: 'direct' } },
//   allResults: [
//     { bindings: Map {...}, score: 0.95, method: 'direct' },
//     { bindings: Map {...}, score: 0.90, method: 'transitive' }
//   ]
// }</code></pre>

  <h4>Query Sources</h4>

  <p>QueryEngine aggregates results from multiple sources:</p>

  <ol>
    <li><strong>HDC Master Equation</strong>: <code>Answer = KB BIND Query⁻¹</code></li>
    <li><strong>Direct KB Search</strong>: Exact metadata matching</li>
    <li><strong>Transitive Reasoning</strong>: Chain traversal for hierarchy queries</li>
    <li><strong>Rule Derivation</strong>: Apply rules to derive new bindings</li>
    <li><strong>Compound CSP</strong>: Multi-variable constraint solutions</li>
    <li><strong>Bundle Patterns</strong>: Common property discovery</li>
  </ol>

  <h3>Reasoning Sub-Components</h3>

  <h4>TransitiveReasoner</h4>

  <p>Handles transitive relations with automatic chain discovery.</p>

  <pre><code>// Supported transitive relations
const TRANSITIVE_RELATIONS = new Set([
  'isA',          // Taxonomy chains
  'locatedIn',    // Spatial containment
  'partOf',       // Mereological relations
  'subClassOf',   // Class hierarchies
  'ancestorOf',   // Genealogy
  'contains',     // Inverse of locatedIn
  'before'        // Temporal ordering
]);</code></pre>

  <h4>ConditionProver</h4>

  <p>Proves compound conditions with And/Or logic and backtracking.</p>

  <pre><code>// And condition: all must succeed
And(isA ?x Bird, can ?x Fly)

// Or condition: any can succeed
Or(isA ?x Penguin, isA ?x Ostrich)</code></pre>

  <h4>PropertyInheritanceReasoner</h4>

  <p>Inherits properties from parent classes in the taxonomy.</p>

  <pre><code>// Given: Bird can Fly, Tweety isA Bird
// Proves: Tweety can Fly (via property inheritance)</code></pre>

  <h2>CSP Solver</h2>

  <p>Constraint Satisfaction Problem solver for assignment problems.</p>

  <pre><code>import { CSPSolver } from './reasoning/csp/solver.mjs';

const solver = new CSPSolver(session);

// Wedding seating problem
solver.addVariable('Alice', ['Table1', 'Table2', 'Table3']);
solver.addVariable('Bob', ['Table1', 'Table2', 'Table3']);
solver.addVariable('Carol', ['Table1', 'Table2', 'Table3']);

// Constraints
solver.addNoConflict('Alice', 'Bob');  // Alice and Bob can't sit together
solver.addAllDifferent('Alice', 'Bob', 'Carol');  // All at different tables

const result = solver.solve();
// { success: true, solutions: [{ Alice: 'Table1', Bob: 'Table2', Carol: 'Table3' }, ...] }</code></pre>

  <h2>Confidence Calculation</h2>

  <p>Confidence values decay through reasoning chains:</p>

  <pre><code>// Strategy-dependent thresholds (from constants.mjs)
const thresholds = {
  VERY_STRONG_MATCH: 0.95,   // Direct match threshold
  STRONG_MATCH: 0.85,        // Weak match threshold
  TRANSITIVE_BASE: 0.95,     // Base transitive confidence
  TRANSITIVE_DECAY: 0.95,    // Per-step decay factor
  DEFAULT_CONFIDENCE: 0.8    // When no explicit confidence
};

// Chain confidence: base * decay^length
// Example: 2-step chain → 0.95 * 0.95² = 0.857</code></pre>

  <h2>Negation Handling</h2>

  <p>The engine checks for explicit negation before attempting proofs:</p>

  <pre><code>// If KB contains: Not $canTweetyFly (where $canTweetyFly = "can Tweety Fly")
// Then prove("can Tweety Fly") returns:
// { valid: false, reason: 'Goal is negated' }</code></pre>

  <h2>Statistics Tracking</h2>

  <p>The engine tracks detailed reasoning statistics:</p>

  <pre><code>session.reasoningStats = {
  kbScans: 0,           // KB traversals
  similarityChecks: 0,  // HDC similarity computations
  ruleAttempts: 0,      // Rules tried
  transitiveChains: 0,  // Transitive inferences
  hdcQueries: 0,        // HDC Master Equation uses
  hdcSuccesses: 0,      // Successful HDC results
  // ...
};</code></pre>

  <h2>Example: Complete Proof Trace</h2>

  <pre><code>// KB: isA Tweety Bird, isA Bird Animal, can Bird Fly
// Query: prove "can Tweety Fly"

const result = engine.prove(parseGoal("can Tweety Fly"));

// Result:
{
  valid: true,
  confidence: 0.902,
  method: 'property_inheritance',
  goal: 'can Tweety Fly',
  steps: [
    {
      operation: 'find_class_property',
      fact: 'can Bird Fly',
      confidence: 0.95
    },
    {
      operation: 'verify_membership',
      fact: 'isA Tweety Bird',
      confidence: 0.95
    },
    {
      operation: 'inherit_property',
      from: 'Bird',
      to: 'Tweety',
      property: 'can Fly'
    }
  ],
  reasoningSteps: 6,
  proof: [...steps]
}</code></pre>

  <h2>Integration with HDC</h2>

  <p>While symbolic reasoning drives decisions, HDC provides acceleration:</p>

  <div class="alert alert-info">
    <strong>HDC Usage in Symbolic Mode:</strong>
    <ul style="margin-bottom: 0;">
      <li><strong>Storage</strong>: Facts encoded as HDC vectors for efficient bundling</li>
      <li><strong>Retrieval</strong>: KB bundle enables sub-linear candidate filtering</li>
      <li><strong>Similarity</strong>: Used for candidate ranking, not decision-making</li>
      <li><strong>Position Encoding</strong>: Structured data via positional binding</li>
    </ul>
  </div>

  <h2>Limitations</h2>

  <ul>
    <li><strong>No fuzzy matching</strong>: Requires exact or near-exact matches</li>
    <li><strong>Depth limits</strong>: Deep recursion may timeout</li>
    <li><strong>Rule explosion</strong>: Many rules can slow backward chaining</li>
    <li><strong>Closed-world assumption</strong>: Unprovable = false</li>
  </ul>

  <div class="footer-nav">
    <p><a href="holographic.html">Next: Holographic Reasoning Engine &rarr;</a></p>
    <p><a href="index.html">&larr; Back to Reasoning Overview</a></p>
  </div>
  </div>
</body>
</html>
