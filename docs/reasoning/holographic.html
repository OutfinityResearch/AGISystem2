<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Holographic Reasoning Engine - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Holographic Reasoning Engine</h1>
    <small>
      <a href="../index.html">Home</a> &middot;
      <a href="index.html">Reasoning</a> &middot;
      <a href="symbolic.html">Symbolic</a> &middot;
      <a href="holographic.html">Holographic</a>
    </small>
    <small>HDC-first approach with symbolic validation - <code>holographicPriority</code> mode</small>
  </div>

  <div class="breadcrumb">
    <a href="../index.html">Docs</a> &rarr; <a href="index.html">Reasoning</a> &rarr; Holographic Engine
  </div>

  <div class="section-intro">
    <p>The <strong>Holographic Reasoning Engine</strong> leverages Hyperdimensional Computing (HDC) as the primary mechanism for finding candidate proofs and query answers. It uses vector similarity to rapidly identify likely solutions, then validates them with symbolic proof for correctness.</p>
  </div>

  <h2>Design Philosophy</h2>

  <div class="alert alert-info">
    <strong>Core Principle:</strong> HDC similarity for candidate discovery, symbolic reasoning for validation. Combine the speed of vector operations with the precision of logical proof.
  </div>

  <p>The holographic engine prioritizes:</p>
  <ul>
    <li><strong>Speed</strong>: Sub-linear search through HDC bundle operations</li>
    <li><strong>Pattern matching</strong>: Find similar facts even with noise</li>
    <li><strong>Synonym awareness</strong>: ComponentKB integration for semantic equivalence</li>
    <li><strong>Graceful degradation</strong>: Fall back to symbolic when HDC fails</li>
  </ul>

  <h2>Architecture Overview</h2>

  <div class="diagram-container">
    <div class="diagram-title">Holographic Engine Pipeline</div>
    <svg viewBox="0 0 800 450" xmlns="http://www.w3.org/2000/svg" style="max-width: 800px;">
      <!-- Input -->
      <rect x="20" y="30" width="120" height="50" rx="8" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
      <text x="80" y="50" text-anchor="middle" font-size="11" fill="#1565c0" font-weight="bold">Query/Goal</text>
      <text x="80" y="68" text-anchor="middle" font-size="10" fill="#1976d2">Input AST</text>

      <!-- Arrow to Build Vector -->
      <line x1="140" y1="55" x2="170" y2="55" stroke="#1976d2" stroke-width="2" marker-end="url(#arrowBlue)"/>

      <!-- Build Vector -->
      <rect x="170" y="30" width="140" height="50" rx="8" fill="#1976d2"/>
      <text x="240" y="50" text-anchor="middle" font-size="11" fill="white" font-weight="bold">Build Vector</text>
      <text x="240" y="68" text-anchor="middle" font-size="10" fill="#bbdefb">HDC encoding</text>

      <!-- Arrow to HDC Search -->
      <line x1="310" y1="55" x2="340" y2="55" stroke="#1976d2" stroke-width="2"/>

      <!-- HDC Search (main box) -->
      <rect x="340" y="10" width="200" height="90" rx="10" fill="#0d47a1" stroke="#1565c0" stroke-width="3"/>
      <text x="440" y="35" text-anchor="middle" font-size="14" fill="white" font-weight="bold">HDC Similarity Search</text>
      <text x="440" y="55" text-anchor="middle" font-size="11" fill="#90caf9">KB Bundle scan</text>
      <text x="440" y="72" text-anchor="middle" font-size="11" fill="#90caf9">Top-K candidates</text>
      <text x="440" y="89" text-anchor="middle" font-size="10" fill="#64b5f6">Answer = KB ⊕ Query⁻¹</text>

      <!-- Candidate pool -->
      <rect x="560" y="30" width="120" height="50" rx="8" fill="#42a5f5"/>
      <text x="620" y="50" text-anchor="middle" font-size="11" fill="white" font-weight="bold">Candidates</text>
      <text x="620" y="68" text-anchor="middle" font-size="10" fill="#e3f2fd">[sim: 0.92, 0.87...]</text>

      <line x1="540" y1="55" x2="560" y2="55" stroke="#1976d2" stroke-width="2"/>

      <!-- Validation phase -->
      <line x1="620" y1="80" x2="620" y2="130" stroke="#4caf50" stroke-width="2"/>

      <rect x="520" y="130" width="200" height="80" rx="10" fill="#4caf50" stroke="#2e7d32" stroke-width="2"/>
      <text x="620" y="155" text-anchor="middle" font-size="14" fill="white" font-weight="bold">Symbolic Validation</text>
      <text x="620" y="175" text-anchor="middle" font-size="11" fill="#c8e6c9">Verify each candidate</text>
      <text x="620" y="195" text-anchor="middle" font-size="10" fill="#a5d6a7">ProofEngine.prove()</text>

      <!-- Valid results -->
      <line x1="620" y1="210" x2="620" y2="250" stroke="#4caf50" stroke-width="2"/>

      <rect x="540" y="250" width="160" height="50" rx="8" fill="#66bb6a"/>
      <text x="620" y="270" text-anchor="middle" font-size="11" fill="white" font-weight="bold">Validated Results</text>
      <text x="620" y="288" text-anchor="middle" font-size="10" fill="#e8f5e9">HDC + Symbolic proof</text>

      <!-- Fallback path -->
      <rect x="200" y="150" width="180" height="70" rx="8" fill="#ff9800" stroke="#f57c00" stroke-width="2"/>
      <text x="290" y="175" text-anchor="middle" font-size="12" fill="white" font-weight="bold">Symbolic Fallback</text>
      <text x="290" y="195" text-anchor="middle" font-size="10" fill="#fff3e0">If HDC finds nothing</text>
      <text x="290" y="210" text-anchor="middle" font-size="10" fill="#ffe0b2">Full symbolic search</text>

      <!-- Fallback arrow -->
      <path d="M440 100 Q440 125 380 150" stroke="#ff9800" stroke-width="2" fill="none" stroke-dasharray="5,3"/>
      <text x="420" y="130" font-size="9" fill="#f57c00">no candidates?</text>

      <!-- Merge arrow -->
      <line x1="380" y1="185" x2="450" y2="185" stroke="#ff9800" stroke-width="1.5" stroke-dasharray="3,3"/>
      <line x1="450" y1="185" x2="540" y2="275" stroke="#ff9800" stroke-width="1.5" stroke-dasharray="3,3"/>

      <!-- Final output -->
      <line x1="620" y1="300" x2="620" y2="340" stroke="#2e7d32" stroke-width="2"/>

      <rect x="520" y="340" width="160" height="50" rx="8" fill="#1b5e20"/>
      <text x="600" y="362" text-anchor="middle" font-size="12" fill="white" font-weight="bold">Final Result</text>
      <text x="600" y="380" text-anchor="middle" font-size="10" fill="#a5d6a7">Confidence + Steps</text>

      <!-- Transitive HDC path -->
      <rect x="20" y="130" width="150" height="60" rx="8" fill="#64b5f6"/>
      <text x="95" y="152" text-anchor="middle" font-size="11" fill="white" font-weight="bold">HDC Chain Search</text>
      <text x="95" y="170" text-anchor="middle" font-size="10" fill="#e3f2fd">Transitive relations</text>
      <text x="95" y="185" text-anchor="middle" font-size="10" fill="#bbdefb">BFS with HDC edges</text>

      <line x1="95" y1="100" x2="95" y2="130" stroke="#1976d2" stroke-width="1.5" stroke-dasharray="3,3"/>
      <text x="105" y="118" font-size="9" fill="#1976d2">isA/locatedIn?</text>

      <!-- Rule HDC path -->
      <rect x="20" y="220" width="150" height="60" rx="8" fill="#90caf9"/>
      <text x="95" y="242" text-anchor="middle" font-size="11" fill="#0d47a1" font-weight="bold">HDC Rule Search</text>
      <text x="95" y="260" text-anchor="middle" font-size="10" fill="#1565c0">Match conclusion</text>
      <text x="95" y="275" text-anchor="middle" font-size="10" fill="#1976d2">Check conditions</text>

      <line x1="95" y1="190" x2="95" y2="220" stroke="#1976d2" stroke-width="1.5" stroke-dasharray="3,3"/>

      <!-- Connect sub-paths to validation -->
      <path d="M170 160 Q350 160 520 170" stroke="#64b5f6" stroke-width="1.5" fill="none" stroke-dasharray="4,2"/>
      <path d="M170 250 Q350 250 520 185" stroke="#90caf9" stroke-width="1.5" fill="none" stroke-dasharray="4,2"/>

      <!-- Legend -->
      <rect x="20" y="380" width="300" height="60" rx="5" fill="#f5f5f5" stroke="#ddd"/>
      <text x="30" y="400" font-size="11" fill="#333" font-weight="bold">Legend:</text>
      <rect x="30" y="410" width="15" height="15" fill="#1976d2"/>
      <text x="50" y="422" font-size="10" fill="#333">HDC operations</text>
      <rect x="130" y="410" width="15" height="15" fill="#4caf50"/>
      <text x="150" y="422" font-size="10" fill="#333">Symbolic validation</text>
      <rect x="250" y="410" width="15" height="15" fill="#ff9800"/>
      <text x="270" y="422" font-size="10" fill="#333">Fallback</text>
    </svg>
  </div>

  <h2>HDC-First Proof Strategy</h2>

  <p>HolographicProofEngine follows this pipeline:</p>

  <table>
    <tr>
      <th>Step</th>
      <th>Operation</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><span class="badge badge-primary">1</span></td>
      <td><strong>Build Goal Vector</strong></td>
      <td>Encode goal as HDC vector using positional binding</td>
    </tr>
    <tr>
      <td><span class="badge badge-primary">2</span></td>
      <td><strong>Check Negation</strong></td>
      <td>Verify goal isn't explicitly negated in KB</td>
    </tr>
    <tr>
      <td><span class="badge badge-primary">3</span></td>
      <td><strong>HDC Direct Search</strong></td>
      <td>Scan KB for similar vectors (threshold: HDC_MATCH)</td>
    </tr>
    <tr>
      <td><span class="badge badge-primary">3b</span></td>
      <td><strong>Synonym Matching</strong></td>
      <td>Try ComponentKB synonym expansion if no direct match</td>
    </tr>
    <tr>
      <td><span class="badge badge-success">4</span></td>
      <td><strong>Symbolic Validation</strong></td>
      <td>Verify HDC candidate with ProofEngine</td>
    </tr>
    <tr>
      <td><span class="badge badge-primary">5</span></td>
      <td><strong>HDC Transitive Search</strong></td>
      <td>BFS through HDC-similar edges for transitive relations</td>
    </tr>
    <tr>
      <td><span class="badge badge-primary">6</span></td>
      <td><strong>HDC Rule Search</strong></td>
      <td>Match rule conclusions via similarity, check conditions</td>
    </tr>
    <tr>
      <td><span class="badge badge-warning">7</span></td>
      <td><strong>Symbolic Fallback</strong></td>
      <td>If HDC fails, run full symbolic proof search</td>
    </tr>
  </table>

  <h2>Core Classes</h2>

  <h3>HolographicProofEngine</h3>

  <p>Drop-in replacement for ProofEngine. Same interface, different strategy.</p>

  <pre><code>import { HolographicProofEngine } from './reasoning/holographic/prove-hdc-first.mjs';

const engine = new HolographicProofEngine(session, {
  maxDepth: 10,
  timeout: 5000
});

// Prove using HDC-first approach
const result = engine.prove({
  type: 'Statement',
  operator: { name: 'isA' },
  args: [{ name: 'Tweety' }, { name: 'Animal' }]
});

// Result includes method information
console.log(result);
// {
//   valid: true,
//   confidence: 0.91,
//   method: 'hdc_transitive_validated',  // HDC found it, symbolic validated
//   steps: [...],
//   reasoningSteps: 3
// }</code></pre>

  <h4>Key Methods</h4>

  <table>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>prove(goal)</code></td>
      <td>Main entry. HDC search first, symbolic validation, then fallback.</td>
    </tr>
    <tr>
      <td><code>hdcDirectSearch(vec, str)</code></td>
      <td>Scan KB bundle for similar vectors. Returns candidates.</td>
    </tr>
    <tr>
      <td><code>hdcTransitiveSearch(goal, vec)</code></td>
      <td>BFS through HDC edges for transitive chains.</td>
    </tr>
    <tr>
      <td><code>hdcRuleSearch(goal, vec)</code></td>
      <td>Match rule conclusions via similarity, verify conditions.</td>
    </tr>
    <tr>
      <td><code>validateWithSymbolic(goal)</code></td>
      <td>Confirm HDC candidate with full symbolic proof.</td>
    </tr>
  </table>

  <h3>HolographicQueryEngine</h3>

  <p>HDC-first query resolution using the unbind operation.</p>

  <pre><code>import { HolographicQueryEngine } from './reasoning/holographic/query-hdc-first.mjs';

const engine = new HolographicQueryEngine(session);

// Query: "What can Tweety do?" (can Tweety ?action)
const result = engine.execute({
  type: 'Statement',
  operator: { name: 'can' },
  args: [
    { name: 'Tweety', type: 'Identifier' },
    { name: 'action', type: 'Hole' }
  ]
});

// HDC unbind finds candidates, symbolic validates
console.log(result);
// {
//   success: true,
//   bindings: Map { 'action' => { answer: 'Fly', similarity: 0.94, method: 'hdc_validated' } },
//   confidence: 0.94,
//   allResults: [...]
// }</code></pre>

  <h4>HDC Query Pipeline</h4>

  <ol>
    <li><strong>Parse Query</strong>: Identify holes (unknowns) and knowns</li>
    <li><strong>Build Partial Vector</strong>: Encode knowns with positions</li>
    <li><strong>HDC Unbind</strong>: <code>Answer = KB ⊕ QueryPartial⁻¹ ⊕ Position⁻¹</code></li>
    <li><strong>Top-K Vocabulary</strong>: Find most similar entities</li>
    <li><strong>Symbolic Validation</strong>: Prove each candidate</li>
    <li><strong>Merge with Symbolic</strong>: Combine HDC + fallback results</li>
  </ol>

  <h3>HolographicCSPSolver</h3>

  <p>Constraint Satisfaction with HDC-guided heuristics.</p>

  <pre><code>import { HolographicCSPSolver } from './reasoning/holographic/csp-hdc-heuristic.mjs';

const solver = new HolographicCSPSolver(session, {
  hdcWeight: 0.7,     // Weight for HDC heuristic
  maxSolutions: 100
});

// Same interface as CSPSolver
solver.addVariable('Alice', ['Table1', 'Table2', 'Table3']);
solver.addVariable('Bob', ['Table1', 'Table2', 'Table3']);
solver.addNoConflict('Alice', 'Bob');

const result = solver.solve();
// HDC guides domain ordering for faster search</code></pre>

  <h4>CSP HDC Heuristics</h4>

  <div class="section-grid">
    <div class="section-card">
      <h4>Constraint Satisfaction Vectors</h4>
      <p>Build HDC vectors representing valid assignment states. Bundle all valid configurations.</p>
      <pre><code>// Valid state: Alice at T1, Bob at T2
const state = bind(
  bind(AliceVec, Table1Vec),
  bind(BobVec, Table2Vec)
);
csBundle = bundle([...validStates]);</code></pre>
    </div>

    <div class="section-card">
      <h4>Domain Ordering</h4>
      <p>Order domain values by HDC similarity to constraint satisfaction bundle.</p>
      <pre><code>// Score hypothetical assignment
const score = scoreCandidate(
  session,
  hypotheticalAssignment,
  csBundle
);
// Higher similarity = try first</code></pre>
    </div>

    <div class="section-card">
      <h4>Early Pruning</h4>
      <p>Skip candidates with low similarity to valid states.</p>
      <pre><code>// In backtracking search
if (score < VERIFICATION_THRESHOLD) {
  stats.hdcPruned++;
  continue;  // Skip this branch
}</code></pre>
    </div>
  </div>

  <h2>The HDC Master Equation</h2>

  <div class="alert alert-info" style="background: linear-gradient(135deg, #e3f2fd, #bbdefb);">
    <h4 style="margin-top: 0;">Answer = KB ⊕ Query⁻¹</h4>
    <p>The holographic query equation leverages HDC's algebraic properties:</p>
    <ul>
      <li><strong>KB</strong>: Bundle of all fact vectors</li>
      <li><strong>Query</strong>: Partial pattern with known components</li>
      <li><strong>⊕</strong>: XOR binding operation</li>
      <li><strong>⁻¹</strong>: Inverse (same as original in binary HDC)</li>
    </ul>
    <p style="margin-bottom: 0;">Result vector is similar to the missing component(s).</p>
  </div>

  <pre><code>// For query: "isA Tweety ?what"
// Query vector encodes: operator=isA, pos1=Tweety, pos2=?

const queryPartial = bind(
  isAVec,
  bind(Pos1Vec, TweetyVec)
);

// Unbind from KB to get what's at position 2
const answerVec = unbind(
  unbind(kbBundle, queryPartial),
  Pos2Vec
);

// Find most similar in vocabulary
const candidates = topKSimilar(answerVec, vocabulary, 10);
// → [{ name: 'Bird', similarity: 0.94 }, ...]</code></pre>

  <h2>Synonym-Aware Matching</h2>

  <p>The holographic engine integrates with ComponentKB for semantic matching:</p>

  <pre><code>// KB contains: isA Rex Dog
// Query: isA Rex Canine
// ComponentKB knows: Dog synonymOf Canine

const result = engine.prove(parseGoal("isA Rex Canine"));
// {
//   valid: true,
//   confidence: 0.95,
//   method: 'synonym_match',
//   matchedFact: 'isA Rex Dog',
//   steps: [{ operation: 'synonym_match', synonymUsed: 'Canine <-> Dog' }]
// }</code></pre>

  <h2>Configuration Thresholds</h2>

  <p>HDC thresholds are strategy-dependent (dense-binary vs sparse-polynomial):</p>

  <pre><code>// From constants.mjs - holographic-specific thresholds
const holographicThresholds = {
  // Query unbind
  UNBIND_MIN_SIMILARITY: 0.3,    // Minimum to consider as candidate
  UNBIND_MAX_CANDIDATES: 15,     // Top-K limit

  // Proof search
  HDC_MATCH: 0.85,               // Direct KB match threshold
  CONCLUSION_MATCH: 0.7,         // Rule conclusion similarity
  VERIFICATION: 0.6,             // Symbolic validation threshold

  // Behavior flags
  FALLBACK_TO_SYMBOLIC: true,    // Allow symbolic fallback
  VALIDATION_REQUIRED: true      // Require symbolic validation
};</code></pre>

  <h2>Statistics Tracking</h2>

  <p>Additional stats specific to holographic mode:</p>

  <pre><code>session.reasoningStats = {
  // HDC queries
  holographicQueries: 0,
  hdcUnbindAttempts: 0,
  hdcUnbindSuccesses: 0,

  // HDC proofs
  holographicProofs: 0,
  hdcProofSuccesses: 0,

  // Validation
  hdcValidationAttempts: 0,
  hdcValidationSuccesses: 0,

  // Fallbacks
  symbolicProofFallbacks: 0,

  // CSP
  holographicCSP: 0,
  cspBundleBuilt: 0,
  cspSymbolicFallback: 0
};</code></pre>

  <h2>Transitive Chain Discovery</h2>

  <p>HDC-guided BFS for transitive relations:</p>

  <pre><code>// Finding: isA Tweety Animal
// KB: isA Tweety Bird, isA Bird Animal

// 1. Start at Tweety, find HDC-similar "isA Tweety ?" edges
const edges = findHDCEdges('isA', 'Tweety');
// → [{ to: 'Bird', similarity: 0.96 }]

// 2. BFS continues from Bird
const edges2 = findHDCEdges('isA', 'Bird');
// → [{ to: 'Animal', similarity: 0.95 }]

// 3. Found target! Build chain
const chain = [
  { from: 'Tweety', to: 'Bird', similarity: 0.96 },
  { from: 'Bird', to: 'Animal', similarity: 0.95 }
];

// 4. Validate each step symbolically
for (const step of chain) {
  if (!symbolicEngine.prove(`isA ${step.from} ${step.to}`).valid) {
    return { valid: false };
  }
}

// 5. Return validated chain proof
return {
  valid: true,
  confidence: computeChainConfidence(chain.length),
  method: 'hdc_transitive_validated',
  steps: chain.map(...)
};</code></pre>

  <h2>Comparison with Symbolic Engine</h2>

  <table class="matrix-table">
    <tr>
      <th>Aspect</th>
      <th>Symbolic</th>
      <th>Holographic</th>
    </tr>
    <tr>
      <td>Primary mechanism</td>
      <td>Rule/pattern matching</td>
      <td>Vector similarity</td>
    </tr>
    <tr>
      <td>Search strategy</td>
      <td>Priority-ordered strategies</td>
      <td>HDC candidates + validation</td>
    </tr>
    <tr>
      <td>KB access pattern</td>
      <td>Targeted lookups</td>
      <td>Bundle similarity scan</td>
    </tr>
    <tr>
      <td>False positive risk</td>
      <td>None (exact match)</td>
      <td>Mitigated by validation</td>
    </tr>
    <tr>
      <td>Fuzzy matching</td>
      <td>Limited (synonyms only)</td>
      <td>Native (similarity)</td>
    </tr>
    <tr>
      <td>CSP heuristics</td>
      <td>Standard backtracking</td>
      <td>HDC-guided ordering</td>
    </tr>
    <tr>
      <td>Best for</td>
      <td>Strict correctness</td>
      <td>Large/noisy KBs</td>
    </tr>
  </table>

  <h2>When Holographic Shines</h2>

  <div class="section-grid">
    <div class="section-card" style="border-left: 4px solid #1976d2;">
      <h4>Large Knowledge Bases</h4>
      <p>HDC bundle operations scale sub-linearly. Finding candidates in 100K facts is nearly as fast as 1K facts.</p>
    </div>

    <div class="section-card" style="border-left: 4px solid #1976d2;">
      <h4>Noisy/Incomplete Data</h4>
      <p>Similarity-based search finds relevant facts even with spelling variations or incomplete information.</p>
    </div>

    <div class="section-card" style="border-left: 4px solid #1976d2;">
      <h4>Similarity Queries</h4>
      <p>Native support for "find things similar to X" without explicit rules.</p>
    </div>

    <div class="section-card" style="border-left: 4px solid #1976d2;">
      <h4>Complex CSP Problems</h4>
      <p>HDC heuristics can dramatically reduce search space in constraint satisfaction.</p>
    </div>
  </div>

  <h2>Limitations</h2>

  <ul>
    <li><strong>Validation overhead</strong>: Each HDC candidate requires symbolic proof</li>
    <li><strong>Memory usage</strong>: KB bundle and candidate sets consume memory</li>
    <li><strong>Threshold sensitivity</strong>: Results depend on similarity thresholds</li>
    <li><strong>Not always faster</strong>: For small KBs, symbolic may be quicker</li>
  </ul>

  <div class="alert alert-warning">
    <strong>Important:</strong> Holographic mode doesn't replace symbolic reasoning. It accelerates candidate discovery while relying on symbolic validation for correctness guarantees.
  </div>

  <h2>Example: Complete HDC Proof Trace</h2>

  <pre><code>// Query: prove "can Tweety Fly"
// KB: isA Tweety Bird, can Bird Fly

const result = engine.prove(parseGoal("can Tweety Fly"));

// Trace:
// 1. Build goal vector: bind(canVec, bind(Pos1, TweetyVec), bind(Pos2, FlyVec))
// 2. HDC direct search: best similarity = 0.72 (below threshold)
// 3. Synonym check: no synonyms for 'can'
// 4. HDC rule search:
//    - Found rule: "If isA ?x Bird Then can ?x Fly"
//    - Conclusion similarity: 0.89
//    - Check condition "isA Tweety Bird": HDC finds it (0.96)
//    - Validate condition symbolically: ✓
// 5. Validate rule application symbolically: ✓

// Result:
{
  valid: true,
  confidence: 0.85,
  method: 'hdc_rule_validated',
  goal: 'can Tweety Fly',
  rule: 'BirdCanFly',
  steps: [
    {
      operation: 'rule_application',
      rule: 'BirdCanFly',
      confidence: 0.85
    }
  ],
  reasoningSteps: 4
}</code></pre>

  <div class="footer-nav">
    <p><a href="symbolic.html">&larr; Symbolic Reasoning Engine</a></p>
    <p><a href="index.html">&larr; Back to Reasoning Overview</a></p>
  </div>
  </div>
</body>
</html>
