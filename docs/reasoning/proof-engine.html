<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proof Engine - AGISystem2</title>
  <link rel="stylesheet" href="../reference/style.css">
  <style>
    .math-box { background: #e3f2fd; border-left: 4px solid #1976d2; padding: 15px 20px; margin: 15px 0; border-radius: 0 8px 8px 0; }
    .algorithm-box { background: #f3e5f5; border-left: 4px solid #9c27b0; padding: 15px 20px; margin: 15px 0; border-radius: 0 8px 8px 0; }
    .example-box { background: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px 20px; margin: 15px 0; border-radius: 0 8px 8px 0; }
    h2 { border-bottom: 2px solid #1976d2; padding-bottom: 10px; margin-top: 40px; }
    .equation { text-align: center; font-size: 18px; margin: 20px 0; font-family: 'Times New Roman', serif; }
  </style>
</head>
<body>
  <div class="page">
  <div class="nav-header">
    <h1>Proof Engine <span class="badge badge-success">Core</span></h1>
    <small>
      <a href="../index.html">Home</a> ·
      <a href="index.html">Reasoning</a> ·
      <a href="symbolic.html">Symbolic</a> ·
      <a href="holographic.html">Holographic</a>
    </small>
    <small>Backward chaining proof search with confidence tracking</small>
  </div>

  <div class="section-intro">
    <p>The Proof Engine implements <strong>goal-directed backward chaining</strong> to establish whether a proposition can be derived from the knowledge base. It returns not just a boolean result, but a complete <strong>proof trace</strong> with confidence scores.</p>
  </div>

  <h2>1. Theoretical Foundation</h2>

  <div class="math-box">
    <p><strong>Goal:</strong> Given a goal G and knowledge base KB, determine if KB ⊢ G (KB entails G).</p>
    <p><strong>Approach:</strong> Backward chaining - start from the goal and work backward to known facts.</p>
    <div class="equation">
      prove(G) = match(G, KB) ∨ ∃rule(P → G) : prove(P)
    </div>
    <p>A goal is proven if it directly matches a KB fact, or if there exists a rule whose consequent matches G and whose premises can all be proven.</p>
  </div>

  <h2>2. Proof Search Algorithm</h2>

  <div style="background: #f8f9fa; padding: 25px; border-radius: 12px; margin: 20px 0;">
    <svg viewBox="0 0 700 380" style="width: 100%; max-width: 800px; display: block; margin: 0 auto;">
      <!-- Title -->
      <text x="350" y="25" text-anchor="middle" font-size="15" font-weight="bold" fill="#333">Backward Chaining Proof Search</text>

      <!-- Goal node -->
      <rect x="275" y="45" width="150" height="40" rx="6" fill="url(#goalGrad)" stroke="#1565c0" stroke-width="2"/>
      <text x="350" y="70" text-anchor="middle" font-size="12" fill="white" font-weight="bold">Goal: prove(G)</text>

      <!-- Branch arrow -->
      <path d="M350 85 L350 110" stroke="#546e7a" stroke-width="2" marker-end="url(#proofArrow)"/>

      <!-- Decision diamond -->
      <polygon points="350,115 420,155 350,195 280,155" fill="#fff3e0" stroke="#ef6c00" stroke-width="2"/>
      <text x="350" y="160" text-anchor="middle" font-size="10" fill="#e65100">Direct KB</text>
      <text x="350" y="172" text-anchor="middle" font-size="10" fill="#e65100">Match?</text>

      <!-- Yes path -->
      <path d="M420 155 L480 155" stroke="#4caf50" stroke-width="2" marker-end="url(#proofArrowGreen)"/>
      <text x="445" y="148" font-size="10" fill="#4caf50">Yes</text>
      <rect x="485" y="135" width="100" height="40" rx="6" fill="#4caf50"/>
      <text x="535" y="160" text-anchor="middle" font-size="11" fill="white" font-weight="bold">SUCCESS</text>

      <!-- No path -->
      <path d="M350 195 L350 220" stroke="#c62828" stroke-width="2"/>
      <text x="360" y="210" font-size="10" fill="#c62828">No</text>

      <!-- Find rules -->
      <rect x="250" y="225" width="200" height="35" rx="6" fill="#7b1fa2"/>
      <text x="350" y="247" text-anchor="middle" font-size="11" fill="white">Find rules: P → G</text>

      <!-- Loop arrow -->
      <path d="M350 260 L350 285" stroke="#546e7a" stroke-width="2" marker-end="url(#proofArrow)"/>

      <!-- For each rule -->
      <rect x="200" y="290" width="300" height="35" rx="6" fill="#1976d2"/>
      <text x="350" y="312" text-anchor="middle" font-size="11" fill="white">For each rule: prove(premise)</text>

      <!-- Recursive arrow -->
      <path d="M200 307 L150 307 L150 70 L275 70" stroke="#1976d2" stroke-width="2" stroke-dasharray="5,3" marker-end="url(#proofArrowBlue)"/>
      <text x="130" y="190" font-size="9" fill="#1565c0" transform="rotate(-90, 130, 190)">Recurse</text>

      <!-- No rules path -->
      <path d="M500 307 L550 307 L550 350 L350 350" stroke="#c62828" stroke-width="2" marker-end="url(#proofArrowRed)"/>
      <rect x="280" y="335" width="140" height="30" rx="6" fill="#c62828"/>
      <text x="350" y="355" text-anchor="middle" font-size="11" fill="white" font-weight="bold">FAILURE</text>

      <!-- Defs -->
      <defs>
        <linearGradient id="goalGrad" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" stop-color="#1565c0"/>
          <stop offset="100%" stop-color="#42a5f5"/>
        </linearGradient>
        <marker id="proofArrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#546e7a"/>
        </marker>
        <marker id="proofArrowGreen" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#4caf50"/>
        </marker>
        <marker id="proofArrowBlue" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#1976d2"/>
        </marker>
        <marker id="proofArrowRed" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#c62828"/>
        </marker>
      </defs>
    </svg>
  </div>

  <div class="algorithm-box">
    <strong>Algorithm: prove(goal, kb, depth, visited)</strong>
    <ol>
      <li><strong>Base cases:</strong>
        <ul>
          <li>If depth > MAX_DEPTH → return FAIL (prevent infinite loops)</li>
          <li>If goal ∈ visited → return FAIL (cycle detection)</li>
        </ul>
      </li>
      <li><strong>Direct match:</strong> Search KB for facts matching goal
        <ul>
          <li>If exact match found → return SUCCESS with confidence 1.0</li>
          <li>If similar match (≥ threshold) → return SUCCESS with similarity score</li>
        </ul>
      </li>
      <li><strong>Transitive chains:</strong> For transitive relations (isA, partOf, locatedIn)
        <ul>
          <li>Search for chains: X rel Y, Y rel Z → X rel Z</li>
          <li>Confidence decays: c_chain = c₁ × c₂ × α</li>
        </ul>
      </li>
      <li><strong>Rule matching:</strong> Find rules whose consequent unifies with goal
        <ul>
          <li>For each matching rule R: (P₁ ∧ P₂ ∧ ... ∧ Pₙ) → G</li>
          <li>Recursively prove each premise Pᵢ</li>
          <li>If all premises proven → SUCCESS</li>
          <li>Confidence: c_rule = min(c_p₁, ..., c_pₙ) × rule_confidence</li>
        </ul>
      </li>
      <li><strong>Failure:</strong> If no method succeeds → return FAIL</li>
    </ol>
  </div>

  <h2>3. Confidence Model</h2>

  <p>Every proof step produces a confidence score between 0 and 1:</p>

  <table>
    <tr>
      <th>Proof Method</th>
      <th>Confidence Formula</th>
      <th>Typical Range</th>
    </tr>
    <tr>
      <td><strong>Direct KB match</strong></td>
      <td>similarity(goal, fact)</td>
      <td>0.95 - 1.0</td>
    </tr>
    <tr>
      <td><strong>Transitive chain (n steps)</strong></td>
      <td>∏ᵢ cᵢ × α^(n-1)</td>
      <td>0.7 - 0.95</td>
    </tr>
    <tr>
      <td><strong>Rule application</strong></td>
      <td>min(c_premises) × c_rule</td>
      <td>0.6 - 0.9</td>
    </tr>
    <tr>
      <td><strong>Weak/fuzzy match</strong></td>
      <td>similarity × β</td>
      <td>0.4 - 0.7</td>
    </tr>
  </table>

  <div class="math-box">
    <strong>Confidence Decay Parameter (α):</strong> Controls how quickly confidence decays in chains.
    <div class="equation">
      α = 0.95 (default)
    </div>
    <p>For a 3-step chain with all steps at 1.0 confidence: 1.0 × 1.0 × 1.0 × 0.95² = 0.9025</p>
  </div>

  <h2>4. Proof Trace Structure</h2>

  <p>The engine returns a complete proof trace for debugging and explanation:</p>

  <pre><code>{
  success: true,
  goal: { operator: 'isA', args: ['Socrates', 'Mortal'] },
  method: 'rule_application',
  confidence: 0.95,
  rule: '@r1: Implies (isA ?x Human) (isA ?x Mortal)',
  bindings: { '?x': 'Socrates' },
  premises: [
    {
      success: true,
      goal: { operator: 'isA', args: ['Socrates', 'Human'] },
      method: 'direct_kb',
      confidence: 1.0,
      matchedFact: 'isA Socrates Human'
    }
  ],
  depth: 1,
  steps: 2
}</code></pre>

  <h2>5. Unification</h2>

  <div class="math-box">
    <p><strong>Unification</strong> finds substitutions that make two expressions identical:</p>
    <div class="equation">
      unify(isA ?x Human, isA Socrates Human) = { ?x → Socrates }
    </div>
    <p>Variables (prefixed with ?) can match any term. Constants must match exactly.</p>
  </div>

  <table>
    <tr>
      <th>Expression 1</th>
      <th>Expression 2</th>
      <th>Unification Result</th>
    </tr>
    <tr>
      <td><code>loves ?x Mary</code></td>
      <td><code>loves John Mary</code></td>
      <td>{ ?x → John }</td>
    </tr>
    <tr>
      <td><code>isA ?x ?y</code></td>
      <td><code>isA Cat Animal</code></td>
      <td>{ ?x → Cat, ?y → Animal }</td>
    </tr>
    <tr>
      <td><code>isA Dog ?x</code></td>
      <td><code>isA Cat Animal</code></td>
      <td>FAIL (Dog ≠ Cat)</td>
    </tr>
  </table>

  <h2>6. Compound Goals</h2>

  <p>The proof engine handles compound logical structures:</p>

  <div class="example-box">
    <strong>And:</strong> All subgoals must be proven
    <pre><code>prove(And(P, Q)) = prove(P) ∧ prove(Q)
confidence = min(c_P, c_Q)</code></pre>
  </div>

  <div class="example-box">
    <strong>Or:</strong> At least one subgoal must be proven
    <pre><code>prove(Or(P, Q)) = prove(P) ∨ prove(Q)
confidence = max(c_P, c_Q)</code></pre>
  </div>

  <div class="example-box">
    <strong>Not:</strong> Negation-as-failure (Closed World Assumption)
    <pre><code>prove(Not(P)) = ¬prove(P)
confidence = 1.0 - c_P (if P provable)
confidence = 1.0 (if P not provable)</code></pre>
  </div>

  <h2>7. Optimization Strategies</h2>

  <table>
    <tr>
      <th>Strategy</th>
      <th>Description</th>
      <th>Impact</th>
    </tr>
    <tr>
      <td><strong>Memoization</strong></td>
      <td>Cache proven/failed goals</td>
      <td>Avoids redundant proof attempts</td>
    </tr>
    <tr>
      <td><strong>Depth limiting</strong></td>
      <td>Max recursion depth (default: 20)</td>
      <td>Prevents infinite loops</td>
    </tr>
    <tr>
      <td><strong>Cycle detection</strong></td>
      <td>Track visited goals in current path</td>
      <td>Detects circular proofs</td>
    </tr>
    <tr>
      <td><strong>Rule ordering</strong></td>
      <td>Try more specific rules first</td>
      <td>Finds proofs faster</td>
    </tr>
    <tr>
      <td><strong>HDC pre-filtering</strong></td>
      <td>Use similarity to find candidates</td>
      <td>Reduces search space</td>
    </tr>
  </table>

  <h2>8. Example: Syllogism Proof</h2>

  <div class="example-box">
    <strong>Knowledge Base:</strong>
    <pre><code>isA Socrates Human
@r1 Implies (isA ?x Human) (isA ?x Mortal)</code></pre>

    <strong>Goal:</strong> <code>prove(isA Socrates Mortal)</code>

    <strong>Proof Trace:</strong>
    <ol>
      <li>Goal: isA Socrates Mortal</li>
      <li>Direct KB search → No match</li>
      <li>Find rules with consequent matching goal:
        <ul>
          <li>Rule @r1: Implies (isA ?x Human) (isA ?x Mortal)</li>
          <li>Unify: { ?x → Socrates }</li>
        </ul>
      </li>
      <li>Prove premise: isA Socrates Human
        <ul>
          <li>Direct KB match → SUCCESS (confidence: 1.0)</li>
        </ul>
      </li>
      <li>All premises proven → Apply rule</li>
      <li><strong>Result:</strong> SUCCESS (confidence: 0.95)</li>
    </ol>
  </div>

  <h2>9. API Reference</h2>

  <pre><code>import { ProofEngine } from 'agisystem2/reasoning';

const engine = new ProofEngine(session);

// Prove a goal
const result = await engine.prove({
  operator: 'isA',
  args: ['Socrates', 'Mortal']
});

// With options
const result = await engine.prove(goal, {
  maxDepth: 10,           // Limit recursion
  minConfidence: 0.5,     // Reject weak proofs
  includeTrace: true,     // Full proof trace
  timeout: 5000           // Max time (ms)
});</code></pre>

  <h2>10. Related Documentation</h2>

  <ul>
    <li><a href="query-engine.html">Query Engine</a> – Finding answers with holes</li>
    <li><a href="abduction.html">Abduction Engine</a> – Finding explanations</li>
    <li><a href="symbolic.html">Symbolic Reasoning</a> – Full symbolic engine</li>
    <li><a href="holographic.html">Holographic Reasoning</a> – HDC-first proofs</li>
  </ul>

  <div class="footer-nav">
    <p><a href="index.html">&larr; Back to Reasoning Engines</a></p>
  </div>
  </div>
</body>
</html>
