# Math - Missing Concepts
# Auto-generated concept definitions

@a:a graph
    # Concept: a
    @entity __Entity a
    return $entity
end

@b:b graph
    # Concept: b
    @entity __Entity b
    return $entity
end

@g:g graph
    # Concept: g
    @entity __Entity g
    return $entity
end

# =============================================================================
# MATHEMATICS DOMAIN THEORY - WITH PROPER MULTI-LINE GRAPH SYNTAX
# =============================================================================
# 1000+ statements using @:Name graph ... end for theorems/axioms
# ============================================================================
# Math Stress Test - Domain-Specific Vocabulary
# AUTO-GENERATED: Definitions for operators used in this test
# ============================================================================

@E:E graph a b
    # Expected value
    @variable __Role Attribute $a
    @distribution __Role Attribute $b
    @relation __Pair $variable $distribution
    return $relation
end

@P:P graph a b
    # Probability of event
    @eid __Event
    @act __Role Action P
    @ctx __Role Context StressCompat
    @event __Role Action $a
    @space __Role Attribute $b
    @probability __Role Context ProbabilitySpace
    @result __Bundle $eid $act $event $space $probability $ctx
    return $result
end

@Var:Var graph a b
    # Variance of random variable
    @variable __Role Attribute $a
    @distribution __Role Attribute $b
    @relation __Pair $variable $distribution
    return $relation
end

@abs:abs graph input output
    @inp __Role Attribute $input
    @out __Role Attribute $output
    @operation __Pair $inp $out
    return $operation
end

@actsOn:actsOn graph a b
    # Group action on set
    @group __Role Group $a
    @set __Role Attribute $b
    @relation __Pair $group $set
    return $relation
end

@additiveGroup:additiveGroup graph a b
    # Additive group structure
    @structure __Role Structure $a
    @operation __Role Attribute $b
    @relation __Pair $structure $operation
    return $relation
end

@allZero:allZero graph a b
    # All elements are zero
    @sequence __Role Attribute $a
    @range __Role Attribute $b
    @relation __Pair $sequence $range
    return $relation
end

@alternateInterior:alternateInterior graph a b
    # Alternate interior angles
    @eid __Event
    @act __Role Action alternateInterior
    @ctx __Role Context StressCompat
    @angle1 __Role Attribute $a
    @angle2 __Role Attribute $b
    @geometry __Role Context GeometricRelation
    @result __Bundle $eid $act $angle1 $angle2 $geometry $ctx
    return $result
end

@angle:angle graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@angle1:angle1 graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@angle2:angle2 graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@angle3:angle3 graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@apply:apply graph a b
    # Function application
    @eid __Event
    @act __Role Action apply
    @ctx __Role Context StressCompat
    @function __Role Function $a
    @argument __Role Content $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $function $argument $application $ctx
    return $result
end

@areIID:areIID graph a b
    # Independent identically distributed
    @variables __Role Attribute $a
    @distribution __Role Attribute $b
    @relation __Pair $variables $distribution
    return $relation
end

@area:area graph a b
    # Area of geometric figure
    @figure __Role Attribute $a
    @measure __Role Attribute $b
    @relation __Pair $figure $measure
    return $relation
end

@attainsMaximum:attainsMaximum graph a b
    # Function attains maximum
    @eid __Event
    @act __Role Action attainsMaximum
    @ctx __Role Context StressCompat
    @function __Role Function $a
    @point __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $function $point $application $ctx
    return $result
end

@attainsMinimum:attainsMinimum graph a b
    # Function attains minimum
    @eid __Event
    @act __Role Action attainsMinimum
    @ctx __Role Context StressCompat
    @function __Role Function $a
    @point __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $function $point $application $ctx
    return $result
end

@averageFixedPoints:averageFixedPoints graph a b
    # Average number of fixed points
    @permutations __Role Attribute $a
    @set __Role Attribute $b
    @relation __Pair $permutations $set
    return $relation
end

@base:base graph a b
    # Base of geometric figure
    @figure __Role Attribute $a
    @segment __Role Attribute $b
    @relation __Pair $figure $segment
    return $relation
end

@binomial:binomial graph a b
    # Binomial coefficient C(n,k)
    @n __Role Attribute $a
    @k __Role Attribute $b
    @relation __Pair $n $k
    return $relation
end

@binomialSum:binomialSum graph a b
    # Sum of binomial terms
    @terms __Role Attribute $a
    @power __Role Attribute $b
    @relation __Pair $terms $power
    return $relation
end

@canExtend:canExtend graph a b
    # Structure can be extended
    @structure __Role Structure $a
    @extension __Role Attribute $b
    @relation __Pair $structure $extension
    return $relation
end

@cardinality:cardinality graph set result
    @s __Role Attribute $set
    @r __Role Result $result
    @operation __Pair $s $r
    return $operation
end

@characteristicPolynomial:characteristicPolynomial graph a b
    # Characteristic polynomial
    @matrix __Role Attribute $a
    @variable __Role Attribute $b
    @relation __Pair $matrix $variable
    return $relation
end

@circleWith:circleWith graph a b
    # Circle with center and radius
    @center __Role Attribute $a
    @radius __Role Attribute $b
    @relation __Pair $center $radius
    return $relation
end

@circumference:circumference graph a b
    # Circumference of circle
    @circle __Role Attribute $a
    @measure __Role Attribute $b
    @relation __Pair $circle $measure
    return $relation
end

@closedInterval:closedInterval graph a b
    # Closed interval [a, b]
    @lower __Role Attribute $a
    @upper __Role Attribute $b
    @relation __Pair $lower $upper
    return $relation
end

@coInterior:coInterior graph a b
    # Co-interior angles
    @eid __Event
    @act __Role Action coInterior
    @ctx __Role Context StressCompat
    @angle1 __Role Attribute $a
    @angle2 __Role Attribute $b
    @geometry __Role Context GeometricRelation
    @result __Bundle $eid $act $angle1 $angle2 $geometry $ctx
    return $result
end

@complement:complement graph input output
    @inp __Role Attribute $input
    @out __Role Attribute $output
    @operation __Pair $inp $out
    return $operation
end

@compose:compose graph a b
    # Function composition
    @eid __Event
    @act __Role Action compose
    @ctx __Role Context StressCompat
    @outer __Role Attribute $a
    @inner __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $outer $inner $application $ctx
    return $result
end

@conditionalP:conditionalP graph a b
    # Conditional probability P(A|B)
    @eid __Event
    @act __Role Action conditionalP
    @ctx __Role Context StressCompat
    @eventA __Role Attribute $a
    @eventB __Role Attribute $b
    @probability __Role Context ProbabilitySpace
    @result __Bundle $eid $act $eventA $eventB $probability $ctx
    return $result
end

@congruent:congruent graph a b
    # Congruent figures
    @figure1 __Role Attribute $a
    @figure2 __Role Attribute $b
    @relation __Pair $figure1 $figure2
    return $relation
end

@containsConstants:containsConstants graph a b
    # Expression contains constants
    @expression __Role Content $a
    @constants __Role Attribute $b
    @relation __Pair $expression $constants
    return $relation
end

@continuousFunctions:continuousFunctions graph a b
    # Space of continuous functions
    @eid __Event
    @act __Role Action continuousFunctions
    @ctx __Role Context StressCompat
    @domain __Role Context $a
    @codomain __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $domain $codomain $application $ctx
    return $result
end

@convergesInDistribution:convergesInDistribution graph function point value
    @eid __Event
    @act __Role Action convergesInDistribution
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@convergesInProbability:convergesInProbability graph function point value
    @eid __Event
    @act __Role Action convergesInProbability
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@convergesPointwise:convergesPointwise graph function point value
    @eid __Event
    @act __Role Action convergesPointwise
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@coprime:coprime graph a b
    # Coprime numbers (gcd = 1)
    @number1 __Role Attribute $a
    @number2 __Role Attribute $b
    @relation __Pair $number1 $number2
    return $relation
end

@corresponding:corresponding graph a b
    # Corresponding angles
    @eid __Event
    @act __Role Action corresponding
    @ctx __Role Context StressCompat
    @angle1 __Role Attribute $a
    @angle2 __Role Attribute $b
    @geometry __Role Context GeometricRelation
    @result __Bundle $eid $act $angle1 $angle2 $geometry $ctx
    return $result
end

@definiteIntegral:definiteIntegral graph a b
    # Definite integral over interval
    @function __Role Function $a
    @interval __Role Attribute $b
    @relation __Pair $function $interval
    return $relation
end

@degrees:degrees graph a b
    # Angle in degrees
    @eid __Event
    @act __Role Action degrees
    @ctx __Role Context StressCompat
    @angle __Role Attribute $a
    @measure __Role Attribute $b
    @geometry __Role Context GeometricRelation
    @result __Bundle $eid $act $angle $measure $geometry $ctx
    return $result
end

@derivative:derivative graph function point value
    @eid __Event
    @act __Role Action derivative
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@derivativeAt:derivativeAt graph function point value
    @eid __Event
    @act __Role Action derivativeAt
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@derives:derives graph a b
    # Logical derivation
    @premise __Role Attribute $a
    @conclusion __Role Attribute $b
    @relation __Pair $premise $conclusion
    return $relation
end

@dimension:dimension graph a b
    # Dimension of vector space
    @eid __Event
    @act __Role Action dimension
    @ctx __Role Context StressCompat
    @space __Role Attribute $a
    @field __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $space $field $linearAlgebra $ctx
    return $result
end

@disjoint:disjoint graph a b
    # Disjoint sets with no common elements
    @eid __Event
    @act __Role Action disjoint
    @ctx __Role Context StressCompat
    @setA __Role Attribute $a
    @setB __Role Attribute $b
    @membership __Role Action SetMembership
    @result __Bundle $eid $act $setA $setB $membership $ctx
    return $result
end

@distance:distance graph a b
    # Distance between points
    @point1 __Role Attribute $a
    @point2 __Role Attribute $b
    @relation __Pair $point1 $point2
    return $relation
end

@divide:divide graph a b
    # Division of dividend by divisor
    @eid __Event
    @act __Role Action divide
    @ctx __Role Context StressCompat
    @dividend __Role Attribute $a
    @divisor __Role Attribute $b
    @division __Role Action Divisibility
    @result __Bundle $eid $act $dividend $divisor $division $ctx
    return $result
end

@divides:divides graph a b
    # Divisor divides dividend evenly
    @eid __Event
    @act __Role Action divides
    @ctx __Role Context StressCompat
    @divisor __Role Attribute $a
    @dividend __Role Attribute $b
    @division __Role Action Divisibility
    @result __Bundle $eid $act $divisor $dividend $division $ctx
    return $result
end

@dominatedBy:dominatedBy graph a b
    # Function dominated by bound
    @eid __Event
    @act __Role Action dominatedBy
    @ctx __Role Context StressCompat
    @function __Role Function $a
    @bound __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $function $bound $application $ctx
    return $result
end

@doubleIntegral:doubleIntegral graph a b
    # Double integral over region
    @function __Role Function $a
    @region __Role Attribute $b
    @relation __Pair $function $region
    return $relation
end

@endpoint1:endpoint1 graph a b
    # First endpoint of segment
    @segment __Role Attribute $a
    @point __Role Attribute $b
    @relation __Pair $segment $point
    return $relation
end

@endpoint2:endpoint2 graph a b
    # Second endpoint of segment
    @segment __Role Attribute $a
    @point __Role Attribute $b
    @relation __Pair $segment $point
    return $relation
end

@eulerPhi:eulerPhi graph a b
    # Euler totient function
    @eid __Event
    @act __Role Action eulerPhi
    @ctx __Role Context StressCompat
    @number __Role Attribute $a
    @totient __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $number $totient $application $ctx
    return $result
end

@evaluateAt:evaluateAt graph a b
    # Function evaluation at point
    @eid __Event
    @act __Role Action evaluateAt
    @ctx __Role Context StressCompat
    @function __Role Function $a
    @point __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $function $point $application $ctx
    return $result
end

@existsBijection:existsBijection graph a b
    # Bijection exists between sets
    @setA __Role Attribute $a
    @setB __Role Attribute $b
    @relation __Pair $setA $setB
    return $relation
end

@existsInjection:existsInjection graph a b
    # Injection exists from A to B
    @setA __Role Attribute $a
    @setB __Role Attribute $b
    @relation __Pair $setA $setB
    return $relation
end

@existsUnique:existsUnique graph a b
    # Unique element satisfying property
    @property __Role Property $a
    @element __Role Attribute $b
    @relation __Pair $property $element
    return $relation
end

@factorial:factorial graph input output
    @inp __Role Attribute $input
    @out __Role Attribute $output
    @operation __Pair $inp $out
    return $operation
end

@functionProduct:functionProduct graph a b
    # Pointwise product of functions
    @eid __Event
    @act __Role Action functionProduct
    @ctx __Role Context StressCompat
    @function1 __Role Attribute $a
    @function2 __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $function1 $function2 $application $ctx
    return $result
end

@functionSum:functionSum graph a b
    # Pointwise sum of functions
    @eid __Event
    @act __Role Action functionSum
    @ctx __Role Context StressCompat
    @function1 __Role Attribute $a
    @function2 __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $function1 $function2 $application $ctx
    return $result
end

@gcd:gcd graph a b
    # Greatest common divisor
    @number1 __Role Attribute $a
    @number2 __Role Attribute $b
    @relation __Pair $number1 $number2
    return $relation
end

@generatedBy:generatedBy graph a b
    # Structure generated by elements
    @structure __Role Structure $a
    @generators __Role Attribute $b
    @relation __Pair $structure $generators
    return $relation
end

@geq:geq graph a b
    # Greater than or equal relation
    @number __Role Attribute $a
    @bound __Role Attribute $b
    @relation __Pair $number $bound
    return $relation
end

@hasBoundAbove:hasBoundAbove graph entity
    @e __Role Entity $entity
    @property __Role Property hasBoundAbove
    @check __Pair $e $property
    return $check
end

@hasCodomain:hasCodomain graph entity
    @e __Role Entity $entity
    @property __Role Property hasCodomain
    @check __Pair $e $property
    return $check
end

@hasConvergentSubsequence:hasConvergentSubsequence graph entity
    @e __Role Entity $entity
    @property __Role Property hasConvergentSubsequence
    @check __Pair $e $property
    return $check
end

@hasDerivativeOfOrder:hasDerivativeOfOrder graph entity
    @e __Role Entity $entity
    @property __Role Property hasDerivativeOfOrder
    @check __Pair $e $property
    return $check
end

@hasDomain:hasDomain graph entity
    @e __Role Entity $entity
    @property __Role Property hasDomain
    @check __Pair $e $property
    return $check
end

@hasFiniteExpectation:hasFiniteExpectation graph entity
    @e __Role Entity $entity
    @property __Role Property hasFiniteExpectation
    @check __Pair $e $property
    return $check
end

@hasFiniteMean:hasFiniteMean graph entity
    @e __Role Entity $entity
    @property __Role Property hasFiniteMean
    @check __Pair $e $property
    return $check
end

@hasFiniteVariance:hasFiniteVariance graph entity
    @e __Role Entity $entity
    @property __Role Property hasFiniteVariance
    @check __Pair $e $property
    return $check
end

@hasOrthonormalEigenbasis:hasOrthonormalEigenbasis graph entity
    @e __Role Entity $entity
    @property __Role Property hasOrthonormalEigenbasis
    @check __Pair $e $property
    return $check
end

@hasRealEigenvalues:hasRealEigenvalues graph entity
    @e __Role Entity $entity
    @property __Role Property hasRealEigenvalues
    @check __Pair $e $property
    return $check
end

@height:height graph a b
    # Height of figure
    @figure __Role Attribute $a
    @measure __Role Attribute $b
    @relation __Pair $figure $measure
    return $relation
end

@holds:holds graph a b
    # Property holds for object
    @property __Role Property $a
    @object __Role Theme $b
    @relation __Pair $property $object
    return $relation
end

@hypotenuse:hypotenuse graph a b
    # Hypotenuse of right triangle
    @eid __Event
    @act __Role Action hypotenuse
    @ctx __Role Context StressCompat
    @triangle __Role Attribute $a
    @side __Role Attribute $b
    @geometry __Role Context GeometricRelation
    @result __Bundle $eid $act $triangle $side $geometry $ctx
    return $result
end

@identity:identity graph a b
    # Identity element of structure
    @structure __Role Structure $a
    @element __Role Attribute $b
    @relation __Pair $structure $element
    return $relation
end

@image:image graph a b
    # Image of function
    @eid __Event
    @act __Role Action image
    @ctx __Role Context StressCompat
    @function __Role Function $a
    @domain __Role Context $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $function $domain $application $ctx
    return $result
end

@inDomain:inDomain graph a b
    # Element in function domain
    @eid __Event
    @act __Role Action inDomain
    @ctx __Role Context StressCompat
    @element __Role Attribute $a
    @domain __Role Context $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $element $domain $application $ctx
    return $result
end

@inSigmaAlgebra:inSigmaAlgebra graph a b
    # Set in sigma-algebra
    @set __Role Attribute $a
    @sigmaAlgebra __Role Attribute $b
    @relation __Pair $set $sigmaAlgebra
    return $relation
end

@independent:independent graph a b
    # Independent events
    @eventA __Role Attribute $a
    @eventB __Role Attribute $b
    @relation __Pair $eventA $eventB
    return $relation
end

@innerProduct:innerProduct graph a b
    # Inner product of vectors
    @eid __Event
    @act __Role Action innerProduct
    @ctx __Role Context StressCompat
    @vector1 __Role Attribute $a
    @vector2 __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $vector1 $vector2 $linearAlgebra $ctx
    return $result
end

@integral:integral graph function point value
    @eid __Event
    @act __Role Action integral
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@integralFrom:integralFrom graph function point value
    @eid __Event
    @act __Role Action integralFrom
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@intersection:intersection graph set result
    @s __Role Attribute $set
    @r __Role Result $result
    @operation __Pair $s $r
    return $operation
end

@inverse:inverse graph input output
    @inp __Role Attribute $input
    @out __Role Attribute $output
    @operation __Pair $inp $out
    return $operation
end

@isAbelianGroup:isAbelianGroup graph entity
    @e __Role Entity $entity
    @property __Role Property isAbelianGroup
    @check __Pair $e $property
    return $check
end

@isAntiderivative:isAntiderivative graph entity
    @e __Role Entity $entity
    @property __Role Property isAntiderivative
    @check __Pair $e $property
    return $check
end

@isArbitrary:isArbitrary graph entity
    @e __Role Entity $entity
    @property __Role Property isArbitrary
    @check __Pair $e $property
    return $check
end

@isAssumption:isAssumption graph entity
    @e __Role Entity $entity
    @property __Role Property isAssumption
    @check __Pair $e $property
    return $check
end

@isBasis:isBasis graph entity
    @e __Role Entity $entity
    @property __Role Property isBasis
    @check __Pair $e $property
    return $check
end

@isBetween:isBetween graph entity
    @e __Role Entity $entity
    @property __Role Property isBetween
    @check __Pair $e $property
    return $check
end

@isBounded:isBounded graph entity
    @e __Role Entity $entity
    @property __Role Property isBounded
    @check __Pair $e $property
    return $check
end

@isBoundedSequence:isBoundedSequence graph entity
    @e __Role Entity $entity
    @property __Role Property isBoundedSequence
    @check __Pair $e $property
    return $check
end

@isCauchySequence:isCauchySequence graph entity
    @e __Role Entity $entity
    @property __Role Property isCauchySequence
    @check __Pair $e $property
    return $check
end

@isCentralAngle:isCentralAngle graph entity
    @e __Role Entity $entity
    @property __Role Property isCentralAngle
    @check __Pair $e $property
    return $check
end

@isCircle:isCircle graph entity
    @e __Role Entity $entity
    @property __Role Property isCircle
    @check __Pair $e $property
    return $check
end

@isClosed:isClosed graph entity
    @e __Role Entity $entity
    @property __Role Property isClosed
    @check __Pair $e $property
    return $check
end

@isCompact:isCompact graph entity
    @e __Role Entity $entity
    @property __Role Property isCompact
    @check __Pair $e $property
    return $check
end

@isConstant:isConstant graph entity
    @e __Role Entity $entity
    @property __Role Property isConstant
    @check __Pair $e $property
    return $check
end

@isContinuousAt:isContinuousAt graph entity
    @e __Role Entity $entity
    @property __Role Property isContinuousAt
    @check __Pair $e $property
    return $check
end

@isContinuousOn:isContinuousOn graph entity
    @e __Role Entity $entity
    @property __Role Property isContinuousOn
    @check __Pair $e $property
    return $check
end

@isConvergent:isConvergent graph entity
    @e __Role Entity $entity
    @property __Role Property isConvergent
    @check __Pair $e $property
    return $check
end

@isCyclicGroup:isCyclicGroup graph entity
    @e __Role Entity $entity
    @property __Role Property isCyclicGroup
    @check __Pair $e $property
    return $check
end

@isDiameter:isDiameter graph entity
    @e __Role Entity $entity
    @property __Role Property isDiameter
    @check __Pair $e $property
    return $check
end

@isDifferentiableAt:isDifferentiableAt graph entity
    @e __Role Entity $entity
    @property __Role Property isDifferentiableAt
    @check __Pair $e $property
    return $check
end

@isDifferentiableOn:isDifferentiableOn graph entity
    @e __Role Entity $entity
    @property __Role Property isDifferentiableOn
    @check __Pair $e $property
    return $check
end

@isField:isField graph entity
    @e __Role Entity $entity
    @property __Role Property isField
    @check __Pair $e $property
    return $check
end

@isFiniteDimensional:isFiniteDimensional graph entity
    @e __Role Entity $entity
    @property __Role Property isFiniteDimensional
    @check __Pair $e $property
    return $check
end

@isFiniteGroup:isFiniteGroup graph entity
    @e __Role Entity $entity
    @property __Role Property isFiniteGroup
    @check __Pair $e $property
    return $check
end

@isFunction:isFunction graph entity
    @e __Role Entity $entity
    @property __Role Property isFunction
    @check __Pair $e $property
    return $check
end

@isGroup:isGroup graph entity
    @e __Role Entity $entity
    @property __Role Property isGroup
    @check __Pair $e $property
    return $check
end

@isHomomorphism:isHomomorphism graph entity
    @e __Role Entity $entity
    @property __Role Property isHomomorphism
    @check __Pair $e $property
    return $check
end

@isInjective:isInjective graph entity
    @e __Role Entity $entity
    @property __Role Property isInjective
    @check __Pair $e $property
    return $check
end

@isInnerProductSpace:isInnerProductSpace graph entity
    @e __Role Entity $entity
    @property __Role Property isInnerProductSpace
    @check __Pair $e $property
    return $check
end

@isInscribedAngle:isInscribedAngle graph entity
    @e __Role Entity $entity
    @property __Role Property isInscribedAngle
    @check __Pair $e $property
    return $check
end

@isIntegrable:isIntegrable graph entity
    @e __Role Entity $entity
    @property __Role Property isIntegrable
    @check __Pair $e $property
    return $check
end

@isIsomorphic:isIsomorphic graph entity
    @e __Role Entity $entity
    @property __Role Property isIsomorphic
    @check __Pair $e $property
    return $check
end

@isLength:isLength graph entity
    @e __Role Entity $entity
    @property __Role Property isLength
    @check __Pair $e $property
    return $check
end

@isLine:isLine graph entity
    @e __Role Entity $entity
    @property __Role Property isLine
    @check __Pair $e $property
    return $check
end

@isLineSegment:isLineSegment graph entity
    @e __Role Entity $entity
    @property __Role Property isLineSegment
    @check __Pair $e $property
    return $check
end

@isLinearMap:isLinearMap graph entity
    @e __Role Entity $entity
    @property __Role Property isLinearMap
    @check __Pair $e $property
    return $check
end

@isMidpoint:isMidpoint graph entity
    @e __Role Entity $entity
    @property __Role Property isMidpoint
    @check __Pair $e $property
    return $check
end

@isMonotone:isMonotone graph entity
    @e __Role Entity $entity
    @property __Role Property isMonotone
    @check __Pair $e $property
    return $check
end

@isNormalSubgroup:isNormalSubgroup graph entity
    @e __Role Entity $entity
    @property __Role Property isNormalSubgroup
    @check __Pair $e $property
    return $check
end

@isNormedSpace:isNormedSpace graph entity
    @e __Role Entity $entity
    @property __Role Property isNormedSpace
    @check __Pair $e $property
    return $check
end

@isPartition:isPartition graph entity
    @e __Role Entity $entity
    @property __Role Property isPartition
    @check __Pair $e $property
    return $check
end

@isPoint:isPoint graph entity
    @e __Role Entity $entity
    @property __Role Property isPoint
    @check __Pair $e $property
    return $check
end

@isPolynomial:isPolynomial graph entity
    @e __Role Entity $entity
    @property __Role Property isPolynomial
    @check __Pair $e $property
    return $check
end

@isPrime:isPrime graph entity
    @e __Role Entity $entity
    @property __Role Property isPrime
    @check __Pair $e $property
    return $check
end

@isProbabilitySpace:isProbabilitySpace graph entity
    @e __Role Entity $entity
    @property __Role Property isProbabilitySpace
    @check __Pair $e $property
    return $check
end

@isRandomVariable:isRandomVariable graph entity
    @e __Role Entity $entity
    @property __Role Property isRandomVariable
    @check __Pair $e $property
    return $check
end

@isRational:isRational graph entity
    @e __Role Entity $entity
    @property __Role Property isRational
    @check __Pair $e $property
    return $check
end

@isReal:isReal graph entity
    @e __Role Entity $entity
    @property __Role Property isReal
    @check __Pair $e $property
    return $check
end

@isRightAngle:isRightAngle graph entity
    @e __Role Entity $entity
    @property __Role Property isRightAngle
    @check __Pair $e $property
    return $check
end

@isRightTriangle:isRightTriangle graph entity
    @e __Role Entity $entity
    @property __Role Property isRightTriangle
    @check __Pair $e $property
    return $check
end

@isRing:isRing graph entity
    @e __Role Entity $entity
    @property __Role Property isRing
    @check __Pair $e $property
    return $check
end

@isSequence:isSequence graph entity
    @e __Role Entity $entity
    @property __Role Property isSequence
    @check __Pair $e $property
    return $check
end

@isSet:isSet graph entity
    @e __Role Entity $entity
    @property __Role Property isSet
    @check __Pair $e $property
    return $check
end

@isSetOfVectors:isSetOfVectors graph entity
    @e __Role Entity $entity
    @property __Role Property isSetOfVectors
    @check __Pair $e $property
    return $check
end

@isSquareMatrix:isSquareMatrix graph entity
    @e __Role Entity $entity
    @property __Role Property isSquareMatrix
    @check __Pair $e $property
    return $check
end

@isSubalgebra:isSubalgebra graph entity
    @e __Role Entity $entity
    @property __Role Property isSubalgebra
    @check __Pair $e $property
    return $check
end

@isSubgroup:isSubgroup graph entity
    @e __Role Entity $entity
    @property __Role Property isSubgroup
    @check __Pair $e $property
    return $check
end

@isSymmetricMatrix:isSymmetricMatrix graph entity
    @e __Role Entity $entity
    @property __Role Property isSymmetricMatrix
    @check __Pair $e $property
    return $check
end

@isTriangle:isTriangle graph entity
    @e __Role Entity $entity
    @property __Role Property isTriangle
    @check __Pair $e $property
    return $check
end

@isTrue:isTrue graph entity
    @e __Role Entity $entity
    @property __Role Property isTrue
    @check __Pair $e $property
    return $check
end

@isVectorSpace:isVectorSpace graph entity
    @e __Role Entity $entity
    @property __Role Property isVectorSpace
    @check __Pair $e $property
    return $check
end

@isWitness:isWitness graph entity
    @e __Role Entity $entity
    @property __Role Property isWitness
    @check __Pair $e $property
    return $check
end

@iteratedIntegral:iteratedIntegral graph a b
    # Iterated integral
    @function __Role Function $a
    @bounds __Role Attribute $b
    @relation __Pair $function $bounds
    return $relation
end

@kernel:kernel graph a b
    # Kernel of homomorphism
    @morphism __Role Attribute $a
    @structure __Role Structure $b
    @relation __Pair $morphism $structure
    return $relation
end

@leftCoset:leftCoset graph a b
    # Left coset of subgroup
    @element __Role Attribute $a
    @subgroup __Role Attribute $b
    @relation __Pair $element $subgroup
    return $relation
end

@leg1:leg1 graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@leg2:leg2 graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@legendreSymbol:legendreSymbol graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@length:length graph a b
    # Length of segment
    @segment __Role Attribute $a
    @measure __Role Attribute $b
    @relation __Pair $segment $measure
    return $relation
end

@leq:leq graph a b
    # Less than or equal relation
    @number __Role Attribute $a
    @bound __Role Attribute $b
    @relation __Pair $number $bound
    return $relation
end

@limitAt:limitAt graph function point value
    @eid __Event
    @act __Role Action limitAt
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@limitOf:limitOf graph function point value
    @eid __Event
    @act __Role Action limitOf
    @ctx __Role Context StressCompat
    @f __Role Function $function
    @p __Role Attribute $point
    @v __Role Value $value
    @analysis __Bundle $eid $act $f $p $v $ctx
    return $analysis
end

@lineThrough:lineThrough graph a b
    # Line through two points
    @point1 __Role Attribute $a
    @point2 __Role Attribute $b
    @relation __Pair $point1 $point2
    return $relation
end

@linearComb:linearComb graph a b
    # Linear combination
    @coefficients __Role Attribute $a
    @vectors __Role Attribute $b
    @relation __Pair $coefficients $vectors
    return $relation
end

@linearlyIndependent:linearlyIndependent graph a b
    # Linearly independent vectors
    @eid __Event
    @act __Role Action linearlyIndependent
    @ctx __Role Context StressCompat
    @vectors __Role Attribute $a
    @space __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $vectors $space $linearAlgebra $ctx
    return $result
end

@minimum:minimum graph a b
    # Minimum element of set
    @eid __Event
    @act __Role Action minimum
    @ctx __Role Context StressCompat
    @set __Role Attribute $a
    @element __Role Attribute $b
    @membership __Role Action SetMembership
    @result __Bundle $eid $act $set $element $membership $ctx
    return $result
end

@modulo:modulo graph a b
    # Modulo operation
    @number __Role Attribute $a
    @modulus __Role Attribute $b
    @relation __Pair $number $modulus
    return $relation
end

@multiplicativeInverse:multiplicativeInverse graph a b
    # Multiplicative inverse
    @element __Role Attribute $a
    @structure __Role Structure $b
    @relation __Pair $element $structure
    return $relation
end

@negate:negate graph input output
    @inp __Role Attribute $input
    @out __Role Attribute $output
    @operation __Pair $inp $out
    return $operation
end

@norm:norm graph a b
    # Norm of vector
    @eid __Event
    @act __Role Action norm
    @ctx __Role Context StressCompat
    @vector __Role Attribute $a
    @space __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $vector $space $linearAlgebra $ctx
    return $result
end

@nullity:nullity graph a b
    # Nullity of matrix
    @eid __Event
    @act __Role Action nullity
    @ctx __Role Context StressCompat
    @matrix __Role Attribute $a
    @space __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $matrix $space $linearAlgebra $ctx
    return $result
end

@numberOfOrbits:numberOfOrbits graph a b
    # Number of orbits under action
    @action __Role Action $a
    @set __Role Attribute $b
    @relation __Pair $action $set
    return $relation
end

@onCircle:onCircle graph a b
    # Point on circle
    @point __Role Attribute $a
    @circle __Role Attribute $b
    @relation __Pair $point $circle
    return $relation
end

@onLine:onLine graph a b
    # Point on line
    @point __Role Attribute $a
    @line __Role Attribute $b
    @relation __Pair $point $line
    return $relation
end

@op:op graph a b
    # Operator application
    @eid __Event
    @act __Role Action op
    @ctx __Role Context StressCompat
    @operator __Role Attribute $a
    @operand __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $operator $operand $application $ctx
    return $result
end

@openInterval:openInterval graph a b
    # Open interval (a, b)
    @lower __Role Attribute $a
    @upper __Role Attribute $b
    @relation __Pair $lower $upper
    return $relation
end

@order:order graph a b
    # Order of group element
    @element __Role Attribute $a
    @group __Role Group $b
    @relation __Pair $element $group
    return $relation
end

@orderedPair:orderedPair graph a b
    # Ordered pair (a, b)
    @first __Role Attribute $a
    @second __Role Attribute $b
    @relation __Pair $first $second
    return $relation
end

@pairSet:pairSet graph set result
    @s __Role Attribute $set
    @r __Role Result $result
    @operation __Pair $s $r
    return $operation
end

@parallel:parallel graph a b
    # Parallel lines
    @line1 __Role Attribute $a
    @line2 __Role Attribute $b
    @relation __Pair $line1 $line2
    return $relation
end

@parallelThrough:parallelThrough graph a b
    # Parallel line through point
    @point __Role Attribute $a
    @line __Role Attribute $b
    @relation __Pair $point $line
    return $relation
end

@power:power graph a b
    # Exponentiation: base to exponent
    @base __Role Attribute $a
    @exponent __Role Attribute $b
    @relation __Pair $base $exponent
    return $relation
end

@product:product graph a b
    # Product of two factors
    @factor1 __Role Attribute $a
    @factor2 __Role Attribute $b
    @relation __Pair $factor1 $factor2
    return $relation
end

@productSpace:productSpace graph a b
    # Product of topological spaces
    @space1 __Role Attribute $a
    @space2 __Role Attribute $b
    @relation __Pair $space1 $space2
    return $relation
end

@quotient:quotient graph a b
    # Quotient of division
    @eid __Event
    @act __Role Action quotient
    @ctx __Role Context StressCompat
    @dividend __Role Attribute $a
    @divisor __Role Attribute $b
    @division __Role Action Divisibility
    @result __Bundle $eid $act $dividend $divisor $division $ctx
    return $result
end

@quotientGroup:quotientGroup graph a b
    # Quotient group
    @group __Role Group $a
    @normalSubgroup __Role Attribute $b
    @relation __Pair $group $normalSubgroup
    return $relation
end

@radius:radius graph a b
    # Radius of circle
    @circle __Role Attribute $a
    @length __Role Attribute $b
    @relation __Pair $circle $length
    return $relation
end

@rank:rank graph a b
    # Rank of matrix
    @eid __Event
    @act __Role Action rank
    @ctx __Role Context StressCompat
    @matrix __Role Attribute $a
    @field __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $matrix $field $linearAlgebra $ctx
    return $result
end

@ratio:ratio graph a b
    # Ratio of two quantities
    @numerator __Role Attribute $a
    @denominator __Role Attribute $b
    @relation __Pair $numerator $denominator
    return $relation
end

@remainder:remainder graph a b
    # Remainder after division
    @eid __Event
    @act __Role Action remainder
    @ctx __Role Context StressCompat
    @dividend __Role Attribute $a
    @divisor __Role Attribute $b
    @division __Role Action Divisibility
    @result __Bundle $eid $act $dividend $divisor $division $ctx
    return $result
end

@rightCoset:rightCoset graph a b
    # Right coset of subgroup
    @subgroup __Role Attribute $a
    @element __Role Attribute $b
    @relation __Pair $subgroup $element
    return $relation
end

@sameArc:sameArc graph a b
    # Angles subtending same arc
    @eid __Event
    @act __Role Action sameArc
    @ctx __Role Context StressCompat
    @angle1 __Role Attribute $a
    @angle2 __Role Attribute $b
    @geometry __Role Context GeometricRelation
    @result __Bundle $eid $act $angle1 $angle2 $geometry $ctx
    return $result
end

@sampleMean:sampleMean graph a b
    # Sample mean
    @sample __Role Attribute $a
    @size __Role Attribute $b
    @relation __Pair $sample $size
    return $relation
end

@scalarMult:scalarMult graph a b
    # Scalar multiplication
    @scalar __Role Attribute $a
    @vector __Role Attribute $b
    @relation __Pair $scalar $vector
    return $relation
end

@segment:segment graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@separatesPoints:separatesPoints graph a b
    # Function family separates points
    @eid __Event
    @act __Role Action separatesPoints
    @ctx __Role Context StressCompat
    @family __Role Attribute $a
    @space __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $family $space $application $ctx
    return $result
end

@setOfSize:setOfSize graph set result
    @s __Role Attribute $set
    @r __Role Result $result
    @operation __Pair $s $r
    return $operation
end

@side:side graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@side1:side1 graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@side2:side2 graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@sideA:sideA graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@sideB:sideB graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@sideC:sideC graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@spans:spans graph a b
    # Vectors span space
    @eid __Event
    @act __Role Action spans
    @ctx __Role Context StressCompat
    @vectors __Role Attribute $a
    @space __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $vectors $space $linearAlgebra $ctx
    return $result
end

@sqrt:sqrt graph input output
    @inp __Role Attribute $input
    @out __Role Attribute $output
    @operation __Pair $inp $out
    return $operation
end

@square:square graph input output
    @inp __Role Attribute $input
    @out __Role Attribute $output
    @operation __Pair $inp $out
    return $operation
end

@standardizedSum:standardizedSum graph a b
    # Standardized sum
    @variables __Role Attribute $a
    @count __Role Attribute $b
    @relation __Pair $variables $count
    return $relation
end

@subtract:subtract graph a b
    # Subtraction: minuend - subtrahend
    @minuend __Role Attribute $a
    @subtrahend __Role Attribute $b
    @relation __Pair $minuend $subtrahend
    return $relation
end

@sum:sum graph a b
    # Sum of two addends
    @addend1 __Role Attribute $a
    @addend2 __Role Attribute $b
    @relation __Pair $addend1 $addend2
    return $relation
end

@supplementary:supplementary graph a b
    # Supplementary angles
    @eid __Event
    @act __Role Action supplementary
    @ctx __Role Context StressCompat
    @angle1 __Role Attribute $a
    @angle2 __Role Attribute $b
    @geometry __Role Context GeometricRelation
    @result __Bundle $eid $act $angle1 $angle2 $geometry $ctx
    return $result
end

@supremum:supremum graph a b
    # Supremum (least upper bound)
    @set __Role Attribute $a
    @bound __Role Attribute $b
    @relation __Pair $set $bound
    return $relation
end

@symmetricDiff:symmetricDiff graph a b
    # Symmetric difference of sets
    @setA __Role Attribute $a
    @setB __Role Attribute $b
    @relation __Pair $setA $setB
    return $relation
end

@taylorPolynomial:taylorPolynomial graph a b
    # Taylor polynomial at point
    @function __Role Function $a
    @point __Role Attribute $b
    @relation __Pair $function $point
    return $relation
end

@transversal:transversal graph a b
    # Transversal intersecting lines
    @line __Role Attribute $a
    @lines __Role Attribute $b
    @relation __Pair $line $lines
    return $relation
end

@triangle:triangle graph figure component
    @fig __Role Attribute $figure
    @comp __Role Component $component
    @geometry __Pair $fig $comp
    return $geometry
end

@uniformClosure:uniformClosure graph a b
    # Uniform closure of functions
    @eid __Event
    @act __Role Action uniformClosure
    @ctx __Role Context StressCompat
    @functions __Role Attribute $a
    @space __Role Attribute $b
    @application __Role Attribute FunctionApplication
    @result __Bundle $eid $act $functions $space $application $ctx
    return $result
end

@union:union graph set result
    @s __Role Attribute $set
    @r __Role Result $result
    @operation __Pair $s $r
    return $operation
end

@uniquePrimeFactorization:uniquePrimeFactorization graph a b
    # Unique prime factorization
    @number __Role Attribute $a
    @factorization __Role Attribute $b
    @relation __Pair $number $factorization
    return $relation
end

@vandermondSum:vandermondSum graph a b
    # Vandermonde convolution
    @upper __Role Attribute $a
    @lower __Role Attribute $b
    @relation __Pair $upper $lower
    return $relation
end

@vectorAdd:vectorAdd graph a b
    # Vector addition
    @eid __Event
    @act __Role Action vectorAdd
    @ctx __Role Context StressCompat
    @vector1 __Role Attribute $a
    @vector2 __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $vector1 $vector2 $linearAlgebra $ctx
    return $result
end

@zero:zero graph a b
    # Zero element of structure
    @structure __Role Structure $a
    @element __Role Attribute $b
    @relation __Pair $structure $element
    return $relation
end

@zeroVector:zeroVector graph a b
    # Zero vector of space
    @eid __Event
    @act __Role Action zeroVector
    @ctx __Role Context StressCompat
    @space __Role Attribute $a
    @identity __Role Attribute $b
    @linearAlgebra __Role Context VectorSpace
    @result __Bundle $eid $act $space $identity $linearAlgebra $ctx
    return $result
end

# Classical names for easy proof understanding
# =============================================================================

# =============================================================================
# SECTION 1: SET THEORY AXIOMS (ZFC-style)
# =============================================================================

# Extensionality Axiom: Sets with same elements are equal
@:Extensionality_Axiom graph A B
    @all forall ?x
    @inA elementOf ?x A
    @inB elementOf ?x B
    @iff Iff $inA $inB
    @premise And $all $iff
    @conclusion equals A B
    @axiom Implies $premise $conclusion
    return $axiom
end

# Empty Set Axiom: There exists a set with no elements
@:Empty_Set_Axiom graph x
    @forall forall $x
    @notIn Not (elementOf $x EmptySet)
    @axiom Implies $forall $notIn
    return $axiom
end

# Pairing Axiom: For any a,b there exists {a,b}
@:Pairing_Axiom graph a b
    @existsA exists $a
    @existsB exists $b
    @premise And $existsA $existsB
    @conclusion exists (pairSet $a $b)
    @axiom Implies $premise $conclusion
    return $axiom
end

# Union Axiom: Union of sets exists
@:Union_Axiom graph x A F
    @inA elementOf $x A
    @aInF elementOf A F
    @premise And $inA $aInF
    @conclusion elementOf $x (unionOf F)
    @axiom Implies $premise $conclusion
    return $axiom
end

# Power Set Axiom: Power set exists
@:Power_Set_Axiom graph A B
    @premise subsetOf A B
    @conclusion elementOf A (powerSetOf B)
    @axiom Implies $premise $conclusion
    return $axiom
end

# Subset Transitivity
@:Subset_Transitivity graph A B C
    @p1 subsetOf A B
    @p2 subsetOf B C
    @premise And $p1 $p2
    @conclusion subsetOf A C
    @theorem Implies $premise $conclusion
    return $theorem
end

# Element through Subset
@:Element_Through_Subset graph x A B
    @inA elementOf $x A
    @sub subsetOf A B
    @premise And $inA $sub
    @conclusion elementOf $x B
    @theorem Implies $premise $conclusion
    return $theorem
end

# Intersection Definition
@:Intersection_Definition graph x A B
    @inA elementOf $x A
    @inB elementOf $x B
    @premise And $inA $inB
    @conclusion elementOf $x (intersectionOf A B)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Complement Definition
@:Complement_Definition graph x A U
    @inU elementOf $x U
    @notInA Not (elementOf $x A)
    @premise And $inU $notInA
    @conclusion elementOf $x (complementOf A U)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Set Difference
@:Set_Difference graph x A B
    @inA elementOf $x A
    @notInB Not (elementOf $x B)
    @premise And $inA $notInB
    @conclusion elementOf $x (differenceOf A B)
    @theorem Implies $premise $conclusion
    return $theorem
end

# De Morgan's Law 1 for Sets
@:De_Morgan_Sets_1 graph x A B U
    @premise elementOf $x (complementOf (unionOf A B) U)
    @compA complementOf A U
    @compB complementOf B U
    @conclusion elementOf $x (intersectionOf $compA $compB)
    @theorem Implies $premise $conclusion
    return $theorem
end

# De Morgan's Law 2 for Sets
@:De_Morgan_Sets_2 graph x A B U
    @premise elementOf $x (complementOf (intersectionOf A B) U)
    @compA complementOf A U
    @compB complementOf B U
    @conclusion elementOf $x (unionOf $compA $compB)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Distributive Law: Union over Intersection
@:Distributive_Union_Intersection graph x A B C
    @premise elementOf $x (unionOf A (intersectionOf B C))
    @left unionOf A B
    @right unionOf A C
    @conclusion elementOf $x (intersectionOf $left $right)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Distributive Law: Intersection over Union
@:Distributive_Intersection_Union graph x A B C
    @premise elementOf $x (intersectionOf A (unionOf B C))
    @left intersectionOf A B
    @right intersectionOf A C
    @conclusion elementOf $x (unionOf $left $right)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Cartesian Product
@:Cartesian_Product_Definition graph a b A B
    @inA elementOf $a A
    @inB elementOf $b B
    @premise And $inA $inB
    @pair orderedPair $a $b
    @conclusion elementOf $pair (cartesianProduct A B)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Symmetric Difference
@:Symmetric_Difference graph x A B
    @inAnotB And (elementOf $x A) (Not (elementOf $x B))
    @inBnotA And (elementOf $x B) (Not (elementOf $x A))
    @def Or $inAnotB $inBnotA
    @premise elementOf $x (symmetricDiff A B)
    @theorem Iff $premise $def
    return $theorem
end

# =============================================================================
# SECTION 2: PEANO AXIOMS & NUMBER THEORY
# =============================================================================

# Peano Axiom 1: Zero is a natural number
@:Peano_Axiom_1 graph
    @axiom isNatural Zero
    return $axiom
end

# Peano Axiom 2: Successor of natural is natural
@:Peano_Axiom_2 graph n
    @premise isNatural $n
    @conclusion isNatural (successor $n)
    @axiom Implies $premise $conclusion
    return $axiom
end

# Peano Axiom 3: Zero is not a successor
@:Peano_Axiom_3 graph n
    @forall forall $n
    @conclusion Not (equals Zero (successor $n))
    @axiom Implies $forall $conclusion
    return $axiom
end

# Peano Axiom 4: Successor is injective
@:Peano_Axiom_4 graph m n
    @premise equals (successor $m) (successor $n)
    @conclusion equals $m $n
    @axiom Implies $premise $conclusion
    return $axiom
end

# Peano Axiom 5: Mathematical Induction
@:Peano_Induction graph P n
    @base holds P Zero
    @step isNatural $n
    @stepHolds holds P $n
    @stepAnd And $step $stepHolds
    @stepConc holds P (successor $n)
    @stepRule Implies $stepAnd $stepConc
    @premise And $base $stepRule
    @conclusion forall $n (Implies (isNatural $n) (holds P $n))
    @axiom Implies $premise $conclusion
    return $axiom
end

# Addition: Zero case
@:Addition_Zero graph n
    @conclusion equals (add $n Zero) $n
    return $conclusion
end

# Addition: Successor case
@:Addition_Successor graph n m
    @left add $n (successor $m)
    @right successor (add $n $m)
    @conclusion equals $left $right
    return $conclusion
end

# Addition Commutativity
@:Addition_Commutativity graph a b
    @p1 isNatural $a
    @p2 isNatural $b
    @premise And $p1 $p2
    @conclusion equals (add $a $b) (add $b $a)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Addition Associativity
@:Addition_Associativity graph a b c
    @p1 isNatural $a
    @p2 isNatural $b
    @p3 isNatural $c
    @premise And $p1 (And $p2 $p3)
    @left add (add $a $b) $c
    @right add $a (add $b $c)
    @conclusion equals $left $right
    @theorem Implies $premise $conclusion
    return $theorem
end

# Addition Identity
@:Addition_Identity graph n
    @premise isNatural $n
    @conclusion equals (add $n Zero) $n
    @theorem Implies $premise $conclusion
    return $theorem
end

# Multiplication: Zero case
@:Multiplication_Zero graph n
    @conclusion equals (mult $n Zero) Zero
    return $conclusion
end

# Multiplication: Successor case
@:Multiplication_Successor graph n m
    @left mult $n (successor $m)
    @right add $n (mult $n $m)
    @conclusion equals $left $right
    return $conclusion
end

# Multiplication Commutativity
@:Multiplication_Commutativity graph a b
    @p1 isNatural $a
    @p2 isNatural $b
    @premise And $p1 $p2
    @conclusion equals (mult $a $b) (mult $b $a)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Multiplication Associativity
@:Multiplication_Associativity graph a b c
    @p1 isNatural $a
    @p2 isNatural $b
    @p3 isNatural $c
    @premise And $p1 (And $p2 $p3)
    @left mult (mult $a $b) $c
    @right mult $a (mult $b $c)
    @conclusion equals $left $right
    @theorem Implies $premise $conclusion
    return $theorem
end

# Distributive Law
@:Distributive_Law graph a b c
    @p1 isNatural $a
    @p2 isNatural $b
    @p3 isNatural $c
    @premise And $p1 (And $p2 $p3)
    @left mult $a (add $b $c)
    @right add (mult $a $b) (mult $a $c)
    @conclusion equals $left $right
    @theorem Implies $premise $conclusion
    return $theorem
end

# Less-Than-Or-Equal Transitivity
@:Leq_Transitivity graph a b c
    @p1 leq $a $b
    @p2 leq $b $c
    @premise And $p1 $p2
    @conclusion leq $a $c
    @theorem Implies $premise $conclusion
    return $theorem
end

# Antisymmetry of Less-Than-Or-Equal
@:Leq_Antisymmetry graph a b
    @p1 leq $a $b
    @p2 leq $b $a
    @premise And $p1 $p2
    @conclusion equals $a $b
    @theorem Implies $premise $conclusion
    return $theorem
end

# Trichotomy
@:Trichotomy graph a b
    @p1 isNatural $a
    @p2 isNatural $b
    @premise And $p1 $p2
    @lt lessThan $a $b
    @eq equals $a $b
    @gt greaterThan $a $b
    @conclusion Or $lt (Or $eq $gt)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Division Algorithm
@:Division_Algorithm graph a b
    @p1 isNatural $a
    @p2 isNatural $b
    @p3 greaterThan $b Zero
    @premise And $p1 (And $p2 $p3)
    @divides equals $a (add (mult $b ?q) ?r)
    @bounds And (leq Zero ?r) (lessThan ?r $b)
    @conclusion exists ?q ?r (And $divides $bounds)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Prime Definition
@:Prime_Definition graph p
    @p1 isNatural $p
    @p2 greaterThan $p One
    @divisorCond divides ?d $p
    @divisorConc Or (equals ?d One) (equals ?d $p)
    @p3 forall ?d (Implies $divisorCond $divisorConc)
    @premise And $p1 (And $p2 $p3)
    @conclusion isPrime $p
    @theorem Implies $premise $conclusion
    return $theorem
end

# Fundamental Theorem of Arithmetic
@:Fundamental_Theorem_Arithmetic graph n
    @p1 isNatural $n
    @p2 greaterThan $n One
    @premise And $p1 $p2
    @conclusion exists (uniquePrimeFactorization $n)
    @theorem Implies $premise $conclusion
    return $theorem
end

# GCD Commutativity
@:GCD_Commutativity graph a b
    @conclusion equals (gcd $a $b) (gcd $b $a)
    return $conclusion
end

# GCD Divides Both
@:GCD_Divides_Both graph a b
    @d1 divides (gcd $a $b) $a
    @d2 divides (gcd $a $b) $b
    @conclusion And $d1 $d2
    return $conclusion
end

# Bezout's Identity
@:Bezout_Identity graph a b
    @p1 isNatural $a
    @p2 isNatural $b
    @premise And $p1 $p2
    @linear add (mult $a ?x) (mult $b ?y)
    @conclusion exists ?x ?y (equals (gcd $a $b) $linear)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Coprime Definition
@:Coprime_Definition graph a b
    @premise equals (gcd $a $b) One
    @conclusion coprime $a $b
    @theorem Implies $premise $conclusion
    return $theorem
end

# Euclid's Lemma
@:Euclid_Lemma graph p a b
    @p1 isPrime $p
    @p2 divides $p (mult $a $b)
    @premise And $p1 $p2
    @conclusion Or (divides $p $a) (divides $p $b)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Infinitude of Primes
@:Infinitude_Of_Primes graph n
    @p1 isNatural $n
    @conclusion exists ?p (And (isPrime ?p) (greaterThan ?p $n))
    @theorem Implies $p1 $conclusion
    return $theorem
end

# =============================================================================
# SECTION 3: EUCLIDEAN GEOMETRY
# =============================================================================

# Euclid's Postulate 1: Line through two points
@:Euclid_Postulate_1 graph A B
    @p1 isPoint A
    @p2 isPoint B
    @p3 Not (equals A B)
    @premise And $p1 (And $p2 $p3)
    @conclusion existsUnique (lineThrough A B)
    @postulate Implies $premise $conclusion
    return $postulate
end

# Euclid's Postulate 2: Line segment can be extended
@:Euclid_Postulate_2 graph s
    @premise isLineSegment $s
    @conclusion canExtend $s
    @postulate Implies $premise $conclusion
    return $postulate
end

# Euclid's Postulate 3: Circle with center and radius
@:Euclid_Postulate_3 graph C r
    @p1 isPoint C
    @p2 isLength $r
    @premise And $p1 $p2
    @conclusion exists (circleWith C $r)
    @postulate Implies $premise $conclusion
    return $postulate
end

# Euclid's Postulate 4: All right angles are equal
@:Euclid_Postulate_4 graph alpha beta
    @p1 isRightAngle $alpha
    @p2 isRightAngle $beta
    @premise And $p1 $p2
    @conclusion congruent $alpha $beta
    @postulate Implies $premise $conclusion
    return $postulate
end

# Euclid's Postulate 5: Parallel Postulate
@:Euclid_Postulate_5 graph l P
    @p1 isLine $l
    @p2 isPoint P
    @p3 Not (onLine P $l)
    @premise And $p1 (And $p2 $p3)
    @conclusion existsUnique (parallelThrough P $l)
    @postulate Implies $premise $conclusion
    return $postulate
end

# SSS Congruence
@:SSS_Congruence graph A B C D E F
    @s1 congruent (side A B) (side D E)
    @s2 congruent (side B C) (side E F)
    @s3 congruent (side C A) (side F D)
    @premise And $s1 (And $s2 $s3)
    @conclusion congruent (triangle A B C) (triangle D E F)
    @theorem Implies $premise $conclusion
    return $theorem
end

# SAS Congruence
@:SAS_Congruence graph A B C D E F
    @s1 congruent (side A B) (side D E)
    @a1 congruent (angle A B C) (angle D E F)
    @s2 congruent (side B C) (side E F)
    @premise And $s1 (And $a1 $s2)
    @conclusion congruent (triangle A B C) (triangle D E F)
    @theorem Implies $premise $conclusion
    return $theorem
end

# ASA Congruence
@:ASA_Congruence graph A B C D E F
    @a1 congruent (angle C A B) (angle F D E)
    @s1 congruent (side A B) (side D E)
    @a2 congruent (angle A B C) (angle D E F)
    @premise And $a1 (And $s1 $a2)
    @conclusion congruent (triangle A B C) (triangle D E F)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Triangle Angle Sum
@:Triangle_Angle_Sum graph T
    @premise isTriangle T
    @sum sum (angle1 T) (angle2 T) (angle3 T)
    @conclusion equals $sum (degrees 180)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Pythagorean Theorem
@:Pythagorean_Theorem graph T
    @premise isRightTriangle T
    @a leg1 T
    @b leg2 T
    @c hypotenuse T
    @sqA square $a
    @sqB square $b
    @sqC square $c
    @sumLegs add $sqA $sqB
    @conclusion equals $sqC $sumLegs
    @theorem Implies $premise $conclusion
    return $theorem
end

# Converse of Pythagorean Theorem
@:Converse_Pythagorean graph T
    @p1 isTriangle T
    @sqA square (sideA T)
    @sqB square (sideB T)
    @sqC square (sideC T)
    @p2 equals $sqC (add $sqA $sqB)
    @premise And $p1 $p2
    @conclusion isRightTriangle T
    @theorem Implies $premise $conclusion
    return $theorem
end

# Thales' Theorem
@:Thales_Theorem graph C AB P
    @p1 isCircle C
    @p2 isDiameter AB C
    @p3 onCircle P C
    @p4 Not (equals P (endpoint1 AB))
    @p5 Not (equals P (endpoint2 AB))
    @premise And $p1 (And $p2 (And $p3 (And $p4 $p5)))
    @conclusion isRightAngle (angle (endpoint1 AB) P (endpoint2 AB))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Inscribed Angle Theorem
@:Inscribed_Angle_Theorem graph C alpha beta
    @p1 isCircle C
    @p2 isCentralAngle $alpha C
    @p3 isInscribedAngle $beta C
    @p4 sameArc $alpha $beta
    @premise And $p1 (And $p2 (And $p3 $p4))
    @conclusion equals $alpha (mult Two $beta)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Parallel Lines Cut by Transversal
@:Parallel_Transversal graph l1 l2 t
    @p1 parallel $l1 $l2
    @p2 transversal $t $l1 $l2
    @premise And $p1 $p2
    @alt congruent (alternateInterior $t $l1) (alternateInterior $t $l2)
    @corr congruent (corresponding $t $l1) (corresponding $t $l2)
    @supp supplementary (coInterior $t $l1) (coInterior $t $l2)
    @conclusion And $alt (And $corr $supp)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Triangle Inequality
@:Triangle_Inequality graph A B C
    @premise isTriangle A B C
    @ineq1 lessThan (distance A B) (add (distance A C) (distance C B))
    @ineq2 lessThan (distance A C) (add (distance A B) (distance B C))
    @ineq3 lessThan (distance B C) (add (distance A B) (distance A C))
    @conclusion And $ineq1 (And $ineq2 $ineq3)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Midpoint Theorem
@:Midpoint_Theorem graph A B C M N
    @p1 isMidpoint M A B
    @p2 isMidpoint N A C
    @premise And $p1 $p2
    @segMN segment M N
    @segBC segment B C
    @par parallel $segMN $segBC
    @half equals (length $segMN) (divide (length $segBC) Two)
    @conclusion And $par $half
    @theorem Implies $premise $conclusion
    return $theorem
end

# Triangle Area Formula
@:Triangle_Area graph T
    @premise isTriangle T
    @bh mult (base T) (height T)
    @conclusion equals (area T) (divide $bh Two)
    @theorem Implies $premise $conclusion
    return $theorem
end

# AA Similarity Criterion
@:AA_Similarity graph T1 T2
    @p1 isTriangle T1
    @p2 isTriangle T2
    @p3 congruent (angle1 T1) (angle1 T2)
    @p4 congruent (angle2 T1) (angle2 T2)
    @premise And $p1 (And $p2 (And $p3 $p4))
    @conclusion similar T1 T2
    @theorem Implies $premise $conclusion
    return $theorem
end

# Similar Triangles Have Proportional Sides
@:Similar_Proportional_Sides graph T1 T2
    @premise similar T1 T2
    @r1 ratio (side1 T1) (side1 T2)
    @r2 ratio (side2 T1) (side2 T2)
    @conclusion equals $r1 $r2
    @theorem Implies $premise $conclusion
    return $theorem
end

# Circle Area
@:Circle_Area graph C
    @premise isCircle C
    @r radius C
    @conclusion equals (area C) (mult Pi (square $r))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Circle Circumference
@:Circle_Circumference graph C
    @premise isCircle C
    @r radius C
    @conclusion equals (circumference C) (mult (mult Two Pi) $r)
    @theorem Implies $premise $conclusion
    return $theorem
end

# =============================================================================
# SECTION 4: GROUP THEORY
# =============================================================================

# Group Closure Axiom
@:Group_Closure graph G a b
    @p1 isGroup G
    @p2 elementOf $a G
    @p3 elementOf $b G
    @premise And $p1 (And $p2 $p3)
    @conclusion elementOf (op G $a $b) G
    @axiom Implies $premise $conclusion
    return $axiom
end

# Group Associativity Axiom
@:Group_Associativity graph G a b c
    @p1 isGroup G
    @p2 elementOf $a G
    @p3 elementOf $b G
    @p4 elementOf $c G
    @premise And $p1 (And $p2 (And $p3 $p4))
    @left op G (op G $a $b) $c
    @right op G $a (op G $b $c)
    @conclusion equals $left $right
    @axiom Implies $premise $conclusion
    return $axiom
end

# Group Identity Axiom
@:Group_Identity graph G a
    @p1 isGroup G
    @p2 elementOf $a G
    @premise And $p1 $p2
    @e identity G
    @left equals (op G $e $a) $a
    @right equals (op G $a $e) $a
    @conclusion And $left $right
    @axiom Implies $premise $conclusion
    return $axiom
end

# Group Inverse Axiom
@:Group_Inverse graph G a
    @p1 isGroup G
    @p2 elementOf $a G
    @premise And $p1 $p2
    @e identity G
    @inv inverse G $a
    @left equals (op G $a $inv) $e
    @right equals (op G $inv $a) $e
    @conclusion And $left $right
    @axiom Implies $premise $conclusion
    return $axiom
end

# Abelian Group Property
@:Abelian_Property graph G a b
    @p1 isAbelianGroup G
    @p2 elementOf $a G
    @p3 elementOf $b G
    @premise And $p1 (And $p2 $p3)
    @conclusion equals (op G $a $b) (op G $b $a)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Subgroup Criterion
@:Subgroup_Criterion graph G H a b
    @p1 isGroup G
    @p2 subsetOf H G
    @p3 Not (equals H EmptySet)
    @closure elementOf $a H
    @closureB elementOf $b H
    @closurePrem And $closure $closureB
    @closureConc elementOf (op G $a (inverse G $b)) H
    @p4 forall $a $b (Implies $closurePrem $closureConc)
    @premise And $p1 (And $p2 (And $p3 $p4))
    @conclusion isSubgroup H G
    @theorem Implies $premise $conclusion
    return $theorem
end

# Lagrange's Theorem
@:Lagrange_Theorem graph G H
    @p1 isFiniteGroup G
    @p2 isSubgroup H G
    @premise And $p1 $p2
    @conclusion divides (order H) (order G)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Coset Cardinality
@:Coset_Cardinality graph G H a
    @p1 isGroup G
    @p2 isSubgroup H G
    @p3 elementOf $a G
    @premise And $p1 (And $p2 $p3)
    @conclusion equals (cardinality (leftCoset $a H)) (cardinality H)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Normal Subgroup Definition
@:Normal_Subgroup graph G N g
    @p1 isSubgroup N G
    @cosetEq forall $g (Implies (elementOf $g G) (equals (leftCoset $g N) (rightCoset $g N)))
    @premise And $p1 $cosetEq
    @conclusion isNormalSubgroup N G
    @theorem Implies $premise $conclusion
    return $theorem
end

# First Isomorphism Theorem
@:First_Isomorphism_Theorem graph G H phi
    @premise isHomomorphism $phi G H
    @quotient quotientGroup G (kernel $phi)
    @img image $phi
    @conclusion isIsomorphic $quotient $img
    @theorem Implies $premise $conclusion
    return $theorem
end

# Cyclic Group Has Generator
@:Cyclic_Generator graph G g
    @premise isCyclicGroup G
    @conclusion exists $g (equals G (generatedBy $g))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Cyclic Groups Are Abelian
@:Cyclic_Is_Abelian graph G
    @premise isCyclicGroup G
    @conclusion isAbelianGroup G
    @theorem Implies $premise $conclusion
    return $theorem
end

# Ring Additive Structure
@:Ring_Additive graph R
    @premise isRing R
    @conclusion isAbelianGroup (additiveGroup R)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Ring Distributivity
@:Ring_Distributivity graph R a b c
    @p1 isRing R
    @p2 elementOf $a R
    @p3 elementOf $b R
    @p4 elementOf $c R
    @premise And $p1 (And $p2 (And $p3 $p4))
    @leftDist equals (mult R $a (add R $b $c)) (add R (mult R $a $b) (mult R $a $c))
    @rightDist equals (mult R (add R $a $b) $c) (add R (mult R $a $c) (mult R $b $c))
    @conclusion And $leftDist $rightDist
    @theorem Implies $premise $conclusion
    return $theorem
end

# Field Has Multiplicative Inverses
@:Field_Inverse graph F a
    @p1 isField F
    @p2 elementOf $a F
    @p3 Not (equals $a (zero F))
    @premise And $p1 (And $p2 $p3)
    @conclusion exists (multiplicativeInverse F $a)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Vector Space Closure
@:Vector_Space_Closure graph V F u v
    @p1 isVectorSpace V F
    @p2 elementOf $u V
    @p3 elementOf $v V
    @premise And $p1 (And $p2 $p3)
    @conclusion elementOf (vectorAdd V $u $v) V
    @theorem Implies $premise $conclusion
    return $theorem
end

# Scalar Multiplication Closure
@:Scalar_Mult_Closure graph V F c v
    @p1 isVectorSpace V F
    @p2 elementOf $c F
    @p3 elementOf $v V
    @premise And $p1 (And $p2 $p3)
    @conclusion elementOf (scalarMult V $c $v) V
    @theorem Implies $premise $conclusion
    return $theorem
end

# Linear Independence Definition
@:Linear_Independence graph V F S
    @p1 isVectorSpace V F
    @p2 isSetOfVectors S V
    @trivialCond And (equals (linearComb ?coeffs S) (zeroVector V)) (Not (allZero ?coeffs))
    @p3 forall ?coeffs (Implies $trivialCond False)
    @premise And $p1 (And $p2 $p3)
    @conclusion linearlyIndependent S
    @theorem Implies $premise $conclusion
    return $theorem
end

# Basis Definition
@:Basis_Definition graph V B
    @p1 linearlyIndependent B
    @p2 spans B V
    @premise And $p1 $p2
    @conclusion isBasis B V
    @theorem Implies $premise $conclusion
    return $theorem
end

# Dimension Theorem
@:Dimension_Theorem graph V B1 B2
    @p1 isFiniteDimensional V
    @p2 isBasis B1 V
    @p3 isBasis B2 V
    @premise And $p1 (And $p2 $p3)
    @conclusion equals (cardinality B1) (cardinality B2)
    @theorem Implies $premise $conclusion
    return $theorem
end

# =============================================================================
# SECTION 5: LOGIC & PROOF THEORY
# =============================================================================

# Modus Ponens
@:Modus_Ponens graph P Q
    @p1 isTrue P
    @p2 isTrue (implies P Q)
    @premise And $p1 $p2
    @conclusion isTrue Q
    @rule Implies $premise $conclusion
    return $rule
end

# Modus Tollens
@:Modus_Tollens graph P Q
    @p1 isTrue (not Q)
    @p2 isTrue (implies P Q)
    @premise And $p1 $p2
    @conclusion isTrue (not P)
    @rule Implies $premise $conclusion
    return $rule
end

# Hypothetical Syllogism
@:Hypothetical_Syllogism graph P Q R
    @p1 isTrue (implies P Q)
    @p2 isTrue (implies Q R)
    @premise And $p1 $p2
    @conclusion isTrue (implies P R)
    @rule Implies $premise $conclusion
    return $rule
end

# Disjunctive Syllogism
@:Disjunctive_Syllogism graph P Q
    @p1 isTrue (or P Q)
    @p2 isTrue (not P)
    @premise And $p1 $p2
    @conclusion isTrue Q
    @rule Implies $premise $conclusion
    return $rule
end

# Constructive Dilemma
@:Constructive_Dilemma graph P Q R S
    @p1 isTrue (or P Q)
    @p2 isTrue (implies P R)
    @p3 isTrue (implies Q S)
    @premise And $p1 (And $p2 $p3)
    @conclusion isTrue (or R S)
    @rule Implies $premise $conclusion
    return $rule
end

# Double Negation Elimination
@:Double_Negation_Elimination graph P
    @premise isTrue (not (not P))
    @conclusion isTrue P
    @rule Implies $premise $conclusion
    return $rule
end

# Double Negation Introduction
@:Double_Negation_Introduction graph P
    @premise isTrue P
    @conclusion isTrue (not (not P))
    @rule Implies $premise $conclusion
    return $rule
end

# De Morgan's Law 1 (Logic)
@:De_Morgan_Logic_1 graph P Q
    @premise isTrue (not (and P Q))
    @conclusion isTrue (or (not P) (not Q))
    @rule Implies $premise $conclusion
    return $rule
end

# De Morgan's Law 2 (Logic)
@:De_Morgan_Logic_2 graph P Q
    @premise isTrue (not (or P Q))
    @conclusion isTrue (and (not P) (not Q))
    @rule Implies $premise $conclusion
    return $rule
end

# Contraposition
@:Contraposition graph P Q
    @premise isTrue (implies P Q)
    @conclusion isTrue (implies (not Q) (not P))
    @rule Implies $premise $conclusion
    return $rule
end

# Law of Excluded Middle
@:Excluded_Middle graph P
    @forall forall P
    @conclusion isTrue (or P (not P))
    @law Implies $forall $conclusion
    return $law
end

# Conjunction Introduction
@:Conjunction_Introduction graph P Q
    @p1 isTrue P
    @p2 isTrue Q
    @premise And $p1 $p2
    @conclusion isTrue (and P Q)
    @rule Implies $premise $conclusion
    return $rule
end

# Conjunction Elimination
@:Conjunction_Elimination graph P Q
    @premise isTrue (and P Q)
    @c1 isTrue P
    @c2 isTrue Q
    @conclusion And $c1 $c2
    @rule Implies $premise $conclusion
    return $rule
end

# Disjunction Introduction
@:Disjunction_Introduction graph P Q
    @premise isTrue P
    @conclusion isTrue (or P Q)
    @rule Implies $premise $conclusion
    return $rule
end

# Universal Instantiation
@:Universal_Instantiation graph P x a
    @premise isTrue (forall $x (holds P $x))
    @conclusion isTrue (holds P $a)
    @rule Implies $premise $conclusion
    return $rule
end

# Universal Generalization
@:Universal_Generalization graph P a x
    @p1 isTrue (holds P $a)
    @p2 isArbitrary $a
    @premise And $p1 $p2
    @conclusion isTrue (forall $x (holds P $x))
    @rule Implies $premise $conclusion
    return $rule
end

# Existential Instantiation
@:Existential_Instantiation graph P x c
    @premise isTrue (exists $x (holds P $x))
    @witness isWitness $c
    @holds isTrue (holds P $c)
    @conclusion exists $c (And $witness $holds)
    @rule Implies $premise $conclusion
    return $rule
end

# Existential Generalization
@:Existential_Generalization graph P a x
    @premise isTrue (holds P $a)
    @conclusion isTrue (exists $x (holds P $x))
    @rule Implies $premise $conclusion
    return $rule
end

# Reductio ad Absurdum
@:Reductio_Ad_Absurdum graph P
    @p1 isAssumption P
    @p2 derives P Contradiction
    @premise And $p1 $p2
    @conclusion isTrue (not P)
    @rule Implies $premise $conclusion
    return $rule
end

# =============================================================================
# SECTION 6: REAL ANALYSIS
# =============================================================================

# Limit Definition (Epsilon-Delta)
@:Limit_Definition graph f a L
    @p1 isFunction $f
    @p2 inDomain $a $f
    @deltaCond And (lessThan Zero (abs (subtract ?x $a))) (lessThan (abs (subtract ?x $a)) ?delta)
    @epsCond lessThan (abs (subtract (apply $f ?x) L)) ?epsilon
    @deltaExists exists ?delta (And (greaterThan ?delta Zero) (forall ?x (Implies $deltaCond $epsCond)))
    @p3 forall ?epsilon (Implies (greaterThan ?epsilon Zero) $deltaExists)
    @premise And $p1 (And $p2 $p3)
    @conclusion equals (limitAt $f $a) L
    @definition Implies $premise $conclusion
    return $definition
end

# Continuity Definition
@:Continuity_Definition graph f a
    @p1 isFunction $f
    @p2 inDomain $a $f
    @p3 equals (limitAt $f $a) (apply $f $a)
    @premise And $p1 (And $p2 $p3)
    @conclusion isContinuousAt $f $a
    @definition Implies $premise $conclusion
    return $definition
end

# Sum of Continuous Functions
@:Continuous_Sum graph f g a
    @p1 isContinuousAt $f $a
    @p2 isContinuousAt $g $a
    @premise And $p1 $p2
    @conclusion isContinuousAt (functionSum $f $g) $a
    @theorem Implies $premise $conclusion
    return $theorem
end

# Product of Continuous Functions
@:Continuous_Product graph f g a
    @p1 isContinuousAt $f $a
    @p2 isContinuousAt $g $a
    @premise And $p1 $p2
    @conclusion isContinuousAt (functionProduct $f $g) $a
    @theorem Implies $premise $conclusion
    return $theorem
end

# Intermediate Value Theorem
@:Intermediate_Value_Theorem graph f a b y
    @p1 isContinuousOn $f (closedInterval $a $b)
    @p2 isBetween $y (apply $f $a) (apply $f $b)
    @premise And $p1 $p2
    @inInterval isBetween ?c $a $b
    @equals equals (apply $f ?c) $y
    @conclusion exists ?c (And $inInterval $equals)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Extreme Value Theorem
@:Extreme_Value_Theorem graph f a b
    @premise isContinuousOn $f (closedInterval $a $b)
    @max attainsMaximum $f (closedInterval $a $b)
    @min attainsMinimum $f (closedInterval $a $b)
    @conclusion And $max $min
    @theorem Implies $premise $conclusion
    return $theorem
end

# Derivative Definition
@:Derivative_Definition graph f x
    @p1 isFunction $f
    @diffQuot quotient (subtract (apply $f (add $x ?h)) (apply $f $x)) ?h
    @p2 exists (limitAt $diffQuot Zero)
    @premise And $p1 $p2
    @conclusion equals (derivativeAt $f $x) (limitAt $diffQuot Zero)
    @definition Implies $premise $conclusion
    return $definition
end

# Differentiable Implies Continuous
@:Differentiable_Implies_Continuous graph f a
    @premise isDifferentiableAt $f $a
    @conclusion isContinuousAt $f $a
    @theorem Implies $premise $conclusion
    return $theorem
end

# Power Rule
@:Power_Rule graph x n
    @premise equals ?f (power $x $n)
    @conclusion equals (derivative ?f) (mult $n (power $x (subtract $n One)))
    @rule Implies $premise $conclusion
    return $rule
end

# Product Rule
@:Product_Rule graph f g
    @d1 mult (derivative $f) $g
    @d2 mult $f (derivative $g)
    @conclusion equals (derivative (product $f $g)) (add $d1 $d2)
    return $conclusion
end

# Quotient Rule
@:Quotient_Rule graph f g
    @num subtract (mult (derivative $f) $g) (mult $f (derivative $g))
    @den square $g
    @conclusion equals (derivative (quotient $f $g)) (quotient $num $den)
    return $conclusion
end

# Chain Rule
@:Chain_Rule graph f g
    @outer compose (derivative $f) $g
    @inner derivative $g
    @conclusion equals (derivative (compose $f $g)) (product $outer $inner)
    return $conclusion
end

# Mean Value Theorem
@:Mean_Value_Theorem graph f a b
    @p1 isContinuousOn $f (closedInterval $a $b)
    @p2 isDifferentiableOn $f (openInterval $a $b)
    @premise And $p1 $p2
    @inInterval isBetween ?c $a $b
    @avgRate quotient (subtract (apply $f $b) (apply $f $a)) (subtract $b $a)
    @derivEq equals (derivativeAt $f ?c) $avgRate
    @conclusion exists ?c (And $inInterval $derivEq)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Rolle's Theorem
@:Rolle_Theorem graph f a b
    @p1 isContinuousOn $f (closedInterval $a $b)
    @p2 isDifferentiableOn $f (openInterval $a $b)
    @p3 equals (apply $f $a) (apply $f $b)
    @premise And $p1 (And $p2 $p3)
    @inInterval isBetween ?c $a $b
    @derivZero equals (derivativeAt $f ?c) Zero
    @conclusion exists ?c (And $inInterval $derivZero)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Fundamental Theorem of Calculus (Part 1)
@:FTC_Part_1 graph f a
    @p1 isContinuousOn $f (closedInterval $a ?b)
    @F integralFrom $a $f
    @premise $p1
    @conclusion isDifferentiableOn F (openInterval $a ?b)
    @theorem Implies $premise $conclusion
    return $theorem
end

# FTC Part 1 - Derivative Form
@:FTC_Derivative graph f a
    @p1 isContinuousOn $f (closedInterval $a ?b)
    @F integralFrom $a $f
    @premise $p1
    @conclusion equals (derivative F) $f
    @theorem Implies $premise $conclusion
    return $theorem
end

# Fundamental Theorem of Calculus (Part 2)
@:FTC_Part_2 graph f a b F
    @p1 isContinuousOn $f (closedInterval $a $b)
    @p2 isAntiderivative F $f
    @premise And $p1 $p2
    @conclusion equals (definiteIntegral $f $a $b) (subtract (apply F $b) (apply F $a))
    @theorem Implies $premise $conclusion
    return $theorem
end

# =============================================================================
# SECTION 7: PROBABILITY THEORY
# =============================================================================

# Probability Axiom 1: Non-negativity and bounds
@:Probability_Axiom_1 graph Omega Sigma P A
    @premise isProbabilitySpace Omega Sigma P
    @geqZero geq (P A) Zero
    @leqOne leq (P A) One
    @conclusion And $geqZero $leqOne
    @axiom Implies $premise $conclusion
    return $axiom
end

# Probability Axiom 2: Sample space has probability 1
@:Probability_Axiom_2 graph Omega Sigma P
    @premise isProbabilitySpace Omega Sigma P
    @conclusion equals (P Omega) One
    @axiom Implies $premise $conclusion
    return $axiom
end

# Probability Axiom 3: Countable additivity
@:Probability_Axiom_3 graph Omega Sigma P A B
    @p1 isProbabilitySpace Omega Sigma P
    @p2 disjoint A B
    @premise And $p1 $p2
    @conclusion equals (P (union A B)) (add (P A) (P B))
    @axiom Implies $premise $conclusion
    return $axiom
end

# Complement Rule
@:Complement_Rule graph Omega Sigma P A
    @p1 isProbabilitySpace Omega Sigma P
    @p2 inSigmaAlgebra A Sigma
    @premise And $p1 $p2
    @conclusion equals (P (complement A)) (subtract One (P A))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Addition Rule (General)
@:Addition_Rule graph P A B
    @sum add (P A) (P B)
    @inter P (intersection A B)
    @conclusion equals (P (union A B)) (subtract $sum $inter)
    return $conclusion
end

# Conditional Probability Definition
@:Conditional_Probability graph P A B
    @premise greaterThan (P B) Zero
    @num P (intersection A B)
    @den P B
    @conclusion equals (conditionalP A B) (divide $num $den)
    @definition Implies $premise $conclusion
    return $definition
end

# Multiplication Rule
@:Multiplication_Rule graph P A B
    @premise greaterThan (P B) Zero
    @conclusion equals (P (intersection A B)) (mult (P B) (conditionalP A B))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Independence Definition
@:Independence_Definition graph P A B
    @premise equals (P (intersection A B)) (mult (P A) (P B))
    @conclusion independent A B
    @definition Implies $premise $conclusion
    return $definition
end

# Bayes' Theorem
@:Bayes_Theorem graph P A B
    @p1 greaterThan (P B) Zero
    @p2 greaterThan (P A) Zero
    @premise And $p1 $p2
    @num mult (conditionalP B A) (P A)
    @den P B
    @conclusion equals (conditionalP A B) (divide $num $den)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Law of Total Probability
@:Total_Probability graph P A B1 Bn Omega
    @premise isPartition B1 Bn Omega
    @term mult (conditionalP A ?Bi) (P ?Bi)
    @conclusion equals (P A) (sum $term)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Expected Value Linearity
@:Expected_Value_Linearity graph X Y
    @p1 isRandomVariable X
    @p2 isRandomVariable Y
    @premise And $p1 $p2
    @conclusion equals (E (add X Y)) (add (E X) (E Y))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Expected Value Scaling
@:Expected_Value_Scaling graph X c
    @p1 isRandomVariable X
    @p2 isConstant $c
    @premise And $p1 $p2
    @conclusion equals (E (mult $c X)) (mult $c (E X))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Variance Definition
@:Variance_Definition graph X
    @premise isRandomVariable X
    @sq E (square X)
    @mu E X
    @conclusion equals (Var X) (subtract $sq (square $mu))
    @definition Implies $premise $conclusion
    return $definition
end

# Variance Scaling
@:Variance_Scaling graph X c
    @p1 isRandomVariable X
    @p2 isConstant $c
    @premise And $p1 $p2
    @conclusion equals (Var (mult $c X)) (mult (square $c) (Var X))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Chebyshev's Inequality
@:Chebyshev_Inequality graph X k
    @p1 isRandomVariable X
    @p2 greaterThan $k Zero
    @premise And $p1 $p2
    @dev abs (subtract X (E X))
    @threshold mult $k (sqrt (Var X))
    @prob P (geq $dev $threshold)
    @bound divide One (square $k)
    @conclusion leq $prob $bound
    @theorem Implies $premise $conclusion
    return $theorem
end

# Law of Large Numbers (Weak)
@:Law_Large_Numbers graph X1 Xn
    @p1 areIID X1 Xn
    @p2 hasFiniteExpectation X1
    @premise And $p1 $p2
    @mean sampleMean X1 Xn
    @mu E X1
    @conclusion convergesInProbability $mean $mu
    @theorem Implies $premise $conclusion
    return $theorem
end

# Central Limit Theorem
@:Central_Limit_Theorem graph X1 Xn
    @p1 areIID X1 Xn
    @p2 hasFiniteMean X1
    @p3 hasFiniteVariance X1
    @premise And $p1 (And $p2 $p3)
    @stdSum standardizedSum X1 Xn
    @conclusion convergesInDistribution $stdSum StandardNormal
    @theorem Implies $premise $conclusion
    return $theorem
end

# =============================================================================
# SECTION 8: ADDITIONAL THEOREMS AND FACTS
# =============================================================================

# Well-Ordering Principle
@:Well_Ordering_Principle graph S
    @p1 subsetOf S NaturalNumbers
    @p2 Not (equals S EmptySet)
    @premise And $p1 $p2
    @conclusion exists (minimum S)
    @principle Implies $premise $conclusion
    return $principle
end

# Archimedean Property
@:Archimedean_Property graph x y
    @p1 isReal $x
    @p2 isReal $y
    @p3 greaterThan $x Zero
    @premise And $p1 (And $p2 $p3)
    @conclusion exists ?n (And (isNatural ?n) (greaterThan (mult ?n $x) $y))
    @property Implies $premise $conclusion
    return $property
end

# Density of Rationals
@:Density_Rationals graph a b
    @p1 isReal $a
    @p2 isReal $b
    @p3 lessThan $a $b
    @premise And $p1 (And $p2 $p3)
    @conclusion exists ?q (And (isRational ?q) (And (lessThan $a ?q) (lessThan ?q $b)))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Completeness of Reals (Least Upper Bound)
@:Completeness_Reals graph S
    @p1 subsetOf S RealNumbers
    @p2 Not (equals S EmptySet)
    @p3 hasBoundAbove S
    @premise And $p1 (And $p2 $p3)
    @conclusion exists (supremum S)
    @axiom Implies $premise $conclusion
    return $axiom
end

# Bolzano-Weierstrass Theorem
@:Bolzano_Weierstrass graph seq
    @premise isBoundedSequence $seq
    @conclusion hasConvergentSubsequence $seq
    @theorem Implies $premise $conclusion
    return $theorem
end

# Cauchy Criterion for Convergence
@:Cauchy_Criterion graph seq
    @p1 isSequence $seq
    @p2 isCauchySequence $seq
    @premise And $p1 $p2
    @conclusion isConvergent $seq
    @theorem Implies $premise $conclusion
    return $theorem
end

# Monotone Convergence Theorem
@:Monotone_Convergence graph seq
    @p1 isMonotone $seq
    @p2 isBounded $seq
    @premise And $p1 $p2
    @conclusion isConvergent $seq
    @theorem Implies $premise $conclusion
    return $theorem
end

# L'Hopital's Rule
@:L_Hopital_Rule graph f g a
    @p1 equals (limitAt $f $a) Zero
    @p2 equals (limitAt $g $a) Zero
    @p3 exists (limitAt (quotient (derivative $f) (derivative $g)) $a)
    @premise And $p1 (And $p2 $p3)
    @conclusion equals (limitAt (quotient $f $g) $a) (limitAt (quotient (derivative $f) (derivative $g)) $a)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Taylor's Theorem
@:Taylor_Theorem graph f a n
    @p1 hasDerivativeOfOrder $f $n
    @premise $p1
    @taylor taylorPolynomial $f $a $n
    @remainder remainder $f $a $n
    @conclusion equals $f (add $taylor $remainder)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Fermat's Little Theorem
@:Fermat_Little_Theorem graph a p
    @p1 isPrime $p
    @p2 Not (divides $p $a)
    @premise And $p1 $p2
    @conclusion congruent (power $a (subtract $p One)) One $p
    @theorem Implies $premise $conclusion
    return $theorem
end

# Euler's Theorem
@:Euler_Theorem graph a n
    @p1 coprime $a $n
    @premise $p1
    @phi eulerPhi $n
    @conclusion congruent (power $a $phi) One $n
    @theorem Implies $premise $conclusion
    return $theorem
end

# Chinese Remainder Theorem
@:Chinese_Remainder_Theorem graph m n
    @premise coprime $m $n
    @exists forall ?a ?b (exists ?x (And (congruent ?x ?a $m) (congruent ?x ?b $n)))
    @unique modulo (mult $m $n)
    @conclusion And $exists $unique
    @theorem Implies $premise $conclusion
    return $theorem
end

# Quadratic Reciprocity (simplified statement)
@:Quadratic_Reciprocity graph p q
    @p1 isPrime $p
    @p2 isPrime $q
    @p3 greaterThan $p Two
    @p4 greaterThan $q Two
    @p5 Not (equals $p $q)
    @premise And $p1 (And $p2 (And $p3 (And $p4 $p5)))
    @leg1 legendreSymbol $p $q
    @leg2 legendreSymbol $q $p
    @exp divide (mult (subtract $p One) (subtract $q One)) 4
    @conclusion equals (mult $leg1 $leg2) (power (negate One) $exp)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Cauchy-Schwarz Inequality
@:Cauchy_Schwarz graph u v V
    @p1 isInnerProductSpace V
    @p2 elementOf $u V
    @p3 elementOf $v V
    @premise And $p1 (And $p2 $p3)
    @lhs abs (innerProduct $u $v)
    @rhs mult (norm $u) (norm $v)
    @conclusion leq $lhs $rhs
    @theorem Implies $premise $conclusion
    return $theorem
end

# Triangle Inequality for Norms
@:Norm_Triangle_Inequality graph u v V
    @p1 isNormedSpace V
    @p2 elementOf $u V
    @p3 elementOf $v V
    @premise And $p1 (And $p2 $p3)
    @conclusion leq (norm (add $u $v)) (add (norm $u) (norm $v))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Rank-Nullity Theorem
@:Rank_Nullity_Theorem graph T V W
    @p1 isLinearMap T V W
    @p2 isFiniteDimensional V
    @premise And $p1 $p2
    @r rank T
    @n nullity T
    @d dimension V
    @conclusion equals (add $r $n) $d
    @theorem Implies $premise $conclusion
    return $theorem
end

# Cayley-Hamilton Theorem
@:Cayley_Hamilton graph A
    @premise isSquareMatrix A
    @charPoly characteristicPolynomial A
    @conclusion equals (evaluateAt $charPoly A) ZeroMatrix
    @theorem Implies $premise $conclusion
    return $theorem
end

# Spectral Theorem (for symmetric matrices)
@:Spectral_Theorem graph A
    @premise isSymmetricMatrix A
    @orthonormal hasOrthonormalEigenbasis A
    @real hasRealEigenvalues A
    @conclusion And $orthonormal $real
    @theorem Implies $premise $conclusion
    return $theorem
end

# =============================================================================
# SECTION 9: MORE CLASSICAL THEOREMS
# =============================================================================

# Heine-Borel Theorem
@:Heine_Borel graph S
    @p1 subsetOf S RealNumbers
    @p2 isClosed S
    @p3 isBounded S
    @premise And $p1 (And $p2 $p3)
    @conclusion isCompact S
    @theorem Implies $premise $conclusion
    return $theorem
end

# Cantor's Theorem (cardinality)
@:Cantor_Theorem graph A
    @premise isSet A
    @powerset powerSetOf A
    @conclusion Not (existsBijection A $powerset)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Schroeder-Bernstein Theorem
@:Schroeder_Bernstein graph A B
    @p1 existsInjection A B
    @p2 existsInjection B A
    @premise And $p1 $p2
    @conclusion existsBijection A B
    @theorem Implies $premise $conclusion
    return $theorem
end

# Pigeon-Hole Principle
@:Pigeon_Hole_Principle graph n m f
    @p1 isNatural $n
    @p2 isNatural $m
    @p3 greaterThan $n $m
    @p4 isFunction $f
    @p5 hasDomain $f (setOfSize $n)
    @p6 hasCodomain $f (setOfSize $m)
    @premise And $p1 (And $p2 (And $p3 (And $p4 (And $p5 $p6))))
    @conclusion Not (isInjective $f)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Wilson's Theorem
@:Wilson_Theorem graph p
    @premise isPrime $p
    @factorial factorial (subtract $p One)
    @conclusion congruent $factorial (negate One) $p
    @theorem Implies $premise $conclusion
    return $theorem
end

# Binomial Theorem
@:Binomial_Theorem graph x y n
    @p1 isNatural $n
    @premise $p1
    @power power (add $x $y) $n
    @sum binomialSum $x $y $n
    @conclusion equals $power $sum
    @theorem Implies $premise $conclusion
    return $theorem
end

# Vandermonde's Identity
@:Vandermonde_Identity graph m n r
    @p1 isNatural $m
    @p2 isNatural $n
    @p3 isNatural $r
    @premise And $p1 (And $p2 $p3)
    @lhs binomial (add $m $n) $r
    @rhs vandermondSum $m $n $r
    @conclusion equals $lhs $rhs
    @theorem Implies $premise $conclusion
    return $theorem
end

# Squeeze Theorem
@:Squeeze_Theorem graph f g h a L
    @p1 leq (apply $f ?x) (apply $g ?x)
    @p2 leq (apply $g ?x) (apply $h ?x)
    @p3 equals (limitAt $f $a) L
    @p4 equals (limitAt $h $a) L
    @premise And $p1 (And $p2 (And $p3 $p4))
    @conclusion equals (limitAt $g $a) L
    @theorem Implies $premise $conclusion
    return $theorem
end

# Weierstrass Approximation Theorem
@:Weierstrass_Approximation graph f a b epsilon
    @p1 isContinuousOn $f (closedInterval $a $b)
    @p2 greaterThan $epsilon Zero
    @premise And $p1 $p2
    @poly isPolynomial ?p
    @bound lessThan (abs (subtract (apply $f ?x) (apply ?p ?x))) $epsilon
    @forall forall ?x (Implies (isBetween ?x $a $b) $bound)
    @conclusion exists ?p (And $poly $forall)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Stone-Weierstrass Theorem (simplified)
@:Stone_Weierstrass graph X A
    @p1 isCompact X
    @p2 isSubalgebra A (continuousFunctions X)
    @p3 separatesPoints A
    @p4 containsConstants A
    @premise And $p1 (And $p2 (And $p3 $p4))
    @closure uniformClosure A
    @conclusion equals $closure (continuousFunctions X)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Lebesgue Dominated Convergence
@:Lebesgue_Dominated_Convergence graph fn f g
    @p1 convergesPointwise $fn $f
    @p2 dominatedBy $fn $g
    @p3 isIntegrable $g
    @premise And $p1 (And $p2 $p3)
    @conclusion equals (limitOf (integral $fn)) (integral $f)
    @theorem Implies $premise $conclusion
    return $theorem
end

# Fubini's Theorem
@:Fubini_Theorem graph f X Y
    @p1 isIntegrable $f (productSpace X Y)
    @premise $p1
    @double doubleIntegral $f X Y
    @iterated iteratedIntegral $f X Y
    @conclusion equals $double $iterated
    @theorem Implies $premise $conclusion
    return $theorem
end

# Sylow's First Theorem
@:Sylow_First_Theorem graph G p
    @p1 isFiniteGroup G
    @p2 isPrime $p
    @p3 divides (power $p ?k) (order G)
    @premise And $p1 (And $p2 $p3)
    @conclusion exists ?H (And (isSubgroup ?H G) (equals (order ?H) (power $p ?k)))
    @theorem Implies $premise $conclusion
    return $theorem
end

# Burnside's Lemma
@:Burnside_Lemma graph G X
    @p1 isFiniteGroup G
    @p2 actsOn G X
    @premise And $p1 $p2
    @orbits numberOfOrbits G X
    @avg averageFixedPoints G X
    @conclusion equals $orbits $avg
    @theorem Implies $premise $conclusion
    return $theorem
end


